[{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\apiMiddleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":190,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":190,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\n\nexport interface AuthConfig {\n  method: 'api_key' | 'jwt_token' | 'local_only' | 'oauth2';\n  apiKeys: string[];\n  jwtSecret: string;\n  localOnly: boolean;\n  oauth2: {\n    providers: string[];\n    clientId?: string;\n    clientSecret?: string;\n    redirectUri?: string;\n    scope?: string;\n  };\n  roles: {\n    admin: string[];\n    agent: string[];\n    readonly: string[];\n    limited: string[];\n  };\n  quotas: {\n    admin: {\n      requestsPerMinute: number;\n      maxConcurrentSessions: number;\n    };\n    agent: {\n      requestsPerMinute: number;\n      maxConcurrentSessions: number;\n    };\n    readonly: {\n      requestsPerMinute: number;\n      maxConcurrentSessions: number;\n    };\n    limited: {\n      requestsPerMinute: number;\n      maxConcurrentSessions: number;\n    };\n  };\n}\n\nexport interface AuthenticatedUser {\n  id: string;\n  role: string;\n  permissions: string[];\n  method: string;\n}\n\nexport interface AuthenticatedRequest extends Request {\n  user?: AuthenticatedUser;\n}\n\n/**\n * Authentication middleware factory\n */\nexport function authMiddleware(config: AuthConfig) {\n  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    try {\n      // Skip authentication for health check and documentation endpoints\n      if (req.path === '/health' || req.path === '/api' || req.path === '/api/docs') {\n        return next();\n      }\n\n      // Local-only mode: restrict to localhost\n      if (config.localOnly || config.method === 'local_only') {\n        const clientIP = req.ip || req.connection?.remoteAddress || '';\n        const isLocalhost =\n          ['127.0.0.1', '::1', '::ffff:127.0.0.1'].includes(clientIP) ||\n          clientIP.startsWith('127.') ||\n          clientIP === 'localhost';\n\n        if (isLocalhost) {\n          // Grant admin permissions for localhost in local-only mode\n          req.user = {\n            id: 'localhost',\n            role: 'admin',\n            permissions: ['*'],\n            method: 'local_only',\n          };\n          return next();\n        } else if (config.localOnly) {\n          return res.status(403).json({\n            error: 'Forbidden',\n            message: 'API access restricted to localhost only',\n          });\n        }\n      }\n\n      // Try different authentication methods\n      let user: AuthenticatedUser | null = null;\n\n      // 1. Try API Key authentication\n      if (config.method === 'api_key') {\n        user = await tryApiKeyAuth(req, config);\n        if (user) {\n          req.user = user;\n          return next();\n        }\n      }\n\n      // 2. Try JWT authentication\n      if (config.method === 'jwt_token') {\n        user = await tryJwtAuth(req, config);\n        if (user) {\n          req.user = user;\n          return next();\n        }\n      }\n\n      // 3. Try OAuth2 authentication\n      if (config.method === 'oauth2') {\n        user = await tryOAuth2Auth(req, config);\n        if (user) {\n          req.user = user;\n          return next();\n        }\n      }\n\n      // No valid authentication found\n      return res.status(401).json({\n        error: 'Unauthorized',\n        message: 'Valid authentication required',\n        supportedMethods: [config.method],\n        hints: {\n          api_key: 'Include X-API-Key header',\n          jwt_token: 'Include Authorization: Bearer <token> header',\n          local_only: 'Access from localhost only',\n        },\n      });\n    } catch (error: unknown) {\n      console.error('[AuthMiddleware] Authentication error:', error);\n      return res.status(500).json({\n        error: 'Internal Server Error',\n        message: 'Authentication system error',\n      });\n    }\n  };\n}\n\n/**\n * Try API Key authentication\n */\nasync function tryApiKeyAuth(req: Request, config: AuthConfig): Promise<AuthenticatedUser | null> {\n  const apiKey = req.headers['x-api-key'] as string;\n  if (!apiKey) return null;\n\n  // Check against configured API keys\n  if (config.apiKeys.includes(apiKey)) {\n    return {\n      id: `api_key_${apiKey.substring(0, 8)}`,\n      role: 'agent', // Default role for API key users\n      permissions: getDefaultPermissions('agent'),\n      method: 'api_key',\n    };\n  }\n\n  return null;\n}\n\n/**\n * Try JWT authentication\n */\nasync function tryJwtAuth(req: Request, config: AuthConfig): Promise<AuthenticatedUser | null> {\n  const authHeader = req.headers.authorization;\n  if (!authHeader || !authHeader.startsWith('Bearer ')) return null;\n\n  const token = authHeader.substring(7);\n\n  try {\n    const decoded = jwt.verify(token, config.jwtSecret) as Record<string, unknown>;\n\n    return {\n      id: (decoded.sub as string) || (decoded.id as string) || 'jwt_user',\n      role: (decoded.role as string) || 'agent',\n      permissions:\n        (decoded.permissions as string[]) ||\n        getDefaultPermissions((decoded.role as string) || 'agent'),\n      method: 'jwt_token',\n    };\n  } catch (error: unknown) {\n    console.error('[AuthMiddleware] JWT verification failed:', error);\n    return null;\n  }\n}\n\n/**\n * Try OAuth2 authentication (placeholder implementation)\n */\nasync function tryOAuth2Auth(req: Request, config: AuthConfig): Promise<AuthenticatedUser | null> {\n  // This is a placeholder for OAuth2 implementation\n  // In a full implementation, this would:\n  // 1. Extract the OAuth2 token from the Authorization header\n  // 2. Validate the token with the OAuth2 provider\n  // 3. Extract user information from the token or provider API\n  // 4. Map provider roles to internal permissions\n\n  const authHeader = req.headers.authorization;\n  if (!authHeader || !authHeader.startsWith('Bearer ')) return null;\n\n  // For now, return null to indicate OAuth2 is not implemented\n  return null;\n}\n\n/**\n * Get default permissions for a role\n */\nfunction getDefaultPermissions(role: string): string[] {\n  const rolePermissions: { [key: string]: string[] } = {\n    admin: ['*'],\n    agent: [\n      'query:execute',\n      'batch:execute',\n      'session:create',\n      'session:read',\n      'session:delete_own',\n      'reasoning:*',\n      'history:read_own',\n    ],\n    readonly: ['query:execute_readonly', 'session:read', 'history:read_own', 'status:read'],\n    limited: ['query:execute_simple', 'session:read_own'],\n  };\n\n  return rolePermissions[role] || rolePermissions['limited'] || [];\n}\n\n/**\n * Generate a new API key\n */\nexport function generateApiKey(): string {\n  return crypto.randomBytes(32).toString('hex');\n}\n\n/**\n * Hash an API key for secure storage\n */\nexport function hashApiKey(apiKey: string): string {\n  return crypto.createHash('sha256').update(apiKey).digest('hex');\n}\n\n/**\n * Generate a JWT token\n */\nexport function generateJwtToken(payload: any, config: AuthConfig): string {\n  return jwt.sign(payload, config.jwtSecret, {\n    expiresIn: '1h',\n    issuer: 'vscode-prolog-toolkit',\n    audience: 'ai-agents',\n  });\n}\n\n/**\n * Verify JWT token\n */\nexport function verifyJwtToken(token: string, config: AuthConfig): Record<string, unknown> {\n  const decoded = jwt.verify(token, config.jwtSecret);\n  if (typeof decoded === 'string') {\n    throw new Error('Invalid JWT token format');\n  }\n  return decoded as Record<string, unknown>;\n}\n\n/**\n * Permission checking utility\n */\nexport function hasPermission(user: AuthenticatedUser | undefined, permission: string): boolean {\n  if (!user) return false;\n\n  // Admin role has all permissions\n  if (user.role === 'admin' || user.permissions.includes('*')) return true;\n\n  // Check exact permission\n  if (user.permissions.includes(permission)) return true;\n\n  // Check wildcard permissions (e.g., 'reasoning:*' matches 'reasoning:clp')\n  const wildcardPermissions = user.permissions.filter(p => p.endsWith(':*'));\n  for (const wildcardPerm of wildcardPermissions) {\n    const prefix = wildcardPerm.slice(0, -1); // Remove '*'\n    if (permission.startsWith(prefix)) return true;\n  }\n\n  return false;\n}\n\n/**\n * Resource quota middleware\n */\nexport function resourceQuotaMiddleware(quotas: {\n  [role: string]: { requests_per_minute?: number; maxConcurrentSessions?: number };\n}) {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    const user = req.user;\n    if (!user) return next();\n\n    const userQuota = quotas[user.role] || quotas['default'];\n    if (!userQuota) return next();\n\n    // Add quota information to request for later use\n    (req as AuthenticatedRequest & { quota?: typeof userQuota }).quota = userQuota;\n\n    // Add quota headers to response\n    res.set({\n      'X-Rate-Limit-Limit': userQuota.requests_per_minute?.toString() || '60',\n      'X-Rate-Limit-Remaining': '60', // This would be calculated based on actual usage\n      'X-Rate-Limit-Reset': (Date.now() + 60000).toString(),\n    });\n\n    next();\n  };\n}\n\n/**\n * Audit logging middleware\n */\nexport function auditMiddleware() {\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    const start = Date.now();\n\n    // Log request\n    console.log(\n      `[Audit] ${req.method} ${req.path} - User: ${req.user?.id || 'anonymous'} (${req.user?.role || 'none'})`\n    );\n\n    // Log response when finished\n    res.on('finish', () => {\n      const duration = Date.now() - start;\n      const logLevel = res.statusCode >= 400 ? 'WARN' : 'INFO';\n\n      console.log(\n        `[Audit] ${logLevel} ${req.method} ${req.path} - ${res.statusCode} (${duration}ms) - User: ${req.user?.id || 'anonymous'}`\n      );\n\n      // Log security events\n      if (res.statusCode === 401) {\n        console.log(`[Security] Authentication failed - ${req.ip} - ${req.method} ${req.path}`);\n      } else if (res.statusCode === 403) {\n        console.log(\n          `[Security] Authorization denied - User: ${req.user?.id} - ${req.method} ${req.path}`\n        );\n      } else if (res.statusCode === 429) {\n        console.log(`[Security] Rate limit exceeded - User: ${req.user?.id} - ${req.ip}`);\n      }\n    });\n\n    next();\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\apiRoutes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'status' is defined but never used. Allowed unused args must match /^_/u.","line":57,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rules' is assigned a value but never used.","line":521,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":521,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router, Request, Response } from 'express';\nimport { PrologBackend } from '../prologBackend';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface AuthenticatedRequest extends Request {\n  user?: {\n    id: string;\n    role: string;\n    permissions: string[];\n  };\n}\n\n/**\n * Create API routes for Prolog operations\n */\nexport function apiRoutes(prologBackend: PrologBackend): Router {\n  const router = Router();\n\n  // Query execution endpoint\n  router.post('/query', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      const { query, session_id, options = {} } = req.body;\n\n      if (!query) {\n        res.status(400).json({\n          error: 'Bad Request',\n          message: 'Query parameter is required',\n        });\n        return;\n      }\n\n      // Check permissions\n      if (!hasPermission(req.user, 'query:execute')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions for query execution',\n        });\n        return;\n      }\n\n      const queryId = uuidv4();\n      const params = {\n        goal: query,\n        timeoutMs: options.timeout || 30000,\n        max_results: options.max_results || 100,\n        streaming: options.stream || false,\n        session_id: session_id || 'default',\n        ...options,\n      };\n\n      // Execute query with notifications if callback provided\n      const result = await prologBackend.sendRequestWithNotifications('query', params, {\n        onProgress: status => {\n          // In a full implementation, this would use WebSocket to notify client\n          console.log(`[ApiRoutes] Query ${queryId} progress: ${status.progress}%`);\n        },\n        onComplete: status => {\n          console.log(`[ApiRoutes] Query ${queryId} completed`);\n        },\n        onError: status => {\n          console.error(`[ApiRoutes] Query ${queryId} error:`, status.error);\n        },\n      });\n\n      res.json({\n        query_id: queryId,\n        success: result.status === 'ok',\n        results: result.results || [],\n        execution_time: result.execution_time || 0,\n        more_available: result.streaming_info?.has_more || false,\n        cursor: result.streaming_info?.next_offset || null,\n        streaming_info: result.streaming_info,\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] Query execution error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'Query execution failed',\n      });\n    }\n  });\n\n  // Batch query execution endpoint\n  router.post('/batch', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      const { queries, session_id, batch_options = {} } = req.body;\n\n      if (!Array.isArray(queries) || queries.length === 0) {\n        res.status(400).json({\n          error: 'Bad Request',\n          message: 'Queries array is required and must not be empty',\n        });\n        return;\n      }\n\n      // Check permissions\n      if (!hasPermission(req.user, 'batch:execute')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions for batch execution',\n        });\n        return;\n      }\n\n      const batchId = uuidv4();\n      const batchRequests = queries.map((query: { query?: string; timeout?: number } | string) => ({\n        cmd: 'query',\n        params: {\n          goal: typeof query === 'string' ? query : query.query || query,\n          timeoutMs:\n            typeof query === 'string'\n              ? batch_options.timeout || 30000\n              : query.timeout || batch_options.timeout || 30000,\n          session_id: session_id || 'default',\n        },\n      }));\n\n      const results = await prologBackend.sendRequest(batchRequests);\n\n      res.json({\n        batch_id: batchId,\n        results: results.map(\n          (result: { status: string; results?: unknown[]; error?: string }, index: number) => ({\n            query_index: index,\n            success: result.status === 'ok',\n            results: result.results || [],\n            error: result.error || null,\n          })\n        ),\n        total_queries: queries.length,\n        successful_queries: results.filter((r: { status: string }) => r.status === 'ok').length,\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] Batch execution error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'Batch execution failed',\n      });\n    }\n  });\n\n  // Session management endpoints\n  router.get('/sessions', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      if (!hasPermission(req.user, 'session:read')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions to list sessions',\n        });\n        return;\n      }\n\n      const listOptions: {\n        userId?: string;\n        agentId?: string;\n        isActive?: boolean;\n        includeInactive?: boolean;\n      } = {\n        includeInactive: req.query.include_inactive === 'true',\n      };\n\n      if (req.user?.id) {\n        listOptions.userId = req.user.id;\n      }\n\n      const sessions = prologBackend.listSessions(listOptions);\n\n      res.json({\n        sessions: sessions.map(session => ({\n          session_id: session.sessionId,\n          name: session.config.name,\n          description: session.config.description,\n          created_at: session.config.createdAt,\n          is_active: session.config.isActive,\n          user_id: session.config.userId,\n        })),\n        total: sessions.length,\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] Session list error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'Failed to list sessions',\n      });\n    }\n  });\n\n  router.post('/sessions', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      const { name, description, config = {} } = req.body;\n\n      if (!name) {\n        res.status(400).json({\n          error: 'Bad Request',\n          message: 'Session name is required',\n        });\n        return;\n      }\n\n      if (!hasPermission(req.user, 'session:create')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions to create sessions',\n        });\n        return;\n      }\n\n      const sessionOptions: Record<string, unknown> = {\n        ...config,\n      };\n\n      if (description) {\n        sessionOptions.description = description;\n      }\n\n      if (req.user?.id) {\n        sessionOptions.userId = req.user.id;\n      }\n\n      if (req.headers['user-agent']) {\n        sessionOptions.agentId = req.headers['user-agent'];\n      }\n\n      const sessionId = await prologBackend.createSession(name, sessionOptions);\n\n      res.status(201).json({\n        session_id: sessionId,\n        name,\n        description,\n        created_at: new Date().toISOString(),\n        message: 'Session created successfully',\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] Session creation error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'Failed to create session',\n      });\n    }\n  });\n\n  router.get(\n    '/sessions/:session_id',\n    async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n      try {\n        const { session_id } = req.params;\n\n        if (!hasPermission(req.user, 'session:read')) {\n          res.status(403).json({\n            error: 'Forbidden',\n            message: 'Insufficient permissions to read session details',\n          });\n          return;\n        }\n\n        if (!session_id) {\n          res.status(400).json({\n            error: 'Bad Request',\n            message: 'Session ID is required',\n          });\n          return;\n        }\n\n        const session = prologBackend.getSession(session_id);\n        if (!session) {\n          res.status(404).json({\n            error: 'Not Found',\n            message: 'Session not found',\n          });\n          return;\n        }\n\n        res.json({\n          session_id,\n          config: session.config,\n          state: session.state,\n          statistics: await prologBackend.getSessionStatistics(session_id),\n        });\n      } catch (error: unknown) {\n        console.error('[ApiRoutes] Session details error:', error);\n        res.status(500).json({\n          error: 'Internal Server Error',\n          message: error instanceof Error ? error.message : 'Failed to get session details',\n        });\n      }\n    }\n  );\n\n  router.delete(\n    '/sessions/:session_id',\n    async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n      try {\n        const { session_id } = req.params;\n\n        if (!hasPermission(req.user, 'session:delete')) {\n          res.status(403).json({\n            error: 'Forbidden',\n            message: 'Insufficient permissions to delete sessions',\n          });\n          return;\n        }\n\n        if (!session_id) {\n          res.status(400).json({\n            error: 'Bad Request',\n            message: 'Session ID is required',\n          });\n          return;\n        }\n\n        const deleted = await prologBackend.deleteSession(session_id);\n        if (!deleted) {\n          res.status(404).json({\n            error: 'Not Found',\n            message: 'Session not found',\n          });\n          return;\n        }\n\n        res.json({\n          session_id,\n          message: 'Session deleted successfully',\n        });\n      } catch (error: unknown) {\n        console.error('[ApiRoutes] Session deletion error:', error);\n        res.status(500).json({\n          error: 'Internal Server Error',\n          message: error instanceof Error ? error.message : 'Failed to delete session',\n        });\n      }\n    }\n  );\n\n  // Session state management\n  router.get(\n    '/sessions/:session_id/state',\n    async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n      try {\n        const { session_id } = req.params;\n\n        if (!session_id) {\n          res.status(400).json({\n            error: 'Bad Request',\n            message: 'Session ID is required',\n          });\n          return;\n        }\n\n        if (!hasPermission(req.user, 'session:read')) {\n          res.status(403).json({\n            error: 'Forbidden',\n            message: 'Insufficient permissions to read session state',\n          });\n          return;\n        }\n\n        const session = prologBackend.getSession(session_id);\n        if (!session) {\n          res.status(404).json({\n            error: 'Not Found',\n            message: 'Session not found',\n          });\n          return;\n        }\n\n        res.json({\n          session_id,\n          state: session.state,\n          exported_at: new Date().toISOString(),\n        });\n      } catch (error: unknown) {\n        console.error('[ApiRoutes] Session state export error:', error);\n        res.status(500).json({\n          error: 'Internal Server Error',\n          message: error instanceof Error ? error.message : 'Failed to export session state',\n        });\n      }\n    }\n  );\n\n  router.post(\n    '/sessions/:session_id/state',\n    async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n      try {\n        const { session_id } = req.params;\n        const { state } = req.body;\n\n        if (!session_id) {\n          res.status(400).json({\n            error: 'Bad Request',\n            message: 'Session ID is required',\n          });\n          return;\n        }\n\n        if (!hasPermission(req.user, 'session:write')) {\n          res.status(403).json({\n            error: 'Forbidden',\n            message: 'Insufficient permissions to modify session state',\n          });\n          return;\n        }\n\n        await prologBackend.saveSessionState(session_id, state);\n\n        res.json({\n          session_id,\n          message: 'Session state imported successfully',\n          imported_at: new Date().toISOString(),\n        });\n      } catch (error: unknown) {\n        console.error('[ApiRoutes] Session state import error:', error);\n        res.status(500).json({\n          error: 'Internal Server Error',\n          message: error instanceof Error ? error.message : 'Failed to import session state',\n        });\n      }\n    }\n  );\n\n  // Advanced reasoning endpoints\n  router.post('/reasoning/clp', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      const { constraints, domain = 'fd', variables } = req.body;\n\n      if (!constraints || !variables) {\n        res.status(400).json({\n          error: 'Bad Request',\n          message: 'Constraints and variables are required',\n        });\n        return;\n      }\n\n      if (!hasPermission(req.user, 'reasoning:clp')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions for CLP reasoning',\n        });\n        return;\n      }\n\n      const result = await prologBackend.sendRequest('clp_solve', {\n        domain,\n        variables,\n        constraints,\n      });\n\n      res.json({\n        success: result.status === 'ok',\n        domain,\n        solution: result.solution || [],\n        error: result.error || null,\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] CLP reasoning error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'CLP reasoning failed',\n      });\n    }\n  });\n\n  router.post(\n    '/reasoning/probabilistic',\n    async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n      try {\n        const { facts, query, samples = 1000 } = req.body;\n\n        if (!query) {\n          res.status(400).json({\n            error: 'Bad Request',\n            message: 'Query is required for probabilistic inference',\n          });\n          return;\n        }\n\n        if (!hasPermission(req.user, 'reasoning:probabilistic')) {\n          res.status(403).json({\n            error: 'Forbidden',\n            message: 'Insufficient permissions for probabilistic reasoning',\n          });\n          return;\n        }\n\n        // Add probabilistic facts if provided\n        if (facts && Array.isArray(facts)) {\n          for (const fact of facts) {\n            await prologBackend.sendRequest('probabilistic_fact', {\n              fact: fact.fact,\n              probability: fact.probability,\n            });\n          }\n        }\n\n        const result = await prologBackend.sendRequest('probabilistic_query', {\n          goal: query,\n          samples,\n          method: 'monte_carlo',\n        });\n\n        res.json({\n          success: result.status === 'ok',\n          query,\n          probability: result.probability || 0,\n          evidence: result.evidence || {},\n          samples,\n          error: result.error || null,\n        });\n      } catch (error: unknown) {\n        console.error('[ApiRoutes] Probabilistic reasoning error:', error);\n        res.status(500).json({\n          error: 'Internal Server Error',\n          message: error instanceof Error ? error.message : 'Probabilistic reasoning failed',\n        });\n      }\n    }\n  );\n\n  router.post('/reasoning/n3', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      const { rules, data, query } = req.body;\n\n      if (!query) {\n        res.status(400).json({\n          error: 'Bad Request',\n          message: 'Query is required for N3 reasoning',\n        });\n        return;\n      }\n\n      if (!hasPermission(req.user, 'reasoning:n3')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions for N3 reasoning',\n        });\n        return;\n      }\n\n      // Load N3 data if provided\n      if (data) {\n        await prologBackend.sendRequest('n3_load', {\n          content: data,\n        });\n      }\n\n      const result = await prologBackend.sendRequest('n3_reason', {\n        goal: query,\n      });\n\n      res.json({\n        success: result.status === 'ok',\n        query,\n        results: result.results || [],\n        inferred_triples: result.inferred_triples || [],\n        count: result.count || 0,\n        error: result.error || null,\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] N3 reasoning error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'N3 reasoning failed',\n      });\n    }\n  });\n\n  // Query history endpoint\n  router.get('/history', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      if (!hasPermission(req.user, 'history:read')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions to read query history',\n        });\n        return;\n      }\n\n      const { session_id, limit = 50, offset = 0, status } = req.query;\n\n      const filter: Record<string, unknown> = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n      };\n\n      if (session_id) filter.session_id = session_id;\n      if (status) filter.status = status;\n      if (req.user?.id) filter.user_id = req.user.id;\n\n      const history = await prologBackend.getQueryHistory(filter);\n\n      res.json({\n        queries: history.queries || [],\n        total: history.total || 0,\n        limit: filter.limit,\n        offset: filter.offset,\n        has_more: (history.total || 0) > (filter.offset as number) + (filter.limit as number),\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] Query history error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'Failed to retrieve query history',\n      });\n    }\n  });\n\n  // System status endpoint\n  router.get('/status', async (req: AuthenticatedRequest, res: Response): Promise<void> => {\n    try {\n      if (!hasPermission(req.user, 'status:read')) {\n        res.status(403).json({\n          error: 'Forbidden',\n          message: 'Insufficient permissions to read system status',\n        });\n        return;\n      }\n\n      const backendStatus = prologBackend.getConcurrencyStatus();\n      const queryStats = prologBackend.getQueryStatistics();\n      const schedulerStats = prologBackend.getSchedulerStatistics();\n\n      res.json({\n        backend: {\n          running: prologBackend.isRunning(),\n          active_queries: queryStats.running || 0,\n          active_sessions: prologBackend.listSessions().length,\n          resource_usage: backendStatus.resourceUsage || {},\n        },\n        scheduler: schedulerStats,\n        query_statistics: queryStats,\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error: unknown) {\n      console.error('[ApiRoutes] Status endpoint error:', error);\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : 'Failed to retrieve system status',\n      });\n    }\n  });\n\n  return router;\n}\n\n/**\n * Check if user has required permission\n */\nfunction hasPermission(\n  user: { role?: string; permissions?: string[] } | undefined,\n  permission: string\n): boolean {\n  if (!user) return false;\n\n  // Admin role has all permissions\n  if (user.role === 'admin') return true;\n\n  // Check specific permissions\n  return user.permissions?.includes(permission) ?? false;\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\apiServer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'burstKey' is assigned a value but never used.","line":102,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used. Allowed unused args must match /^_/u.","line":207,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":207,"endColumn":66}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express, { Express, Request, Response, NextFunction } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport { Server } from 'http';\nimport { PrologBackend } from '../prologBackend';\nimport { apiRoutes } from './apiRoutes';\nimport { authMiddleware, AuthConfig } from './apiMiddleware';\n\nexport interface ApiServerConfig {\n  enabled: boolean;\n  port: number;\n  host: string;\n  corsOrigins: string[];\n  maxConnections: number;\n  requestTimeout: number;\n  rateLimiting: {\n    enabled: boolean;\n    requestsPerMinute: number;\n    burstLimit: number;\n  };\n  auth: AuthConfig;\n}\n\nexport interface ApiServerOptions {\n  config: ApiServerConfig;\n  prologBackend: PrologBackend;\n}\n\n/**\n * Express.js-based HTTP API server for external AI agent access\n * Provides RESTful endpoints for all Prolog operations with security middleware\n */\nexport class ApiServer {\n  private app: Express;\n  private server: Server | null = null;\n  private config: ApiServerConfig;\n  private prologBackend: PrologBackend;\n  private isRunning: boolean = false;\n\n  constructor(options: ApiServerOptions) {\n    this.config = options.config;\n    this.prologBackend = options.prologBackend;\n    this.app = express();\n    this.setupMiddleware();\n    this.setupRoutes();\n    this.setupErrorHandling();\n  }\n\n  /**\n   * Set up Express middleware stack\n   */\n  private setupMiddleware(): void {\n    // Security middleware\n    this.app.use(\n      helmet({\n        contentSecurityPolicy: {\n          directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n            imgSrc: [\"'self'\", 'data:', 'https:'],\n          },\n        },\n        crossOriginEmbedderPolicy: false, // Allow WebSocket connections\n      })\n    );\n\n    // CORS configuration\n    this.app.use(\n      cors({\n        origin: (origin, callback) => {\n          // Allow requests with no origin (like mobile apps or curl requests)\n          if (!origin) return callback(null, true);\n\n          if (this.config.corsOrigins.includes('*') || this.config.corsOrigins.includes(origin)) {\n            return callback(null, true);\n          }\n\n          callback(new Error('Not allowed by CORS'));\n        },\n        credentials: true,\n        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n        allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],\n      })\n    );\n\n    // Rate limiting\n    if (this.config.rateLimiting.enabled) {\n      const limiter = rateLimit({\n        windowMs: 60 * 1000, // 1 minute\n        max: this.config.rateLimiting.requestsPerMinute,\n        message: {\n          error: 'Too many requests',\n          message: `Rate limit exceeded. Maximum ${this.config.rateLimiting.requestsPerMinute} requests per minute.`,\n          retryAfter: 60,\n        },\n        standardHeaders: true,\n        legacyHeaders: false,\n        // Allow burst requests up to the burst limit\n        skip: req => {\n          const burstKey = `burst_${req.ip}`;\n          // Simple burst tracking (in production, use Redis or similar)\n          return false; // For now, apply rate limiting to all requests\n        },\n      });\n      this.app.use('/api/', limiter);\n    }\n\n    // Request parsing\n    this.app.use(express.json({ limit: '10mb' }));\n    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n    // Request timeout\n    this.app.use((req: Request, res: Response, next: NextFunction) => {\n      req.setTimeout(this.config.requestTimeout, () => {\n        res.status(408).json({\n          error: 'Request timeout',\n          message: `Request exceeded ${this.config.requestTimeout}ms timeout`,\n        });\n      });\n      next();\n    });\n\n    // Authentication middleware\n    this.app.use('/api/', authMiddleware(this.config.auth));\n\n    // Request logging\n    this.app.use((req: Request, res: Response, next: NextFunction) => {\n      const start = Date.now();\n      console.log(`[ApiServer] ${req.method} ${req.path} - ${req.ip}`);\n\n      res.on('finish', () => {\n        const duration = Date.now() - start;\n        console.log(`[ApiServer] ${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`);\n      });\n\n      next();\n    });\n  }\n\n  /**\n   * Set up API routes\n   */\n  private setupRoutes(): void {\n    // Health check endpoint (no auth required)\n    this.app.get('/health', (req: Request, res: Response) => {\n      res.json({\n        status: 'healthy',\n        timestamp: new Date().toISOString(),\n        version: '1.0.0',\n        backend: {\n          running: this.prologBackend.isRunning(),\n          port: this.prologBackend['port'] || 3060,\n        },\n      });\n    });\n\n    // API documentation endpoint\n    this.app.get('/api', (req: Request, res: Response) => {\n      res.json({\n        name: 'VSCode Prolog Toolkit API',\n        version: '1.0.0',\n        description: 'RESTful API for Prolog operations and AI agent integration',\n        documentation: '/api/docs',\n        endpoints: {\n          query: 'POST /api/v1/query',\n          batch: 'POST /api/v1/batch',\n          sessions: 'GET|POST /api/v1/sessions',\n          reasoning: {\n            clp: 'POST /api/v1/reasoning/clp',\n            probabilistic: 'POST /api/v1/reasoning/probabilistic',\n            n3: 'POST /api/v1/reasoning/n3',\n          },\n          history: 'GET /api/v1/history',\n          status: 'GET /api/v1/status',\n        },\n      });\n    });\n\n    // Mount API routes\n    this.app.use('/api/v1', apiRoutes(this.prologBackend));\n  }\n\n  /**\n   * Set up error handling middleware\n   */\n  private setupErrorHandling(): void {\n    // 404 handler\n    this.app.use('*', (req: Request, res: Response) => {\n      res.status(404).json({\n        error: 'Not Found',\n        message: `Endpoint ${req.method} ${req.originalUrl} not found`,\n        availableEndpoints: [\n          'GET /health',\n          'GET /api',\n          'POST /api/v1/query',\n          'POST /api/v1/batch',\n          'GET /api/v1/sessions',\n          'POST /api/v1/sessions',\n          'GET /api/v1/status',\n        ],\n      });\n    });\n\n    // Global error handler\n    this.app.use((error: Error, req: Request, res: Response, next: NextFunction) => {\n      console.error(`[ApiServer] Error in ${req.method} ${req.path}:`, error);\n\n      // Don't send error details in production\n      const isDevelopment = process.env.NODE_ENV !== 'production';\n\n      res.status(500).json({\n        error: 'Internal Server Error',\n        message: isDevelopment ? error.message : 'An unexpected error occurred',\n        ...(isDevelopment && { stack: error.stack }),\n      });\n    });\n  }\n\n  /**\n   * Start the API server\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error('API server is already running');\n    }\n\n    if (!this.config.enabled) {\n      console.log('[ApiServer] API server is disabled in configuration');\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.server = this.app.listen(this.config.port, this.config.host, () => {\n          this.isRunning = true;\n          console.log(\n            `[ApiServer] HTTP API server started on ${this.config.host}:${this.config.port}`\n          );\n          console.log(\n            `[ApiServer] Health check: http://${this.config.host}:${this.config.port}/health`\n          );\n          console.log(\n            `[ApiServer] API documentation: http://${this.config.host}:${this.config.port}/api`\n          );\n          resolve();\n        });\n\n        this.server.on('error', (error: unknown) => {\n          console.error('[ApiServer] Server error:', error);\n          reject(error);\n        });\n\n        // Handle connection limits\n        this.server.maxConnections = this.config.maxConnections;\n      } catch (error: unknown) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Stop the API server\n   */\n  async stop(): Promise<void> {\n    if (!this.isRunning || !this.server) {\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.server!.close(error => {\n        if (error) {\n          console.error('[ApiServer] Error stopping server:', error);\n          reject(error);\n        } else {\n          this.isRunning = false;\n          this.server = null;\n          console.log('[ApiServer] HTTP API server stopped');\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Get server status\n   */\n  getStatus(): {\n    running: boolean;\n    port: number;\n    host: string;\n    connections: number;\n  } {\n    return {\n      running: this.isRunning,\n      port: this.config.port,\n      host: this.config.host,\n      connections: (this.server as any)?.connections || 0,\n    };\n  }\n\n  /**\n   * Get Express app instance (for testing)\n   */\n  getApp(): Express {\n    return this.app;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\concurrencyManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\configurationMigration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":271,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":271,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport { InstallationChecker } from './installationChecker';\n\nexport interface MigrationResult {\n  migrated: boolean;\n  oldPath?: string;\n  newPath?: string;\n  backupCreated?: boolean;\n  issues?: string[];\n}\n\nexport interface ConfigurationBackup {\n  timestamp: string;\n  configuration: any;\n  reason: string;\n}\n\nexport class ConfigurationMigration {\n  private static instance: ConfigurationMigration;\n  private installationChecker: InstallationChecker;\n\n  private constructor() {\n    this.installationChecker = InstallationChecker.getInstance();\n  }\n\n  public static getInstance(): ConfigurationMigration {\n    if (!ConfigurationMigration.instance) {\n      ConfigurationMigration.instance = new ConfigurationMigration();\n    }\n    return ConfigurationMigration.instance;\n  }\n\n  /**\n   * Perform automatic configuration migration\n   */\n  public async performMigration(): Promise<MigrationResult> {\n    const config = vscode.workspace.getConfiguration('prolog');\n    const currentPath = config.get<string>('executablePath', 'swipl');\n\n    // Check if current path is valid\n    const isCurrentValid = await this.installationChecker.validateSwiplPath(currentPath);\n\n    if (isCurrentValid) {\n      return {\n        migrated: false,\n        issues: [],\n      };\n    }\n\n    // Current path is invalid, try to find a valid one\n    const foundPath = await this.installationChecker.findSwiplExecutable();\n\n    if (!foundPath) {\n      return {\n        migrated: false,\n        oldPath: currentPath,\n        issues: ['No valid SWI-Prolog installation found for migration'],\n      };\n    }\n\n    // Create backup before migration\n    const backupResult = await this.createConfigurationBackup('automatic_migration');\n\n    try {\n      // Update configuration\n      await config.update('executablePath', foundPath, vscode.ConfigurationTarget.Global);\n\n      return {\n        migrated: true,\n        oldPath: currentPath,\n        newPath: foundPath,\n        backupCreated: backupResult,\n        issues: [],\n      };\n    } catch (error) {\n      return {\n        migrated: false,\n        oldPath: currentPath,\n        backupCreated: backupResult,\n        issues: [`Failed to update configuration: ${error}`],\n      };\n    }\n  }\n\n  /**\n   * Detect and handle outdated or invalid paths\n   */\n  public async detectOutdatedPaths(): Promise<{\n    hasOutdatedPaths: boolean;\n    invalidPaths: string[];\n    suggestions: Array<{ path: string; version?: string }>;\n  }> {\n    const config = vscode.workspace.getConfiguration('prolog');\n    const currentPath = config.get<string>('executablePath', 'swipl');\n    const invalidPaths: string[] = [];\n    const suggestions: Array<{ path: string; version?: string }> = [];\n\n    // Check current executable path\n    const isCurrentValid = await this.installationChecker.validateSwiplPath(currentPath);\n    if (!isCurrentValid) {\n      invalidPaths.push(currentPath);\n    }\n\n    // Check for common outdated paths\n    const commonOutdatedPaths = this.getCommonOutdatedPaths();\n    for (const outdatedPath of commonOutdatedPaths) {\n      if (currentPath.includes(outdatedPath)) {\n        invalidPaths.push(currentPath);\n        break;\n      }\n    }\n\n    // Find valid alternatives\n    const foundPath = await this.installationChecker.findSwiplExecutable();\n    if (foundPath) {\n      const version = await this.installationChecker.getSwiplVersion(foundPath);\n      suggestions.push({ path: foundPath, version });\n    }\n\n    return {\n      hasOutdatedPaths: invalidPaths.length > 0,\n      invalidPaths,\n      suggestions,\n    };\n  }\n\n  /**\n   * Attempt to find new valid paths for invalid configurations\n   */\n  public async findNewValidPaths(): Promise<Array<{ path: string; version?: string }>> {\n    const validPaths: Array<{ path: string; version?: string }> = [];\n    const commonPaths = this.installationChecker.detectCommonInstallPaths();\n\n    for (const path of commonPaths) {\n      const isValid = await this.installationChecker.validateSwiplPath(path);\n      if (isValid) {\n        const version = await this.installationChecker.getSwiplVersion(path);\n        validPaths.push({ path, version });\n      }\n    }\n\n    return validPaths;\n  }\n\n  /**\n   * Create a backup of current configuration\n   */\n  public async createConfigurationBackup(reason: string): Promise<boolean> {\n    try {\n      const config = vscode.workspace.getConfiguration('prolog');\n      const backup: ConfigurationBackup = {\n        timestamp: new Date().toISOString(),\n        reason,\n        configuration: {\n          executablePath: config.get('executablePath'),\n          dialect: config.get('dialect'),\n          'linter.run': config.get('linter.run'),\n          'linter.delay': config.get('linter.delay'),\n          'linter.enableMsgInOutput': config.get('linter.enableMsgInOutput'),\n          'format.addSpace': config.get('format.addSpace'),\n          'terminal.runtimeArgs': config.get('terminal.runtimeArgs'),\n          'telemetry.enabled': config.get('telemetry.enabled'),\n        },\n      };\n\n      // Store backup in global state (VS Code's storage)\n      const context = this.getExtensionContext();\n      if (context) {\n        const existingBackups = context.globalState.get<ConfigurationBackup[]>(\n          'prologConfigBackups',\n          []\n        );\n        existingBackups.push(backup);\n\n        // Keep only last 10 backups\n        if (existingBackups.length > 10) {\n          existingBackups.splice(0, existingBackups.length - 10);\n        }\n\n        await context.globalState.update('prologConfigBackups', existingBackups);\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      console.error('Failed to create configuration backup:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Restore configuration from backup\n   */\n  public async restoreConfigurationBackup(backupIndex: number = 0): Promise<boolean> {\n    try {\n      const context = this.getExtensionContext();\n      if (!context) {\n        return false;\n      }\n\n      const backups = context.globalState.get<ConfigurationBackup[]>('prologConfigBackups', []);\n      if (backups.length === 0 || backupIndex >= backups.length) {\n        return false;\n      }\n\n      const backup = backups[backups.length - 1 - backupIndex]; // Most recent first\n      const config = vscode.workspace.getConfiguration('prolog');\n\n      // Restore each configuration value\n      for (const [key, value] of Object.entries(backup.configuration)) {\n        if (value !== undefined) {\n          await config.update(key, value, vscode.ConfigurationTarget.Global);\n        }\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Failed to restore configuration backup:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get list of available backups\n   */\n  public getConfigurationBackups(): ConfigurationBackup[] {\n    const context = this.getExtensionContext();\n    if (!context) {\n      return [];\n    }\n\n    return context.globalState.get<ConfigurationBackup[]>('prologConfigBackups', []);\n  }\n\n  /**\n   * Handle migration of different SWI-Prolog versions\n   */\n  public async handleVersionMigration(\n    oldVersion: string,\n    newVersion: string\n  ): Promise<{\n    compatibilityIssues: string[];\n    recommendations: string[];\n  }> {\n    const compatibilityIssues: string[] = [];\n    const recommendations: string[] = [];\n\n    try {\n      const oldVersionParts = oldVersion.split('.').map(v => parseInt(v, 10));\n      const newVersionParts = newVersion.split('.').map(v => parseInt(v, 10));\n\n      // Check for major version changes\n      if (oldVersionParts[0] !== newVersionParts[0]) {\n        compatibilityIssues.push(\n          `Major version change from ${oldVersionParts[0]} to ${newVersionParts[0]} may affect compatibility`\n        );\n        recommendations.push(\n          'Review your Prolog code for compatibility with the new major version'\n        );\n      }\n\n      // Check for specific version-related issues\n      if (oldVersionParts[0] < 8 && newVersionParts[0] >= 8) {\n        recommendations.push('SWI-Prolog 8.x introduced new features and some syntax changes');\n        recommendations.push('Consider updating your code to use new string syntax if applicable');\n      }\n\n      if (oldVersionParts[0] < 9 && newVersionParts[0] >= 9) {\n        recommendations.push('SWI-Prolog 9.x has improved performance and new built-in predicates');\n      }\n    } catch (_error) {\n      compatibilityIssues.push('Unable to parse version numbers for compatibility check');\n    }\n\n    return {\n      compatibilityIssues,\n      recommendations,\n    };\n  }\n\n  /**\n   * Preserve user customizations during migration\n   */\n  public async preserveUserCustomizations(): Promise<{\n    preserved: string[];\n    issues: string[];\n  }> {\n    const preserved: string[] = [];\n    const issues: string[] = [];\n\n    try {\n      const config = vscode.workspace.getConfiguration('prolog');\n\n      // List of settings to preserve (non-path related)\n      const settingsToPreserve = [\n        'dialect',\n        'linter.run',\n        'linter.delay',\n        'linter.enableMsgInOutput',\n        'format.addSpace',\n        'terminal.runtimeArgs',\n        'telemetry.enabled',\n      ];\n\n      for (const setting of settingsToPreserve) {\n        const value = config.get(setting);\n        if (value !== undefined) {\n          preserved.push(`${setting}: ${JSON.stringify(value)}`);\n        }\n      }\n    } catch (error) {\n      issues.push(`Failed to preserve customizations: ${error}`);\n    }\n\n    return {\n      preserved,\n      issues,\n    };\n  }\n\n  /**\n   * Show migration dialog to user\n   */\n  public async showMigrationDialog(migrationResult: MigrationResult): Promise<void> {\n    if (migrationResult.migrated) {\n      const action = await vscode.window.showInformationMessage(\n        `Configuration migrated successfully!\\n\\nOld path: ${migrationResult.oldPath}\\nNew path: ${migrationResult.newPath}`,\n        'OK',\n        'Undo Migration'\n      );\n\n      if (action === 'Undo Migration') {\n        const restored = await this.restoreConfigurationBackup(0);\n        if (restored) {\n          vscode.window.showInformationMessage('Configuration restored from backup');\n        } else {\n          vscode.window.showErrorMessage('Failed to restore configuration backup');\n        }\n      }\n    } else if (migrationResult.issues && migrationResult.issues.length > 0) {\n      const issueMessage = migrationResult.issues.join('\\n');\n      await vscode.window.showWarningMessage(\n        `Configuration migration failed:\\n\\n${issueMessage}`,\n        'OK'\n      );\n    }\n  }\n\n  /**\n   * Get common outdated paths that should be migrated\n   */\n  private getCommonOutdatedPaths(): string[] {\n    return [\n      '/usr/local/bin/pl', // Old SWI-Prolog executable name\n      '/usr/bin/pl', // Old SWI-Prolog executable name\n      'C:\\\\pl\\\\bin\\\\pl.exe', // Old Windows path\n      '/opt/pl/', // Old installation directory\n    ];\n  }\n\n  /**\n   * Get extension context (this would need to be set by the extension)\n   */\n  private getExtensionContext(): vscode.ExtensionContext | undefined {\n    // This would be set by the extension when initializing the migration system\n    return (global as any).prologExtensionContext;\n  }\n\n  /**\n   * Set extension context for storage operations\n   */\n  public setExtensionContext(context: vscode.ExtensionContext): void {\n    (global as any).prologExtensionContext = context;\n  }\n\n  /**\n   * Perform comprehensive migration check and handle user interaction\n   */\n  public async performComprehensiveMigration(): Promise<void> {\n    try {\n      // Check for outdated paths\n      const outdatedCheck = await this.detectOutdatedPaths();\n\n      if (outdatedCheck.hasOutdatedPaths) {\n        const action = await vscode.window.showWarningMessage(\n          `Outdated SWI-Prolog configuration detected.\\n\\nInvalid paths: ${outdatedCheck.invalidPaths.join(', ')}\\n\\nWould you like to automatically migrate to a valid installation?`,\n          'Migrate Now',\n          'Show Suggestions',\n          'Skip'\n        );\n\n        switch (action) {\n          case 'Migrate Now': {\n            const migrationResult = await this.performMigration();\n            await this.showMigrationDialog(migrationResult);\n            break;\n          }\n\n          case 'Show Suggestions':\n            await this.showSuggestionsDialog(outdatedCheck.suggestions);\n            break;\n        }\n      }\n    } catch (error) {\n      console.error('Error during comprehensive migration:', error);\n      vscode.window.showErrorMessage(`Migration check failed: ${error}`);\n    }\n  }\n\n  /**\n   * Show suggestions dialog for manual path selection\n   */\n  private async showSuggestionsDialog(\n    suggestions: Array<{ path: string; version?: string }>\n  ): Promise<void> {\n    if (suggestions.length === 0) {\n      vscode.window.showWarningMessage('No valid SWI-Prolog installations found for migration.');\n      return;\n    }\n\n    const items = suggestions.map(suggestion => ({\n      label: suggestion.path,\n      description: suggestion.version ? `Version ${suggestion.version}` : 'Version unknown',\n      path: suggestion.path,\n    }));\n\n    const selected = await vscode.window.showQuickPick(items, {\n      placeHolder: 'Select a SWI-Prolog installation to use',\n      ignoreFocusOut: true,\n    });\n\n    if (selected) {\n      const config = vscode.workspace.getConfiguration('prolog');\n      await this.createConfigurationBackup('manual_path_selection');\n      await config.update('executablePath', selected.path, vscode.ConfigurationTarget.Global);\n      vscode.window.showInformationMessage(`Configuration updated to use: ${selected.path}`);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\definitionProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\documentHighlightProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\editHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\errorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\externalWebSocketManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used. Allowed unused args must match /^_/u.","line":469,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":469,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import WebSocket from 'ws';\nimport { EventEmitter } from 'events';\nimport { QueryNotificationManager } from './queryNotificationManager';\nimport { AuthConfig, verifyJwtToken, hasPermission } from './apiMiddleware';\nimport { IncomingMessage } from 'http';\nimport { URL } from 'url';\n\nexport interface ExternalWebSocketConfig {\n  enabled: boolean;\n  port: number;\n  maxConnections: number;\n  heartbeatInterval: number;\n  auth: AuthConfig;\n}\n\nexport interface WebSocketClient {\n  id: string;\n  ws: WebSocket;\n  user?: {\n    id: string;\n    role: string;\n    permissions: string[];\n    method: string;\n  };\n  subscriptions: Set<string>;\n  lastHeartbeat: number;\n  isAlive: boolean;\n}\n\n/**\n * External WebSocket manager for AI agent real-time notifications\n * Extends the existing QueryNotificationManager with external access capabilities\n */\nexport class ExternalWebSocketManager extends EventEmitter {\n  private server: WebSocket.Server | null = null;\n  private clients: Map<string, WebSocketClient> = new Map();\n  private config: ExternalWebSocketConfig;\n  private queryNotificationManager: QueryNotificationManager;\n  private heartbeatInterval: ReturnType<typeof setInterval> | null = null;\n  private isRunning: boolean = false;\n\n  constructor(config: ExternalWebSocketConfig, queryNotificationManager: QueryNotificationManager) {\n    super();\n    this.config = config;\n    this.queryNotificationManager = queryNotificationManager;\n    this.setupQueryNotificationForwarding();\n  }\n\n  /**\n   * Start the external WebSocket server\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error('External WebSocket server is already running');\n    }\n\n    if (!this.config.enabled) {\n      console.log('[ExternalWebSocketManager] External WebSocket server is disabled');\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.server = new WebSocket.Server({\n          port: this.config.port,\n          perMessageDeflate: false,\n          maxPayload: 1024 * 1024, // 1MB max message size\n          verifyClient: (info: { origin: string; secure: boolean; req: IncomingMessage }) =>\n            this.verifyClient(info),\n        });\n\n        this.server.on('connection', (ws: WebSocket, request: IncomingMessage) => {\n          this.handleConnection(ws, request);\n        });\n\n        this.server.on('error', error => {\n          console.error('[ExternalWebSocketManager] Server error:', error);\n          this.emit('error', error);\n        });\n\n        this.server.on('listening', () => {\n          this.isRunning = true;\n          this.startHeartbeat();\n          console.log(\n            `[ExternalWebSocketManager] External WebSocket server started on port ${this.config.port}`\n          );\n          resolve();\n        });\n      } catch (error: unknown) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Stop the external WebSocket server\n   */\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n\n    return new Promise(resolve => {\n      // Stop heartbeat\n      if (this.heartbeatInterval) {\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n\n      // Close all client connections\n      this.clients.forEach(client => {\n        client.ws.close(1001, 'Server shutting down');\n      });\n      this.clients.clear();\n\n      // Close server\n      if (this.server) {\n        this.server.close(() => {\n          this.isRunning = false;\n          console.log('[ExternalWebSocketManager] External WebSocket server stopped');\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Verify client connection\n   */\n  private verifyClient(info: { origin: string; secure: boolean; req: IncomingMessage }): boolean {\n    // Check connection limits\n    if (this.clients.size >= this.config.maxConnections) {\n      console.log('[ExternalWebSocketManager] Connection rejected: max connections reached');\n      return false;\n    }\n\n    // In local-only mode, only allow localhost connections\n    if (this.config.auth.localOnly) {\n      const clientIP = info.req.socket.remoteAddress || '';\n      const isLocalhost =\n        ['127.0.0.1', '::1', '::ffff:127.0.0.1'].includes(clientIP) ||\n        clientIP.startsWith('127.') ||\n        clientIP === 'localhost';\n\n      if (!isLocalhost) {\n        console.log(`[ExternalWebSocketManager] Connection rejected: non-localhost IP ${clientIP}`);\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle new WebSocket connection\n   */\n  private async handleConnection(ws: WebSocket, request: IncomingMessage): Promise<void> {\n    const clientId = this.generateClientId();\n    const client: WebSocketClient = {\n      id: clientId,\n      ws,\n      subscriptions: new Set(),\n      lastHeartbeat: Date.now(),\n      isAlive: true,\n    };\n\n    // Authenticate the client\n    try {\n      const user = await this.authenticateClient(request);\n      client.user = user;\n    } catch (error: unknown) {\n      console.log(\n        `[ExternalWebSocketManager] Authentication failed for client ${clientId}:`,\n        error\n      );\n      ws.close(1008, 'Authentication failed');\n      return;\n    }\n\n    this.clients.set(clientId, client);\n    console.log(\n      `[ExternalWebSocketManager] Client ${clientId} connected (user: ${client.user?.id || 'anonymous'})`\n    );\n\n    // Set up client event handlers\n    ws.on('message', data => {\n      this.handleClientMessage(clientId, data);\n    });\n\n    ws.on('close', (code, reason) => {\n      console.log(\n        `[ExternalWebSocketManager] Client ${clientId} disconnected (${code}: ${reason})`\n      );\n      this.clients.delete(clientId);\n      this.emit('clientDisconnected', clientId);\n    });\n\n    ws.on('error', error => {\n      console.error(`[ExternalWebSocketManager] Client ${clientId} error:`, error);\n      this.clients.delete(clientId);\n    });\n\n    ws.on('pong', () => {\n      const client = this.clients.get(clientId);\n      if (client) {\n        client.isAlive = true;\n        client.lastHeartbeat = Date.now();\n      }\n    });\n\n    // Send welcome message\n    this.sendToClient(clientId, {\n      type: 'welcome',\n      client_id: clientId,\n      server_time: new Date().toISOString(),\n      capabilities: ['query_notifications', 'session_events', 'system_status', 'real_time_updates'],\n    });\n\n    this.emit('clientConnected', clientId, client.user);\n  }\n\n  /**\n   * Authenticate WebSocket client\n   */\n  private async authenticateClient(\n    request: IncomingMessage\n  ): Promise<{ id: string; role: string; permissions: string[]; method: string }> {\n    const url = new URL(request.url || '', `ws://localhost:${this.config.port}`);\n\n    // Try different authentication methods\n\n    // 1. JWT token from query parameter\n    const token = url.searchParams.get('token');\n    if (token && this.config.auth.method === 'jwt_token') {\n      try {\n        const decoded = verifyJwtToken(token, this.config.auth);\n        return {\n          id: (decoded.sub as string) || (decoded.id as string) || 'jwt_user',\n          role: (decoded.role as string) || 'agent',\n          permissions:\n            (decoded.permissions as string[]) ||\n            this.getDefaultPermissions((decoded.role as string) || 'agent'),\n          method: 'jwt_token',\n        };\n      } catch (error: unknown) {\n        console.error('[ExternalWebSocketManager] JWT verification failed:', error);\n      }\n    }\n\n    // 2. API key from query parameter\n    const apiKey = url.searchParams.get('api_key');\n    if (apiKey && this.config.auth.method === 'api_key') {\n      const isValidKey = this.config.auth.apiKeys.includes(apiKey);\n      if (isValidKey) {\n        return {\n          id: `api_key_${apiKey.substring(0, 8)}`,\n          role: 'agent',\n          permissions: this.getDefaultPermissions('agent'),\n          method: 'api_key',\n        };\n      }\n    }\n\n    // 3. Local-only mode\n    if (this.config.auth.localOnly || this.config.auth.method === 'local_only') {\n      const clientIP = request.socket.remoteAddress || '';\n      const isLocalhost =\n        ['127.0.0.1', '::1', '::ffff:127.0.0.1'].includes(clientIP) ||\n        clientIP.startsWith('127.') ||\n        clientIP === 'localhost';\n\n      if (isLocalhost) {\n        return {\n          id: 'localhost',\n          role: 'admin',\n          permissions: ['*'],\n          method: 'local_only',\n        };\n      }\n    }\n\n    throw new Error('Authentication required');\n  }\n\n  /**\n   * Handle client message\n   */\n  private handleClientMessage(clientId: string, data: WebSocket.Data): void {\n    const client = this.clients.get(clientId);\n    if (!client) return;\n\n    try {\n      const message = JSON.parse(data.toString());\n      console.log(`[ExternalWebSocketManager] Message from ${clientId}:`, message.type);\n\n      switch (message.type) {\n        case 'subscribe':\n          this.handleSubscribe(clientId, message);\n          break;\n        case 'unsubscribe':\n          this.handleUnsubscribe(clientId, message);\n          break;\n        case 'cancel_query':\n          this.handleCancelQuery(clientId, message);\n          break;\n        case 'get_query_status':\n          this.handleGetQueryStatus(clientId, message);\n          break;\n        case 'get_system_status':\n          this.handleGetSystemStatus(clientId, message);\n          break;\n        case 'ping':\n          this.sendToClient(clientId, { type: 'pong', timestamp: Date.now() });\n          break;\n        default:\n          this.sendToClient(clientId, {\n            type: 'error',\n            message: `Unknown message type: ${message.type}`,\n          });\n      }\n    } catch (error: unknown) {\n      console.error(`[ExternalWebSocketManager] Error parsing message from ${clientId}:`, error);\n      this.sendToClient(clientId, {\n        type: 'error',\n        message: 'Invalid message format',\n      });\n    }\n  }\n\n  /**\n   * Handle subscription request\n   */\n  private handleSubscribe(\n    clientId: string,\n    message: { query_id?: string; session_id?: string; event_types?: string[] }\n  ): void {\n    const client = this.clients.get(clientId);\n    if (!client) return;\n\n    const {\n      query_id,\n      session_id,\n      event_types = ['progress', 'complete', 'error', 'cancel'],\n    } = message;\n\n    // Check permissions\n    if (!hasPermission(client.user ?? undefined, 'notifications:subscribe')) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        message: 'Insufficient permissions to subscribe to notifications',\n      });\n      return;\n    }\n\n    // Add subscriptions\n    if (query_id) {\n      client.subscriptions.add(`query:${query_id}`);\n    }\n    if (session_id) {\n      client.subscriptions.add(`session:${session_id}`);\n    }\n\n    event_types.forEach((eventType: string) => {\n      client.subscriptions.add(`event:${eventType}`);\n    });\n\n    this.sendToClient(clientId, {\n      type: 'subscribed',\n      query_id,\n      session_id,\n      event_types,\n      message: 'Successfully subscribed to notifications',\n    });\n  }\n\n  /**\n   * Handle unsubscribe request\n   */\n  private handleUnsubscribe(\n    clientId: string,\n    message: { query_id?: string; session_id?: string; event_types?: string[] }\n  ): void {\n    const client = this.clients.get(clientId);\n    if (!client) return;\n\n    const { query_id, session_id, event_types } = message;\n\n    if (query_id) {\n      client.subscriptions.delete(`query:${query_id}`);\n    }\n    if (session_id) {\n      client.subscriptions.delete(`session:${session_id}`);\n    }\n    if (event_types) {\n      event_types.forEach((eventType: string) => {\n        client.subscriptions.delete(`event:${eventType}`);\n      });\n    }\n\n    this.sendToClient(clientId, {\n      type: 'unsubscribed',\n      query_id,\n      session_id,\n      event_types,\n      message: 'Successfully unsubscribed from notifications',\n    });\n  }\n\n  /**\n   * Handle query cancellation request\n   */\n  private handleCancelQuery(clientId: string, message: { query_id?: string }): void {\n    const client = this.clients.get(clientId);\n    if (!client || !hasPermission(client.user ?? undefined, 'query:cancel')) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        message: 'Insufficient permissions to cancel queries',\n      });\n      return;\n    }\n\n    const { query_id } = message;\n    if (!query_id) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        message: 'Query ID is required for cancellation',\n      });\n      return;\n    }\n\n    // Forward to query notification manager\n    const cancelled = this.queryNotificationManager.cancelQuery(query_id);\n\n    this.sendToClient(clientId, {\n      type: 'query_cancel_response',\n      query_id,\n      cancelled,\n      message: cancelled ? 'Query cancelled successfully' : 'Query not found or already completed',\n    });\n  }\n\n  /**\n   * Handle query status request\n   */\n  private handleGetQueryStatus(clientId: string, message: { query_id?: string }): void {\n    const client = this.clients.get(clientId);\n    if (!client || !hasPermission(client.user ?? undefined, 'query:status')) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        message: 'Insufficient permissions to get query status',\n      });\n      return;\n    }\n\n    const { query_id } = message;\n    const status = this.queryNotificationManager.getQueryStatus(query_id || '');\n\n    this.sendToClient(clientId, {\n      type: 'query_status_response',\n      query_id,\n      status: status || null,\n      found: !!status,\n    });\n  }\n\n  /**\n   * Handle system status request\n   */\n  private handleGetSystemStatus(clientId: string, message: Record<string, unknown>): void {\n    const client = this.clients.get(clientId);\n    if (!client || !hasPermission(client.user ?? undefined, 'status:read')) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        message: 'Insufficient permissions to get system status',\n      });\n      return;\n    }\n\n    const stats = this.queryNotificationManager.getStatistics();\n\n    this.sendToClient(clientId, {\n      type: 'system_status_response',\n      active_queries: stats.running,\n      total_queries: stats.total,\n      connected_clients: this.clients.size,\n      server_uptime: process.uptime(),\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Send message to specific client\n   */\n  private sendToClient(clientId: string, message: Record<string, unknown>): void {\n    const client = this.clients.get(clientId);\n    if (!client || client.ws.readyState !== client.ws.OPEN) return;\n\n    try {\n      client.ws.send(JSON.stringify(message));\n    } catch (error: unknown) {\n      console.error(`[ExternalWebSocketManager] Error sending message to ${clientId}:`, error);\n      this.clients.delete(clientId);\n    }\n  }\n\n  /**\n   * Broadcast message to all subscribed clients\n   */\n  private broadcast(message: Record<string, unknown>, subscription?: string): void {\n    this.clients.forEach((client, clientId) => {\n      if (subscription && !client.subscriptions.has(subscription)) return;\n      this.sendToClient(clientId, message);\n    });\n  }\n\n  /**\n   * Set up forwarding from QueryNotificationManager\n   */\n  private setupQueryNotificationForwarding(): void {\n    this.queryNotificationManager.on('queryStatusUpdated', status => {\n      this.broadcast(\n        {\n          type: 'query_progress',\n          query_id: status.id,\n          status: status.status,\n          progress: status.progress,\n          message: status.message,\n          timestamp: new Date().toISOString(),\n        },\n        `query:${status.id}`\n      );\n\n      this.broadcast(\n        {\n          type: 'query_progress',\n          query_id: status.id,\n          status: status.status,\n          progress: status.progress,\n          message: status.message,\n          timestamp: new Date().toISOString(),\n        },\n        `event:${status.status}`\n      );\n    });\n\n    this.queryNotificationManager.on('query_completed', status => {\n      this.broadcast(\n        {\n          type: 'query_complete',\n          query_id: status.id,\n          results: status.results,\n          execution_time: status.endTime ? status.endTime - status.startTime : 0,\n          timestamp: new Date().toISOString(),\n        },\n        `query:${status.id}`\n      );\n    });\n  }\n\n  /**\n   * Start heartbeat mechanism\n   */\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      this.clients.forEach((client, clientId) => {\n        if (!client.isAlive) {\n          console.log(`[ExternalWebSocketManager] Terminating inactive client ${clientId}`);\n          client.ws.terminate();\n          this.clients.delete(clientId);\n          return;\n        }\n\n        client.isAlive = false;\n        client.ws.ping();\n      });\n    }, this.config.heartbeatInterval * 1000);\n  }\n\n  /**\n   * Generate unique client ID\n   */\n  private generateClientId(): string {\n    return `ws_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get default permissions for role\n   */\n  private getDefaultPermissions(role: string): string[] {\n    const rolePermissions: { [key: string]: string[] } = {\n      admin: ['*'],\n      agent: [\n        'query:execute',\n        'query:cancel',\n        'query:status',\n        'notifications:subscribe',\n        'session:read',\n        'status:read',\n      ],\n      readonly: ['query:status', 'notifications:subscribe', 'status:read'],\n      limited: ['query:status'],\n    };\n\n    return rolePermissions[role] || rolePermissions['limited'] || [];\n  }\n\n  /**\n   * Get server status\n   */\n  getStatus(): {\n    running: boolean;\n    port: number;\n    connectedClients: number;\n    maxConnections: number;\n  } {\n    return {\n      running: this.isRunning,\n      port: this.config.port,\n      connectedClients: this.clients.size,\n      maxConnections: this.config.maxConnections,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\hoverProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\installationChecker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\installationGuide.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\localization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\multiIDESupport.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":574,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":574,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":749,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":749,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { exec } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Multi-IDE Support for Prolog LSP\n * Provides configuration and setup for various IDEs and editors\n */\nexport class MultiIDESupport {\n  private static readonly SUPPORTED_IDES = [\n    'vscode',\n    'vim',\n    'neovim',\n    'emacs',\n    'sublime',\n    'atom',\n    'intellij',\n    'eclipse',\n    'theia',\n    'coc-nvim',\n  ];\n\n  /**\n   * Generate LSP configuration files for different IDEs\n   */\n  public static async generateIDEConfigurations(workspaceRoot: string): Promise<void> {\n    const configs = {\n      // VS Code configuration (already handled by extension)\n      vscode: this.generateVSCodeConfig(),\n\n      // Vim/Neovim with coc.nvim\n      'coc-settings': this.generateCocNvimConfig(),\n\n      // Neovim with built-in LSP\n      neovim: this.generateNeovimConfig(),\n\n      // Vim with vim-lsp\n      vim: this.generateVimLspConfig(),\n\n      // Emacs with lsp-mode\n      emacs: this.generateEmacsConfig(),\n\n      // Sublime Text with LSP package\n      sublime: this.generateSublimeConfig(),\n\n      // IntelliJ IDEA configuration\n      intellij: this.generateIntelliJConfig(),\n\n      // Eclipse configuration\n      eclipse: this.generateEclipseConfig(),\n\n      // Theia configuration\n      theia: this.generateTheiaConfig(),\n    };\n\n    // Create .lsp directory for configurations\n    const lspDir = path.join(workspaceRoot, '.lsp');\n    if (!fs.existsSync(lspDir)) {\n      fs.mkdirSync(lspDir, { recursive: true });\n    }\n\n    // Write configuration files\n    for (const [ide, config] of Object.entries(configs)) {\n      if (config) {\n        const configPath = path.join(lspDir, `${ide}.json`);\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n      }\n    }\n\n    // Generate setup scripts\n    await this.generateSetupScripts(lspDir);\n\n    // Generate documentation\n    await this.generateIDEDocumentation(lspDir);\n  }\n\n  private static generateVSCodeConfig() {\n    return {\n      name: 'Prolog LSP for VS Code',\n      description: 'Already configured through the VSCode Prolog Toolkit extension',\n      status: 'native_support',\n      setup: 'Install the VSCode Prolog Toolkit extension from the marketplace',\n    };\n  }\n\n  private static generateCocNvimConfig() {\n    return {\n      languageserver: {\n        prolog: {\n          command: 'node',\n          args: ['./out/pub/features/prologLSPServer.js', '--stdio'],\n          filetypes: ['prolog'],\n          rootPatterns: ['.git', '*.pl', '*.pro', '*.prolog'],\n          settings: {\n            prolog: {\n              executablePath: 'swipl',\n              dialect: 'swi',\n              linter: {\n                run: 'onType',\n                delay: 500,\n              },\n            },\n          },\n          initializationOptions: {\n            enableSnippets: true,\n            enableFormatting: true,\n            enableDiagnostics: true,\n          },\n        },\n      },\n    };\n  }\n\n  private static generateNeovimConfig() {\n    return {\n      setup_function: `\n-- Neovim built-in LSP setup for Prolog\nlocal lspconfig = require('lspconfig')\nlocal configs = require('lspconfig.configs')\n\n-- Define Prolog LSP configuration\nif not configs.prolog_lsp then\n  configs.prolog_lsp = {\n    default_config = {\n      cmd = {'node', './out/pub/features/prologLSPServer.js', '--stdio'},\n      filetypes = {'prolog'},\n      root_dir = lspconfig.util.root_pattern('.git', '*.pl', '*.pro', '*.prolog'),\n      settings = {\n        prolog = {\n          executablePath = 'swipl',\n          dialect = 'swi',\n          linter = {\n            run = 'onType',\n            delay = 500\n          }\n        }\n      }\n    }\n  }\nend\n\n-- Setup the LSP\nlspconfig.prolog_lsp.setup({\n  on_attach = function(client, bufnr)\n    -- Enable completion triggered by <c-x><c-o>\n    vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')\n    \n    -- Mappings\n    local opts = { noremap=true, silent=true }\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)\n    vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)\n  end,\n  capabilities = require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities())\n})\n      `,\n      filetype_detection: `\n-- Add Prolog filetype detection\nvim.cmd([[\n  augroup PrologFiletype\n    autocmd!\n    autocmd BufRead,BufNewFile *.pl,*.pro,*.prolog,*.plt,*.ecl set filetype=prolog\n  augroup END\n]])\n      `,\n    };\n  }\n\n  private static generateVimLspConfig() {\n    return {\n      vim_script: `\n\" Vim-LSP configuration for Prolog\nif executable('node')\n  augroup LspProlog\n    autocmd!\n    autocmd User lsp_setup call lsp#register_server({\n      \\\\ 'name': 'prolog-lsp',\n      \\\\ 'cmd': {server_info->['node', './out/pub/features/prologLSPServer.js', '--stdio']},\n      \\\\ 'allowlist': ['prolog'],\n      \\\\ 'root_uri': {server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), ['.git', '*.pl', '*.pro']))},\n      \\\\ })\n  augroup END\nendif\n\n\" Prolog filetype detection\naugroup PrologFiletype\n  autocmd!\n  autocmd BufRead,BufNewFile *.pl,*.pro,*.prolog,*.plt,*.ecl set filetype=prolog\naugroup END\n\n\" Key mappings for LSP\nfunction! s:on_lsp_buffer_enabled() abort\n  setlocal omnifunc=lsp#complete\n  setlocal signcolumn=yes\n  if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif\n  nmap <buffer> gd <plug>(lsp-definition)\n  nmap <buffer> gs <plug>(lsp-document-symbol-search)\n  nmap <buffer> gS <plug>(lsp-workspace-symbol-search)\n  nmap <buffer> gr <plug>(lsp-references)\n  nmap <buffer> gi <plug>(lsp-implementation)\n  nmap <buffer> gt <plug>(lsp-type-definition)\n  nmap <buffer> <leader>rn <plug>(lsp-rename)\n  nmap <buffer> [g <plug>(lsp-previous-diagnostic)\n  nmap <buffer> ]g <plug>(lsp-next-diagnostic)\n  nmap <buffer> K <plug>(lsp-hover)\nendfunction\n\naugroup lsp_install\n  au!\n  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()\naugroup END\n      `,\n    };\n  }\n\n  private static generateEmacsConfig() {\n    return {\n      elisp_config: `\n;; Emacs LSP configuration for Prolog\n(use-package lsp-mode\n  :hook (prolog-mode . lsp)\n  :commands lsp\n  :config\n  (lsp-register-client\n   (make-lsp-client\n    :new-connection (lsp-stdio-connection '(\"node\" \"./out/pub/features/prologLSPServer.js\" \"--stdio\"))\n    :major-modes '(prolog-mode)\n    :server-id 'prolog-lsp\n    :root-uri (lsp-workspace-root)\n    :initialization-options '((enableSnippets . t)\n                             (enableFormatting . t)\n                             (enableDiagnostics . t)))))\n\n;; Prolog mode setup\n(use-package prolog\n  :mode ((\"\\\\\\\\.pl\\\\\\\\'\" . prolog-mode)\n         (\"\\\\\\\\.pro\\\\\\\\'\" . prolog-mode)\n         (\"\\\\\\\\.prolog\\\\\\\\'\" . prolog-mode)\n         (\"\\\\\\\\.plt\\\\\\\\'\" . prolog-mode)\n         (\"\\\\\\\\.ecl\\\\\\\\'\" . prolog-mode))\n  :config\n  (setq prolog-system 'swi))\n\n;; LSP UI enhancements\n(use-package lsp-ui\n  :commands lsp-ui-mode\n  :config\n  (setq lsp-ui-doc-enable t\n        lsp-ui-doc-position 'at-point\n        lsp-ui-sideline-enable t\n        lsp-ui-sideline-show-hover t))\n\n;; Company completion\n(use-package company-lsp\n  :commands company-lsp\n  :config\n  (push 'company-lsp company-backends))\n      `,\n    };\n  }\n\n  private static generateSublimeConfig() {\n    return {\n      'LSP.sublime-settings': {\n        clients: {\n          'prolog-lsp': {\n            enabled: true,\n            command: ['node', './out/pub/features/prologLSPServer.js', '--stdio'],\n            selector: 'source.prolog',\n            settings: {\n              prolog: {\n                executablePath: 'swipl',\n                dialect: 'swi',\n                linter: {\n                  run: 'onType',\n                  delay: 500,\n                },\n              },\n            },\n            initializationOptions: {\n              enableSnippets: true,\n              enableFormatting: true,\n              enableDiagnostics: true,\n            },\n          },\n        },\n      },\n      'Prolog.sublime-syntax': `\n%YAML 1.2\n---\nname: Prolog\nfile_extensions: [pl, pro, prolog, plt, ecl]\nscope: source.prolog\n\ncontexts:\n  main:\n    - include: comments\n    - include: strings\n    - include: numbers\n    - include: predicates\n    - include: variables\n    - include: operators\n\n  comments:\n    - match: '%.*$'\n      scope: comment.line.prolog\n    - match: '/\\\\*'\n      push: block_comment\n\n  block_comment:\n    - meta_scope: comment.block.prolog\n    - match: '\\\\*/'\n      pop: true\n\n  strings:\n    - match: \"'\"\n      push: single_quoted_string\n    - match: '\"'\n      push: double_quoted_string\n\n  single_quoted_string:\n    - meta_scope: string.quoted.single.prolog\n    - match: \"'\"\n      pop: true\n\n  double_quoted_string:\n    - meta_scope: string.quoted.double.prolog\n    - match: '\"'\n      pop: true\n\n  numbers:\n    - match: '\\\\b\\\\d+(\\\\.\\\\d+)?\\\\b'\n      scope: constant.numeric.prolog\n\n  predicates:\n    - match: '\\\\b[a-z][a-zA-Z0-9_]*(?=\\\\s*\\\\()'\n      scope: entity.name.function.prolog\n\n  variables:\n    - match: '\\\\b[A-Z_][a-zA-Z0-9_]*\\\\b'\n      scope: variable.prolog\n\n  operators:\n    - match: ':-|->|;|,|\\\\+|\\\\-|\\\\*|/|=|\\\\\\\\=|==|\\\\\\\\==|@<|@>|@=<|@>='\n      scope: keyword.operator.prolog\n      `,\n    };\n  }\n\n  private static generateIntelliJConfig() {\n    return {\n      plugin_xml: `\n<idea-plugin>\n  <id>com.example.prolog-lsp</id>\n  <name>Prolog LSP Support</name>\n  <version>1.0</version>\n  <vendor>Prolog Toolkit</vendor>\n  \n  <description>\n    Language Server Protocol support for Prolog in IntelliJ IDEA\n  </description>\n  \n  <depends>com.intellij.modules.platform</depends>\n  <depends>com.redhat.devtools.lsp4ij</depends>\n  \n  <extensions defaultExtensionNs=\"com.intellij\">\n    <fileType name=\"Prolog\" \n              implementationClass=\"com.example.prolog.PrologFileType\" \n              fieldName=\"INSTANCE\" \n              language=\"Prolog\" \n              extensions=\"pl;pro;prolog;plt;ecl\"/>\n              \n    <lang.parserDefinition language=\"Prolog\" \n                          implementationClass=\"com.example.prolog.PrologParserDefinition\"/>\n  </extensions>\n  \n  <extensions defaultExtensionNs=\"com.redhat.devtools.lsp4ij\">\n    <server id=\"prolog-lsp\"\n            name=\"Prolog Language Server\"\n            factoryClass=\"com.example.prolog.PrologLanguageServerFactory\"/>\n  </extensions>\n</idea-plugin>\n      `,\n      server_factory: `\npublic class PrologLanguageServerFactory implements LanguageServerFactory {\n    @Override\n    public LanguageServerDefinition createLanguageServerDefinition(@NotNull Project project) {\n        return new LanguageServerDefinition(\n            \"prolog-lsp\",\n            \"Prolog Language Server\",\n            Arrays.asList(\"node\", \"./out/pub/features/prologLSPServer.js\", \"--stdio\"),\n            Arrays.asList(\"pl\", \"pro\", \"prolog\", \"plt\", \"ecl\")\n        );\n    }\n}\n      `,\n    };\n  }\n\n  private static generateEclipseConfig() {\n    return {\n      plugin_xml: `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<plugin>\n   <extension point=\"org.eclipse.lsp4e.languageServer\">\n      <server id=\"prolog.lsp\"\n              label=\"Prolog Language Server\"\n              class=\"org.eclipse.lsp4e.server.ProcessStreamConnectionProvider\">\n         <commandline>\n            <arg>node</arg>\n            <arg>./out/pub/features/prologLSPServer.js</arg>\n            <arg>--stdio</arg>\n         </commandline>\n      </server>\n   </extension>\n   \n   <extension point=\"org.eclipse.lsp4e.languageServerMapping\">\n      <mapping languageId=\"prolog\"\n               serverId=\"prolog.lsp\"\n               contentTypeId=\"org.eclipse.prolog.contentType\"/>\n   </extension>\n   \n   <extension point=\"org.eclipse.core.contenttype.contentTypes\">\n      <content-type id=\"org.eclipse.prolog.contentType\"\n                    name=\"Prolog\"\n                    base-type=\"org.eclipse.core.runtime.text\"\n                    file-extensions=\"pl,pro,prolog,plt,ecl\"/>\n   </extension>\n</plugin>\n      `,\n    };\n  }\n\n  private static generateTheiaConfig() {\n    return {\n      'package.json': {\n        name: 'prolog-lsp-theia',\n        version: '1.0.0',\n        description: 'Prolog LSP support for Theia',\n        dependencies: {\n          '@theia/core': 'latest',\n          '@theia/languages': 'latest',\n          'vscode-languageserver-protocol': 'latest',\n        },\n        theiaExtensions: [\n          {\n            frontend: 'lib/browser/prolog-frontend-module',\n            backend: 'lib/node/prolog-backend-module',\n          },\n        ],\n      },\n      frontend_module: `\nimport { ContainerModule } from 'inversify';\nimport { LanguageClientContribution } from '@theia/languages/lib/browser';\nimport { PrologLanguageClientContribution } from './prolog-language-client-contribution';\n\nexport default new ContainerModule(bind => {\n    bind(LanguageClientContribution).to(PrologLanguageClientContribution).inSingletonScope();\n});\n      `,\n      client_contribution: `\nimport { injectable } from 'inversify';\nimport { LanguageClientContribution, ILanguageClient } from '@theia/languages/lib/browser';\nimport { PROLOG_LANGUAGE_ID, PROLOG_LANGUAGE_NAME } from '../common';\n\n@injectable()\nexport class PrologLanguageClientContribution implements LanguageClientContribution {\n    readonly id = PROLOG_LANGUAGE_ID;\n    readonly name = PROLOG_LANGUAGE_NAME;\n\n    start(languageClient: ILanguageClient): void {\n        const command = 'node';\n        const args = ['./out/pub/features/prologLSPServer.js', '--stdio'];\n        \n        languageClient.start({\n            command,\n            args,\n            options: {}\n        });\n    }\n}\n      `,\n    };\n  }\n\n  private static async generateSetupScripts(lspDir: string): Promise<void> {\n    // Bash setup script\n    const bashScript = `#!/bin/bash\n# Prolog LSP Setup Script\n\necho \"Setting up Prolog LSP for multiple IDEs...\"\n\n# Check if Node.js is installed\nif ! command -v node &> /dev/null; then\n    echo \"Error: Node.js is required but not installed.\"\n    echo \"Please install Node.js from https://nodejs.org/\"\n    exit 1\nfi\n\n# Check if SWI-Prolog is installed\nif ! command -v swipl &> /dev/null; then\n    echo \"Warning: SWI-Prolog not found in PATH.\"\n    echo \"Please install SWI-Prolog from https://www.swi-prolog.org/\"\nfi\n\necho \"Available IDE configurations:\"\nfor config in *.json; do\n    if [ -f \"$config\" ]; then\n        ide_name=$(basename \"$config\" .json)\n        echo \"  - $ide_name\"\n    fi\ndone\n\necho \"\"\necho \"To use with your IDE:\"\necho \"1. Copy the appropriate configuration file\"\necho \"2. Follow the setup instructions in the documentation\"\necho \"3. Restart your IDE\"\n\necho \"Setup complete!\"\n`;\n\n    // PowerShell setup script\n    const powershellScript = `# Prolog LSP Setup Script for Windows\n\nWrite-Host \"Setting up Prolog LSP for multiple IDEs...\" -ForegroundColor Green\n\n# Check if Node.js is installed\ntry {\n    $nodeVersion = node --version\n    Write-Host \"Node.js found: $nodeVersion\" -ForegroundColor Green\n} catch {\n    Write-Host \"Error: Node.js is required but not installed.\" -ForegroundColor Red\n    Write-Host \"Please install Node.js from https://nodejs.org/\" -ForegroundColor Yellow\n    exit 1\n}\n\n# Check if SWI-Prolog is installed\ntry {\n    $swiplVersion = swipl --version\n    Write-Host \"SWI-Prolog found: $swiplVersion\" -ForegroundColor Green\n} catch {\n    Write-Host \"Warning: SWI-Prolog not found in PATH.\" -ForegroundColor Yellow\n    Write-Host \"Please install SWI-Prolog from https://www.swi-prolog.org/\" -ForegroundColor Yellow\n}\n\nWrite-Host \"Available IDE configurations:\" -ForegroundColor Cyan\nGet-ChildItem -Filter \"*.json\" | ForEach-Object {\n    $ideName = $_.BaseName\n    Write-Host \"  - $ideName\" -ForegroundColor White\n}\n\nWrite-Host \"\"\nWrite-Host \"To use with your IDE:\" -ForegroundColor Cyan\nWrite-Host \"1. Copy the appropriate configuration file\" -ForegroundColor White\nWrite-Host \"2. Follow the setup instructions in the documentation\" -ForegroundColor White\nWrite-Host \"3. Restart your IDE\" -ForegroundColor White\n\nWrite-Host \"Setup complete!\" -ForegroundColor Green\n`;\n\n    fs.writeFileSync(path.join(lspDir, 'setup.sh'), bashScript);\n    fs.writeFileSync(path.join(lspDir, 'setup.ps1'), powershellScript);\n\n    // Make bash script executable on Unix systems\n    try {\n      fs.chmodSync(path.join(lspDir, 'setup.sh'), 0o755);\n    } catch (_error) {\n      // Ignore chmod errors on Windows\n    }\n  }\n\n  private static async generateIDEDocumentation(lspDir: string): Promise<void> {\n    const documentation = `# Prolog LSP Multi-IDE Support\n\nThis directory contains configuration files and setup instructions for using the Prolog Language Server with various IDEs and editors.\n\n## Supported IDEs\n\n### VS Code\n- **Status**: Native support through VSCode Prolog Toolkit extension\n- **Setup**: Install the extension from the marketplace\n- **Configuration**: Automatic\n\n### Vim/Neovim\n- **coc.nvim**: Copy \\`coc-settings.json\\` to your coc configuration\n- **Built-in LSP (Neovim)**: Add the Lua configuration to your init.lua\n- **vim-lsp**: Add the Vim script to your .vimrc\n\n### Emacs\n- **lsp-mode**: Add the Elisp configuration to your init.el\n- **Requirements**: lsp-mode, lsp-ui, company-lsp packages\n\n### Sublime Text\n- **LSP Package**: Install the LSP package and copy the configuration\n- **Syntax**: Copy the syntax definition for Prolog highlighting\n\n### IntelliJ IDEA\n- **Plugin**: Install LSP4IJ plugin\n- **Configuration**: Use the provided plugin configuration\n\n### Eclipse\n- **LSP4E**: Install LSP4E plugin\n- **Configuration**: Use the provided plugin.xml configuration\n\n### Theia\n- **Extension**: Use the provided Theia extension configuration\n- **Build**: Follow Theia extension development guidelines\n\n## Features Supported\n\nAll IDE configurations support the following LSP features:\n\n- ✅ **Syntax Highlighting**: Prolog-specific syntax coloring\n- ✅ **Code Completion**: Intelligent autocompletion for predicates\n- ✅ **Hover Information**: Documentation on hover\n- ✅ **Go to Definition**: Navigate to predicate definitions\n- ✅ **Find References**: Find all uses of a predicate\n- ✅ **Document Symbols**: Outline view of predicates\n- ✅ **Workspace Symbols**: Search predicates across workspace\n- ✅ **Diagnostics**: Real-time error and warning detection\n- ✅ **Code Actions**: Quick fixes and refactoring\n- ✅ **Document Formatting**: Automatic code formatting\n- ✅ **Signature Help**: Parameter hints for predicates\n- ✅ **Rename**: Rename predicates across files\n- ✅ **Folding**: Code folding for clauses and comments\n- ✅ **Semantic Tokens**: Enhanced syntax highlighting\n\n## Advanced Features\n\n### N3/RDF Support\n- Semantic web reasoning with N3 notation\n- RDF triple validation and completion\n- RDFS inference support\n\n### Query Execution\n- Execute Prolog queries directly from the editor\n- Interactive query results\n- Query history and management\n\n### Help System\n- Integrated SWI-Prolog documentation\n- Predicate help on demand\n- Example code snippets\n\n## Setup Instructions\n\n1. **Prerequisites**:\n   - Node.js (v14 or later)\n   - SWI-Prolog (latest version)\n   - Your preferred IDE/editor\n\n2. **Installation**:\n   - Run the setup script for your platform:\n     - Linux/macOS: \\`./setup.sh\\`\n     - Windows: \\`./setup.ps1\\`\n\n3. **IDE Configuration**:\n   - Copy the appropriate configuration file\n   - Follow IDE-specific setup instructions\n   - Restart your IDE\n\n4. **Verification**:\n   - Open a .pl file\n   - Check that syntax highlighting works\n   - Try code completion (Ctrl+Space)\n   - Hover over a predicate for documentation\n\n## Troubleshooting\n\n### Common Issues\n\n1. **LSP Server not starting**:\n   - Check Node.js installation\n   - Verify server path in configuration\n   - Check IDE error logs\n\n2. **No syntax highlighting**:\n   - Verify file extension association\n   - Check syntax definition installation\n\n3. **No completions**:\n   - Ensure LSP client is connected\n   - Check server initialization logs\n\n4. **SWI-Prolog not found**:\n   - Add SWI-Prolog to system PATH\n   - Update executablePath in configuration\n\n### Getting Help\n\n- Check the main extension documentation\n- Review IDE-specific LSP documentation\n- Report issues on the project repository\n\n## Contributing\n\nTo add support for additional IDEs:\n\n1. Create configuration files following LSP standards\n2. Add setup instructions\n3. Test with the target IDE\n4. Submit a pull request\n\n## License\n\nThis multi-IDE support is part of the VSCode Prolog Toolkit and follows the same MIT license.\n`;\n\n    fs.writeFileSync(path.join(lspDir, 'README.md'), documentation);\n  }\n\n  /**\n   * Detect available IDEs on the system\n   */\n  public static async detectAvailableIDEs(): Promise<string[]> {\n    const available: string[] = [];\n\n    // Check for common IDE executables\n    const ideChecks = [\n      { name: 'vscode', commands: ['code', 'code-insiders'] },\n      { name: 'vim', commands: ['vim'] },\n      { name: 'neovim', commands: ['nvim'] },\n      { name: 'emacs', commands: ['emacs'] },\n      { name: 'sublime', commands: ['subl', 'sublime_text'] },\n      { name: 'intellij', commands: ['idea', 'intellij-idea-ultimate'] },\n    ];\n\n    for (const ide of ideChecks) {\n      for (const command of ide.commands) {\n        try {\n          await new Promise((resolve, reject) => {\n            exec(`which ${command}`, (error: unknown) => {\n              if (!error) {\n                available.push(ide.name);\n                resolve(true);\n              } else {\n                reject(error);\n              }\n            });\n          });\n          break; // Found one command for this IDE\n        } catch (error: unknown) {\n          // Command not found, continue\n        }\n      }\n    }\n\n    return [...new Set(available)]; // Remove duplicates\n  }\n\n  /**\n   * Generate IDE-specific launch configurations\n   */\n  public static generateLaunchConfigurations(workspaceRoot: string): void {\n    const launchConfig = {\n      version: '0.2.0',\n      configurations: [\n        {\n          name: 'Launch Prolog LSP Server',\n          type: 'node',\n          request: 'launch',\n          program: '${workspaceFolder}/out/pub/features/prologLSPServer.js',\n          args: ['--stdio'],\n          console: 'integratedTerminal',\n          internalConsoleOptions: 'neverOpen',\n          env: {\n            NODE_ENV: 'development',\n          },\n        },\n        {\n          name: 'Debug Prolog LSP Server',\n          type: 'node',\n          request: 'launch',\n          program: '${workspaceFolder}/out/pub/features/prologLSPServer.js',\n          args: ['--stdio'],\n          console: 'integratedTerminal',\n          internalConsoleOptions: 'neverOpen',\n          env: {\n            NODE_ENV: 'development',\n          },\n          sourceMaps: true,\n          outFiles: ['${workspaceFolder}/out/**/*.js'],\n        },\n      ],\n    };\n\n    const vscodeDir = path.join(workspaceRoot, '.vscode');\n    if (!fs.existsSync(vscodeDir)) {\n      fs.mkdirSync(vscodeDir, { recursive: true });\n    }\n\n    fs.writeFileSync(path.join(vscodeDir, 'launch.json'), JSON.stringify(launchConfig, null, 2));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\outputFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\packageManagerIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":239,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":239,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":324,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":324,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawn } from 'child_process';\nimport * as vscode from 'vscode';\nimport { PlatformType, PlatformUtils } from '../utils/platformUtils';\n\n/**\n * Package manager information interface\n */\nexport interface PackageManagerInfo {\n  name: string;\n  displayName: string;\n  checkCommand: string;\n  installCommand: string;\n  packageName: string;\n  isAvailable: boolean;\n  version?: string;\n  priority: number; // Higher priority = preferred\n}\n\n/**\n * Installation result interface\n */\nexport interface InstallationResult {\n  success: boolean;\n  packageManager: string;\n  command: string;\n  output?: string;\n  error?: string;\n  requiresElevation?: boolean;\n}\n\n/**\n * Package manager integration for SWI-Prolog installation\n */\nexport class PackageManagerIntegration {\n  private static instance: PackageManagerIntegration;\n  private platform: PlatformType;\n  private availableManagers: Map<string, PackageManagerInfo> = new Map();\n  private detectionCache: Map<string, boolean> = new Map();\n\n  public static getInstance(): PackageManagerIntegration {\n    if (!PackageManagerIntegration.instance) {\n      PackageManagerIntegration.instance = new PackageManagerIntegration();\n    }\n    return PackageManagerIntegration.instance;\n  }\n\n  constructor() {\n    this.platform = PlatformUtils.getPlatform();\n    this.initializePackageManagers();\n  }\n\n  /**\n   * Initialize platform-specific package managers\n   */\n  private initializePackageManagers(): void {\n    switch (this.platform) {\n      case 'windows':\n        this.initializeWindowsManagers();\n        break;\n      case 'macos':\n        this.initializeMacOSManagers();\n        break;\n      case 'linux':\n        this.initializeLinuxManagers();\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Initialize Windows package managers\n   */\n  private initializeWindowsManagers(): void {\n    const managers: PackageManagerInfo[] = [\n      {\n        name: 'winget',\n        displayName: 'Windows Package Manager (winget)',\n        checkCommand: 'winget --version',\n        installCommand: 'winget install SWI.SWI-Prolog',\n        packageName: 'SWI.SWI-Prolog',\n        isAvailable: false,\n        priority: 100,\n      },\n      {\n        name: 'chocolatey',\n        displayName: 'Chocolatey',\n        checkCommand: 'choco --version',\n        installCommand: 'choco install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 90,\n      },\n      {\n        name: 'scoop',\n        displayName: 'Scoop',\n        checkCommand: 'scoop --version',\n        installCommand: 'scoop install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 80,\n      },\n    ];\n\n    managers.forEach(manager => {\n      this.availableManagers.set(manager.name, manager);\n    });\n  }\n\n  /**\n   * Initialize macOS package managers\n   */\n  private initializeMacOSManagers(): void {\n    const managers: PackageManagerInfo[] = [\n      {\n        name: 'homebrew',\n        displayName: 'Homebrew',\n        checkCommand: 'brew --version',\n        installCommand: 'brew install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 100,\n      },\n      {\n        name: 'macports',\n        displayName: 'MacPorts',\n        checkCommand: 'port version',\n        installCommand: 'sudo port install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 90,\n      },\n    ];\n\n    managers.forEach(manager => {\n      this.availableManagers.set(manager.name, manager);\n    });\n  }\n\n  /**\n   * Initialize Linux package managers\n   */\n  private initializeLinuxManagers(): void {\n    const managers: PackageManagerInfo[] = [\n      {\n        name: 'apt',\n        displayName: 'APT (Ubuntu/Debian)',\n        checkCommand: 'apt --version',\n        installCommand: 'sudo apt update && sudo apt install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 100,\n      },\n      {\n        name: 'dnf',\n        displayName: 'DNF (Fedora)',\n        checkCommand: 'dnf --version',\n        installCommand: 'sudo dnf install pl',\n        packageName: 'pl',\n        isAvailable: false,\n        priority: 95,\n      },\n      {\n        name: 'yum',\n        displayName: 'YUM (CentOS/RHEL)',\n        checkCommand: 'yum --version',\n        installCommand: 'sudo yum install pl',\n        packageName: 'pl',\n        isAvailable: false,\n        priority: 90,\n      },\n      {\n        name: 'pacman',\n        displayName: 'Pacman (Arch Linux)',\n        checkCommand: 'pacman --version',\n        installCommand: 'sudo pacman -S swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 85,\n      },\n      {\n        name: 'zypper',\n        displayName: 'Zypper (openSUSE)',\n        checkCommand: 'zypper --version',\n        installCommand: 'sudo zypper install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 80,\n      },\n      {\n        name: 'snap',\n        displayName: 'Snap',\n        checkCommand: 'snap --version',\n        installCommand: 'sudo snap install swi-prolog',\n        packageName: 'swi-prolog',\n        isAvailable: false,\n        priority: 70,\n      },\n      {\n        name: 'flatpak',\n        displayName: 'Flatpak',\n        checkCommand: 'flatpak --version',\n        installCommand: 'flatpak install flathub org.swi_prolog.SWI-Prolog',\n        packageName: 'org.swi_prolog.SWI-Prolog',\n        isAvailable: false,\n        priority: 60,\n      },\n    ];\n\n    managers.forEach(manager => {\n      this.availableManagers.set(manager.name, manager);\n    });\n  }\n\n  /**\n   * Detect available package managers on the system\n   */\n  public async detectAvailableManagers(): Promise<PackageManagerInfo[]> {\n    const available: PackageManagerInfo[] = [];\n\n    for (const [name, manager] of this.availableManagers) {\n      // Check cache first\n      if (this.detectionCache.has(name)) {\n        manager.isAvailable = this.detectionCache.get(name)!;\n        if (manager.isAvailable) {\n          available.push(manager);\n        }\n        continue;\n      }\n\n      try {\n        const isAvailable = await this.checkPackageManagerAvailability(manager);\n        manager.isAvailable = isAvailable;\n        this.detectionCache.set(name, isAvailable);\n\n        if (isAvailable) {\n          available.push(manager);\n        }\n      } catch (_error) {\n        manager.isAvailable = false;\n        this.detectionCache.set(name, false);\n      }\n    }\n\n    // Sort by priority (higher priority first)\n    return available.sort((a, b) => b.priority - a.priority);\n  }\n\n  /**\n   * Check if a specific package manager is available\n   */\n  private async checkPackageManagerAvailability(manager: PackageManagerInfo): Promise<boolean> {\n    return new Promise(resolve => {\n      const [command, ...args] = manager.checkCommand.split(' ');\n      if (!command) {\n        resolve(false);\n        return;\n      }\n      const process: import('child_process').ChildProcess = spawn(command, args, {\n        stdio: ['ignore', 'pipe', 'pipe'],\n        timeout: 5000,\n      });\n\n      let hasOutput = false;\n\n      process.stdout?.on('data', data => {\n        const output = data.toString();\n        hasOutput = true;\n\n        // Try to extract version information\n        const versionMatch = output.match(/(\\d+\\.\\d+(?:\\.\\d+)?)/);\n        if (versionMatch) {\n          manager.version = versionMatch[1];\n        }\n      });\n\n      process.on('close', code => {\n        // Most package managers return 0 for version commands\n        resolve(code === 0 && hasOutput);\n      });\n\n      process.on('error', () => {\n        resolve(false);\n      });\n\n      // Timeout fallback\n      setTimeout(() => {\n        process.kill();\n        resolve(false);\n      }, 5000);\n    });\n  }\n\n  /**\n   * Check if SWI-Prolog is already installed via package managers\n   */\n  public async checkExistingInstallation(): Promise<{\n    isInstalled: boolean;\n    packageManager?: string;\n    version?: string;\n    packageName?: string;\n  }> {\n    const availableManagers = await this.detectAvailableManagers();\n\n    for (const manager of availableManagers) {\n      try {\n        const isInstalled = await this.checkPackageInstallation(manager);\n        if (isInstalled.installed) {\n          const result: {\n            isInstalled: boolean;\n            packageManager: string;\n            version?: string;\n            packageName: string;\n          } = {\n            isInstalled: true,\n            packageManager: manager.name,\n            packageName: manager.packageName,\n          };\n          if (isInstalled.version !== undefined) {\n            result.version = isInstalled.version;\n          }\n          return result;\n        }\n      } catch (_error) {\n        // Continue checking other managers\n        continue;\n      }\n    }\n\n    return { isInstalled: false };\n  }\n\n  /**\n   * Check if a package is installed via a specific package manager\n   */\n  private async checkPackageInstallation(manager: PackageManagerInfo): Promise<{\n    installed: boolean;\n    version?: string;\n  }> {\n    return new Promise(resolve => {\n      let checkCommand: string;\n      let expectedOutput: RegExp;\n\n      switch (manager.name) {\n        case 'winget':\n          checkCommand = `winget list ${manager.packageName}`;\n          expectedOutput = /SWI\\.SWI-Prolog/i;\n          break;\n        case 'chocolatey':\n          checkCommand = `choco list ${manager.packageName} --local-only`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'scoop':\n          checkCommand = `scoop list ${manager.packageName}`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'homebrew':\n          checkCommand = `brew list ${manager.packageName}`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'macports':\n          checkCommand = `port installed ${manager.packageName}`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'apt':\n          checkCommand = `dpkg -l ${manager.packageName}`;\n          expectedOutput = /^ii\\s+swi-prolog/m;\n          break;\n        case 'dnf':\n        case 'yum':\n          checkCommand = `rpm -q ${manager.packageName}`;\n          expectedOutput = /^pl-/m;\n          break;\n        case 'pacman':\n          checkCommand = `pacman -Q ${manager.packageName}`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'zypper':\n          checkCommand = `zypper search --installed-only ${manager.packageName}`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'snap':\n          checkCommand = `snap list ${manager.packageName}`;\n          expectedOutput = /swi-prolog/i;\n          break;\n        case 'flatpak':\n          checkCommand = `flatpak list | grep ${manager.packageName}`;\n          expectedOutput = /org\\.swi_prolog\\.SWI-Prolog/i;\n          break;\n        default:\n          resolve({ installed: false });\n          return;\n      }\n\n      const [command, ...args] = checkCommand.split(' ');\n      if (typeof command !== 'string' || !command.trim()) {\n        resolve({ installed: false });\n        return;\n      }\n      // Ensure command is a non-empty string and all args are strings\n      const safeCommand: string = command.trim();\n      const safeArgs: string[] = args.filter((arg): arg is string => typeof arg === 'string');\n      if (!safeCommand) {\n        resolve({ installed: false });\n        return;\n      }\n      const process: import('child_process').ChildProcess = spawn(safeCommand, safeArgs, {\n        stdio: ['ignore', 'pipe', 'pipe'],\n        timeout: 10000,\n      });\n\n      let output = '';\n      process.stdout?.on('data', data => {\n        output += data.toString();\n      });\n\n      process.on('close', code => {\n        if (code === 0 && expectedOutput.test(output)) {\n          // Try to extract version\n          const versionMatch = output.match(/(\\d+\\.\\d+(?:\\.\\d+)?)/);\n          if (versionMatch && versionMatch[1]) {\n            resolve({\n              installed: true,\n              version: versionMatch[1],\n            });\n          } else {\n            resolve({\n              installed: true\n            });\n          }\n        } else {\n          resolve({ installed: false });\n        }\n      });\n\n      process.on('error', () => {\n        resolve({ installed: false });\n      });\n\n      setTimeout(() => {\n        process.kill();\n        resolve({ installed: false });\n      }, 10000);\n    });\n  }\n\n  /**\n   * Install SWI-Prolog using the best available package manager\n   */\n  public async installSwiplProlog(preferredManager?: string): Promise<InstallationResult> {\n    const availableManagers = await this.detectAvailableManagers();\n\n    if (availableManagers.length === 0) {\n      return {\n        success: false,\n        packageManager: 'none',\n        command: '',\n        error: 'No package managers found on this system',\n      };\n    }\n\n    // Use preferred manager if specified and available\n    let selectedManager = availableManagers[0]; // Default to highest priority\n    if (preferredManager) {\n      const preferred = availableManagers.find(m => m.name === preferredManager);\n      if (preferred) {\n        selectedManager = preferred;\n      }\n    }\n\n    if (!selectedManager) {\n      return {\n        success: false,\n        packageManager: 'none',\n        command: '',\n        error: 'No valid package manager selected',\n      };\n    }\n    return await this.executeInstallation(selectedManager);\n  }\n\n  /**\n   * Execute the installation using a specific package manager\n   */\n  private async executeInstallation(manager: PackageManagerInfo): Promise<InstallationResult> {\n    return new Promise(resolve => {\n      const [command, ...args] = manager.installCommand.split(' ');\n      if (!command) {\n        throw new Error('Install command must be a string');\n      }\n      // Check if command requires elevation\n      const requiresElevation =\n        manager.installCommand.includes('sudo') ||\n        (this.platform === 'windows' && ['choco', 'winget'].includes(manager.name));\n\n      const process: import('child_process').ChildProcess = spawn(command, args, {\n        stdio: ['pipe', 'pipe', 'pipe'],\n        timeout: 300000, // 5 minutes timeout for installation\n        shell: true, // Use shell for complex commands\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      process.stdout?.on('data', data => {\n        stdout += data.toString();\n      });\n\n      process.stderr?.on('data', data => {\n        stderr += data.toString();\n      });\n\n      process.on('close', code => {\n        const success = code === 0;\n        if (success) {\n          resolve({\n            success,\n            packageManager: manager.name,\n            command: manager.installCommand,\n            output: stdout,\n            requiresElevation,\n          });\n        } else {\n          resolve({\n            success,\n            packageManager: manager.name,\n            command: manager.installCommand,\n            output: stdout,\n            error: stderr,\n            requiresElevation,\n          });\n        }\n      });\n\n      process.on('error', error => {\n        resolve({\n          success: false,\n          packageManager: manager.name,\n          command: manager.installCommand,\n          error: error.message,\n          requiresElevation,\n        });\n      });\n\n      // Timeout fallback\n      setTimeout(() => {\n        process.kill();\n        resolve({\n          success: false,\n          packageManager: manager.name,\n          command: manager.installCommand,\n          error: 'Installation timed out after 5 minutes',\n          requiresElevation,\n        });\n      }, 300000);\n    });\n  }\n\n  /**\n   * Show installation dialog with package manager options\n   */\n  public async showInstallationDialog(): Promise<InstallationResult | null> {\n    const availableManagers = await this.detectAvailableManagers();\n\n    if (availableManagers.length === 0) {\n      vscode.window.showErrorMessage(\n        'No package managers found on your system. Please install SWI-Prolog manually from https://www.swi-prolog.org/download/stable'\n      );\n      return null;\n    }\n\n    // Create quick pick items\n    const items = availableManagers.map(manager => ({\n      label: manager.displayName,\n      description: `Install using: ${manager.installCommand}`,\n      detail: manager.version ? `Version: ${manager.version}` : 'Available',\n      manager: manager.name,\n    }));\n\n    items.push({\n      label: 'Manual Installation',\n      description: 'Download and install manually',\n      detail: 'Opens the official SWI-Prolog download page',\n      manager: 'manual',\n    });\n\n    const selected = await vscode.window.showQuickPick(items, {\n      title: 'Install SWI-Prolog',\n      placeHolder: 'Choose an installation method',\n    });\n\n    if (!selected) {\n      return null; // User cancelled\n    }\n\n    if (selected.manager === 'manual') {\n      vscode.env.openExternal(vscode.Uri.parse('https://www.swi-prolog.org/download/stable'));\n      return null;\n    }\n\n    // Show confirmation dialog\n    const manager = availableManagers.find(m => m.name === selected.manager)!;\n    const requiresElevation =\n      manager.installCommand.includes('sudo') ||\n      (this.platform === 'windows' && ['choco', 'winget'].includes(manager.name));\n\n    let confirmMessage = `Install SWI-Prolog using ${manager.displayName}?\\n\\nCommand: ${manager.installCommand}`;\n    if (requiresElevation) {\n      confirmMessage += '\\n\\nNote: This command requires administrator/sudo privileges.';\n    }\n\n    const confirm = await vscode.window.showInformationMessage(\n      confirmMessage,\n      { modal: true },\n      'Install',\n      'Cancel'\n    );\n\n    if (confirm !== 'Install') {\n      return null;\n    }\n\n    // Show progress and execute installation\n    return vscode.window.withProgress(\n      {\n        location: vscode.ProgressLocation.Notification,\n        title: `Installing SWI-Prolog via ${manager.displayName}`,\n        cancellable: false,\n      },\n      async progress => {\n        progress.report({ message: 'Starting installation...' });\n\n        const result = await this.executeInstallation(manager);\n\n        if (result.success) {\n          progress.report({ message: 'Installation completed successfully!' });\n          vscode.window.showInformationMessage(\n            `SWI-Prolog has been installed successfully using ${manager.displayName}!`\n          );\n        } else {\n          let errorMessage = `Installation failed using ${manager.displayName}.`;\n          if (result.requiresElevation) {\n            errorMessage += ' Make sure you have administrator/sudo privileges.';\n          }\n          if (result.error) {\n            errorMessage += `\\n\\nError: ${result.error}`;\n          }\n\n          vscode.window.showErrorMessage(errorMessage);\n        }\n\n        return result;\n      }\n    );\n  }\n\n  /**\n   * Get installation suggestions for the current platform\n   */\n  public async getInstallationSuggestions(): Promise<string[]> {\n    const availableManagers = await this.detectAvailableManagers();\n    const suggestions: string[] = [];\n\n    suggestions.push('Install SWI-Prolog using one of these methods:');\n    suggestions.push('');\n\n    if (availableManagers.length > 0) {\n      suggestions.push('Available package managers:');\n      availableManagers.forEach(manager => {\n        suggestions.push(`  • ${manager.displayName}: ${manager.installCommand}`);\n      });\n      suggestions.push('');\n    }\n\n    // Add manual installation option\n    suggestions.push('Manual installation:');\n    suggestions.push('  • Download from: https://www.swi-prolog.org/download/stable');\n\n    // Add platform-specific notes\n    switch (this.platform) {\n      case 'windows':\n        suggestions.push('');\n        suggestions.push('Windows notes:');\n        suggestions.push('  • Run terminal as Administrator for package manager installations');\n        suggestions.push('  • Add SWI-Prolog to PATH after manual installation');\n        break;\n      case 'macos':\n        suggestions.push('');\n        suggestions.push('macOS notes:');\n        suggestions.push('  • Homebrew is recommended for easy installation and updates');\n        suggestions.push('  • For Apple Silicon Macs, ensure you use the arm64 version');\n        break;\n      case 'linux':\n        suggestions.push('');\n        suggestions.push('Linux notes:');\n        suggestions.push('  • Package names may vary between distributions');\n        suggestions.push('  • Some distributions use \"pl\" instead of \"swi-prolog\"');\n        break;\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * Clear detection cache (useful for testing or after system changes)\n   */\n  public clearCache(): void {\n    this.detectionCache.clear();\n  }\n\n  /**\n   * Get all configured package managers for the current platform\n   */\n  public getConfiguredManagers(): PackageManagerInfo[] {\n    return Array.from(this.availableManagers.values());\n  }\n\n  /**\n   * Get platform-specific package manager recommendations\n   */\n  public getRecommendedManagers(): string[] {\n    switch (this.platform) {\n      case 'windows':\n        return ['winget', 'chocolatey', 'scoop'];\n      case 'macos':\n        return ['homebrew', 'macports'];\n      case 'linux':\n        return ['apt', 'dnf', 'yum', 'pacman', 'zypper', 'snap', 'flatpak'];\n      default:\n        return [];\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologActivityProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":292,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":292,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":369,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":369,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'allQueries' is assigned a value but never used.","line":503,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":503,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":607,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":607,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from 'path';\nimport * as vscode from 'vscode';\nimport { ErrorHandler, PrologError } from './errorHandler';\nimport { InstallationChecker } from './installationChecker';\nimport { QueryHistoryManager } from './queryHistoryManager';\nimport { QueryNotificationManager } from './queryNotificationManager';\n\nexport interface PrologTreeItem {\n  id: string;\n  label: string;\n  description?: string;\n  tooltip?: string;\n  iconPath?: vscode.ThemeIcon | { light: vscode.Uri; dark: vscode.Uri };\n  contextValue?: string;\n  command?: vscode.Command;\n  children?: PrologTreeItem[];\n}\n\nexport class PrologActivityProvider implements vscode.TreeDataProvider<PrologTreeItem> {\n  private _onDidChangeTreeData: vscode.EventEmitter<PrologTreeItem | undefined | null | void> =\n    new vscode.EventEmitter<PrologTreeItem | undefined | null | void>();\n  readonly onDidChangeTreeData: vscode.Event<PrologTreeItem | undefined | null | void> =\n    this._onDidChangeTreeData.event;\n\n  private installationChecker: InstallationChecker;\n  private queryHistory: QueryHistoryManager;\n  private queryNotificationManager: QueryNotificationManager;\n  private errorHandler: ErrorHandler;\n  private recentErrors: PrologError[] = [];\n  private isInstalled: boolean = false;\n  private currentVersion: string = 'Unknown';\n\n  /**\n   * Add an error to the recent errors list\n   */\n  addError(error: PrologError): void {\n    // Add to the beginning of the array\n    this.recentErrors.unshift(error);\n\n    // Keep only the last 10 errors\n    if (this.recentErrors.length > 10) {\n      this.recentErrors = this.recentErrors.slice(0, 10);\n    }\n\n    // Refresh the tree view\n    this.refresh();\n  }\n\n  constructor(private context: vscode.ExtensionContext) {\n    this.installationChecker = InstallationChecker.getInstance();\n    this.queryHistory = QueryHistoryManager.getInstance();\n    this.queryNotificationManager = new QueryNotificationManager();\n    this.errorHandler = new ErrorHandler();\n    this.checkInstallation();\n  }\n\n  private async checkInstallation(): Promise<void> {\n    try {\n      const status = await this.installationChecker.checkSwiplInstallation();\n      this.isInstalled = status.isInstalled;\n      this.currentVersion = status.version || 'Unknown';\n      this.refresh();\n    } catch (error) {\n      console.error('Error checking Prolog installation:', error);\n    }\n  }\n\n  refresh(): void {\n    this._onDidChangeTreeData.fire();\n  }\n\n  getTreeItem(element: PrologTreeItem): vscode.TreeItem {\n    const treeItem = new vscode.TreeItem(\n      element.label,\n      element.children\n        ? vscode.TreeItemCollapsibleState.Expanded\n        : vscode.TreeItemCollapsibleState.None\n    );\n\n    treeItem.id = element.id;\n    if (typeof element.description !== 'undefined') {\n      treeItem.description = element.description;\n    }\n    treeItem.tooltip = element.tooltip;\n    if (typeof element.iconPath !== 'undefined') {\n      treeItem.iconPath = element.iconPath;\n    }\n    if (typeof element.contextValue !== 'undefined') {\n      treeItem.contextValue = element.contextValue;\n    }\n    if (typeof element.command !== 'undefined') {\n      treeItem.command = element.command;\n    }\n\n    return treeItem;\n  }\n\n  async getChildren(element?: PrologTreeItem): Promise<PrologTreeItem[]> {\n    if (!element) {\n      return this.getRootItems();\n    }\n\n    switch (element.id) {\n      case 'installation':\n        return this.getInstallationItems();\n      case 'queries':\n        return this.getQueryItems();\n      case 'files':\n        return this.getFileItems();\n      case 'debugging':\n        return this.getDebuggingItems();\n      case 'settings':\n        return this.getSettingsItems();\n      case 'notifications-errors':\n        return this.getNotificationsAndErrorsItems();\n      default:\n        return element.children || [];\n    }\n  }\n\n  private getRootItems(): PrologTreeItem[] {\n    return [\n      {\n        id: 'installation',\n        label: 'Installation',\n        description: this.isInstalled ? `✓ ${this.currentVersion}` : '✗ Not Found',\n        tooltip: this.isInstalled\n          ? `SWI-Prolog ${this.currentVersion} is installed`\n          : 'SWI-Prolog not found',\n        iconPath: new vscode.ThemeIcon(this.isInstalled ? 'check' : 'error'),\n        contextValue: 'installation',\n        children: [],\n      },\n      {\n        id: 'queries',\n        label: 'Query History',\n        description: 'Recent queries',\n        tooltip: 'View and manage recent Prolog queries',\n        iconPath: new vscode.ThemeIcon('history'),\n        contextValue: 'queries',\n        children: [],\n      },\n      {\n        id: 'files',\n        label: 'Prolog Files',\n        description: 'Workspace files',\n        tooltip: 'Prolog files in current workspace',\n        iconPath: new vscode.ThemeIcon('files'),\n        contextValue: 'files',\n        children: [],\n      },\n      {\n        id: 'debugging',\n        label: 'Debug Sessions',\n        description: 'Active sessions',\n        tooltip: 'Manage debug sessions',\n        iconPath: new vscode.ThemeIcon('debug'),\n        contextValue: 'debugging',\n        children: [],\n      },\n      {\n        id: 'settings',\n        label: 'Settings',\n        description: 'Configuration',\n        tooltip: 'Extension settings and configuration',\n        iconPath: new vscode.ThemeIcon('settings-gear'),\n        contextValue: 'settings',\n        children: [],\n      },\n      {\n        id: 'notifications-errors',\n        label: 'Notifications & Errors',\n        description: 'System status',\n        tooltip: 'View notifications and errors',\n        iconPath: new vscode.ThemeIcon('bell'),\n        contextValue: 'notifications-errors',\n        children: [],\n      },\n    ];\n  }\n\n  private getInstallationItems(): PrologTreeItem[] {\n    const items: PrologTreeItem[] = [];\n\n    if (this.isInstalled) {\n      items.push({\n        id: 'installation-status',\n        label: `SWI-Prolog ${this.currentVersion}`,\n        description: 'Installed',\n        tooltip: 'SWI-Prolog is properly installed',\n        iconPath: new vscode.ThemeIcon('check'),\n        contextValue: 'installation-status',\n      });\n\n      items.push({\n        id: 'test-installation',\n        label: 'Test Installation',\n        tooltip: 'Test SWI-Prolog installation',\n        iconPath: new vscode.ThemeIcon('beaker'),\n        contextValue: 'test-installation',\n        command: {\n          command: 'prolog.testInstallation',\n          title: 'Test Installation',\n        },\n      });\n    } else {\n      items.push({\n        id: 'installation-missing',\n        label: 'SWI-Prolog Not Found',\n        description: 'Click to install',\n        tooltip: 'SWI-Prolog is not installed or not found in PATH',\n        iconPath: new vscode.ThemeIcon('error'),\n        contextValue: 'installation-missing',\n        command: {\n          command: 'prolog.setupWizard',\n          title: 'Setup Wizard',\n        },\n      });\n\n      items.push({\n        id: 'auto-detect',\n        label: 'Auto-Detect Path',\n        tooltip: 'Automatically detect SWI-Prolog installation',\n        iconPath: new vscode.ThemeIcon('search'),\n        contextValue: 'auto-detect',\n        command: {\n          command: 'prolog.autoDetectPath',\n          title: 'Auto-Detect Path',\n        },\n      });\n    }\n\n    items.push({\n      id: 'refresh-installation',\n      label: 'Refresh Status',\n      tooltip: 'Refresh installation status',\n      iconPath: new vscode.ThemeIcon('refresh'),\n      contextValue: 'refresh-installation',\n      command: {\n        command: 'prolog.refreshInstallation',\n        title: 'Refresh Installation',\n      },\n    });\n\n    return items;\n  }\n\n  private async getQueryItems(): Promise<PrologTreeItem[]> {\n    const items: PrologTreeItem[] = [];\n\n    try {\n      const history = await this.queryHistory.getRecentQueries(10);\n\n      if (history.length === 0) {\n        items.push({\n          id: 'no-queries',\n          label: 'No recent queries',\n          description: 'Execute a query to see history',\n          tooltip: 'Query history will appear here',\n          iconPath: new vscode.ThemeIcon('info'),\n          contextValue: 'no-queries',\n        });\n      } else {\n        history.forEach((query, index) => {\n          items.push({\n            id: `query-${index}`,\n            label: query.query.length > 30 ? `${query.query.substring(0, 30)}...` : query.query,\n            description: query.success ? '✓' : '✗',\n            tooltip: `Query: ${query.query}\\nResult: ${query.success ? 'Success' : 'Failed'}\\nTime: ${new Date(query.timestamp).toLocaleString()}`,\n            iconPath: new vscode.ThemeIcon(query.success ? 'check' : 'error'),\n            contextValue: 'query-item',\n            command: {\n              command: 'prolog.rerunQuery',\n              title: 'Rerun Query',\n              arguments: [query.query],\n            },\n          });\n        });\n      }\n\n      items.push({\n        id: 'clear-history',\n        label: 'Clear History',\n        tooltip: 'Clear query history',\n        iconPath: new vscode.ThemeIcon('trash'),\n        contextValue: 'clear-history',\n        command: {\n          command: 'prolog.clearQueryHistory',\n          title: 'Clear History',\n        },\n      });\n    } catch (_error) {\n      items.push({\n        id: 'query-error',\n        label: 'Error loading history',\n        description: 'Click to retry',\n        tooltip: 'Failed to load query history',\n        iconPath: new vscode.ThemeIcon('error'),\n        contextValue: 'query-error',\n      });\n    }\n\n    return items;\n  }\n\n  private async getFileItems(): Promise<PrologTreeItem[]> {\n    const items: PrologTreeItem[] = [];\n\n    if (!vscode.workspace.workspaceFolders) {\n      items.push({\n        id: 'no-workspace',\n        label: 'No workspace open',\n        description: 'Open a folder to see Prolog files',\n        tooltip: 'Open a workspace to see Prolog files',\n        iconPath: new vscode.ThemeIcon('folder'),\n        contextValue: 'no-workspace',\n      });\n      return items;\n    }\n\n    try {\n      const prologFiles = await vscode.workspace.findFiles(\n        '**/*.{pl,pro,prolog,plt,ecl}',\n        '**/node_modules/**',\n        50\n      );\n\n      if (prologFiles.length === 0) {\n        items.push({\n          id: 'no-files',\n          label: 'No Prolog files found',\n          description: 'Create a .pl file to get started',\n          tooltip: 'No Prolog files found in workspace',\n          iconPath: new vscode.ThemeIcon('file'),\n          contextValue: 'no-files',\n        });\n      } else {\n        prologFiles.forEach((file, index) => {\n          const fileName = path.basename(file.fsPath);\n          const relativePath = vscode.workspace.asRelativePath(file);\n\n          items.push({\n            id: `file-${index}`,\n            label: fileName,\n            description: path.dirname(relativePath),\n            tooltip: `Open ${relativePath}`,\n            iconPath: new vscode.ThemeIcon('file-code'),\n            contextValue: 'prolog-file',\n            command: {\n              command: 'vscode.open',\n              title: 'Open File',\n              arguments: [file],\n            },\n          });\n        });\n      }\n\n      items.push({\n        id: 'new-file',\n        label: 'New Prolog File',\n        tooltip: 'Create a new Prolog file',\n        iconPath: new vscode.ThemeIcon('file-add'),\n        contextValue: 'new-file',\n        command: {\n          command: 'prolog.newFile',\n          title: 'New Prolog File',\n        },\n      });\n    } catch (_error) {\n      items.push({\n        id: 'file-error',\n        label: 'Error loading files',\n        description: 'Click to retry',\n        tooltip: 'Failed to load Prolog files',\n        iconPath: new vscode.ThemeIcon('error'),\n        contextValue: 'file-error',\n      });\n    }\n\n    return items;\n  }\n\n  private getDebuggingItems(): PrologTreeItem[] {\n    const items: PrologTreeItem[] = [];\n\n    // Check if there are active debug sessions\n    const activeSessions = vscode.debug.activeDebugSession;\n\n    if (activeSessions && activeSessions.type === 'prolog') {\n      items.push({\n        id: 'active-session',\n        label: `Active: ${activeSessions.name}`,\n        description: 'Running',\n        tooltip: 'Active Prolog debug session',\n        iconPath: new vscode.ThemeIcon('debug-alt'),\n        contextValue: 'active-session',\n      });\n\n      items.push({\n        id: 'stop-debugging',\n        label: 'Stop Debugging',\n        tooltip: 'Stop current debug session',\n        iconPath: new vscode.ThemeIcon('debug-stop'),\n        contextValue: 'stop-debugging',\n        command: {\n          command: 'workbench.action.debug.stop',\n          title: 'Stop Debugging',\n        },\n      });\n    } else {\n      items.push({\n        id: 'no-sessions',\n        label: 'No active sessions',\n        description: 'Start debugging to see sessions',\n        tooltip: 'No active debug sessions',\n        iconPath: new vscode.ThemeIcon('debug'),\n        contextValue: 'no-sessions',\n      });\n\n      items.push({\n        id: 'start-debugging',\n        label: 'Start Debugging',\n        tooltip: 'Start a new debug session',\n        iconPath: new vscode.ThemeIcon('debug-start'),\n        contextValue: 'start-debugging',\n        command: {\n          command: 'workbench.action.debug.start',\n          title: 'Start Debugging',\n        },\n      });\n    }\n\n    items.push({\n      id: 'debug-config',\n      label: 'Debug Configuration',\n      tooltip: 'Configure debug settings',\n      iconPath: new vscode.ThemeIcon('gear'),\n      contextValue: 'debug-config',\n      command: {\n        command: 'workbench.action.debug.configure',\n        title: 'Configure Debug',\n      },\n    });\n\n    return items;\n  }\n\n  private getSettingsItems(): PrologTreeItem[] {\n    return [\n      {\n        id: 'open-settings',\n        label: 'Open Settings',\n        tooltip: 'Open Prolog extension settings',\n        iconPath: new vscode.ThemeIcon('settings'),\n        contextValue: 'open-settings',\n        command: {\n          command: 'prolog.openSettings',\n          title: 'Open Settings',\n        },\n      },\n      {\n        id: 'setup-wizard',\n        label: 'Setup Wizard',\n        tooltip: 'Run the setup wizard',\n        iconPath: new vscode.ThemeIcon('wand'),\n        contextValue: 'setup-wizard',\n        command: {\n          command: 'prolog.setupWizard',\n          title: 'Setup Wizard',\n        },\n      },\n      {\n        id: 'view-logs',\n        label: 'View Logs',\n        tooltip: 'View extension logs',\n        iconPath: new vscode.ThemeIcon('output'),\n        contextValue: 'view-logs',\n        command: {\n          command: 'prolog.viewLogs',\n          title: 'View Logs',\n        },\n      },\n      {\n        id: 'report-issue',\n        label: 'Report Issue',\n        tooltip: 'Report an issue on GitHub',\n        iconPath: new vscode.ThemeIcon('bug'),\n        contextValue: 'report-issue',\n        command: {\n          command: 'prolog.reportIssue',\n          title: 'Report Issue',\n        },\n      },\n    ];\n  }\n\n  private getNotificationsAndErrorsItems(): PrologTreeItem[] {\n    const items: PrologTreeItem[] = [];\n\n    // Get active queries from QueryNotificationManager\n    try {\n      const activeQueries = this.queryNotificationManager.getActiveQueries();\n      const allQueries = this.queryNotificationManager.getAllQueries();\n\n      // Add active queries section\n      if (activeQueries.length > 0) {\n        items.push({\n          id: 'active-queries-header',\n          label: 'Active Queries',\n          description: `${activeQueries.length} running`,\n          tooltip: 'Currently running queries',\n          iconPath: new vscode.ThemeIcon('sync'),\n          contextValue: 'active-queries-header',\n          children: [],\n        });\n\n        activeQueries.forEach((query, index) => {\n          const statusIcon =\n            query.status === 'running' ? 'sync' : query.status === 'pending' ? 'clock' : 'question';\n          const statusText = query.status.charAt(0).toUpperCase() + query.status.slice(1);\n\n          items.push({\n            id: `active-query-${query.id}`,\n            label: query.message || `Query ${index + 1}`,\n            description: statusText,\n            tooltip: `Status: ${statusText}\\nStart time: ${new Date(query.startTime).toLocaleString()}`,\n            iconPath: new vscode.ThemeIcon(statusIcon),\n            contextValue: 'active-query',\n          });\n        });\n      } else {\n        items.push({\n          id: 'no-active-queries',\n          label: 'No Active Queries',\n          description: 'All queries completed',\n          tooltip: 'No currently running queries',\n          iconPath: new vscode.ThemeIcon('check'),\n          contextValue: 'no-active-queries',\n        });\n      }\n\n      // Add recent errors section\n      items.push({\n        id: 'recent-errors-header',\n        label: 'Recent Errors',\n        description: `${this.recentErrors.length} errors`,\n        tooltip: 'Recently encountered errors',\n        iconPath: new vscode.ThemeIcon('error'),\n        contextValue: 'recent-errors-header',\n        children: [],\n      });\n\n      if (this.recentErrors.length > 0) {\n        // Show only the most recent 5 errors\n        const errorsToShow = this.recentErrors.slice(0, 5);\n        errorsToShow.forEach((error, index) => {\n          const severityIcon =\n            error.severity === 'error'\n              ? 'error'\n              : error.severity === 'warning'\n                ? 'warning'\n                : 'info';\n          const severityText = error.severity.charAt(0).toUpperCase() + error.severity.slice(1);\n\n          items.push({\n            id: `recent-error-${index}`,\n            label:\n              error.message.length > 50 ? `${error.message.substring(0, 50)}...` : error.message,\n            description: severityText,\n            tooltip: `Severity: ${severityText}\\nType: ${error.type}\\nCode: ${error.code}\\nMessage: ${error.message}`,\n            iconPath: new vscode.ThemeIcon(severityIcon),\n            contextValue: 'recent-error',\n          });\n        });\n\n        if (this.recentErrors.length > 5) {\n          items.push({\n            id: 'more-errors',\n            label: 'More errors...',\n            description: `${this.recentErrors.length - 5} more`,\n            tooltip: `View all ${this.recentErrors.length} errors`,\n            iconPath: new vscode.ThemeIcon('more'),\n            contextValue: 'more-errors',\n          });\n        }\n      } else {\n        items.push({\n          id: 'no-recent-errors',\n          label: 'No Recent Errors',\n          description: 'All clear',\n          tooltip: 'No recent errors to display',\n          iconPath: new vscode.ThemeIcon('check'),\n          contextValue: 'no-recent-errors',\n        });\n      }\n\n      // Add statistics\n      const stats = this.queryNotificationManager.getStatistics();\n      items.push({\n        id: 'notification-stats',\n        label: 'Statistics',\n        description: `${stats.total} total`,\n        tooltip: `Total: ${stats.total}\\nPending: ${stats.pending}\\nRunning: ${stats.running}\\nCompleted: ${stats.completed}\\nErrors: ${stats.error}\\nCancelled: ${stats.cancelled}\\nTimeouts: ${stats.timeout}`,\n        iconPath: new vscode.ThemeIcon('graph'),\n        contextValue: 'notification-stats',\n      });\n    } catch (_error) {\n      items.push({\n        id: 'notifications-error',\n        label: 'Error loading notifications',\n        description: 'Click to retry',\n        tooltip: 'Failed to load notifications and errors',\n        iconPath: new vscode.ThemeIcon('error'),\n        contextValue: 'notifications-error',\n      });\n    }\n\n    return items;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologDashboardProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_scriptUri' is assigned a value but never used.","line":189,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":189,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { InstallationChecker } from './installationChecker';\nimport { QueryHistoryManager } from './queryHistoryManager';\n\nexport class PrologDashboardProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'prologDashboard';\n  private _view?: vscode.WebviewView;\n  private installationChecker: InstallationChecker;\n  private queryHistory: QueryHistoryManager;\n\n  constructor(private readonly _extensionUri: vscode.Uri) {\n    this.installationChecker = InstallationChecker.getInstance();\n    this.queryHistory = QueryHistoryManager.getInstance();\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    this._view = webviewView;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._extensionUri],\n    };\n\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    // Handle messages from the webview\n    webviewView.webview.onDidReceiveMessage(\n      async message => {\n        switch (message.type) {\n          case 'executeQuery':\n            await this._executeQuery(message.query);\n            break;\n          case 'openSettings':\n            vscode.commands.executeCommand('prolog.openSettings');\n            break;\n          case 'setupWizard':\n            vscode.commands.executeCommand('prolog.setupWizard');\n            break;\n          case 'refreshStatus':\n            await this._refreshStatus();\n            break;\n          case 'openFile':\n            if (message.filePath) {\n              const uri = vscode.Uri.file(message.filePath);\n              await vscode.window.showTextDocument(uri);\n            }\n            break;\n          case 'newFile':\n            await this._createNewFile();\n            break;\n          case 'clearHistory':\n            await this._clearHistory();\n            break;\n        }\n      },\n      undefined,\n      []\n    );\n\n    // Initial data load\n    this._refreshStatus();\n  }\n\n  private async _executeQuery(query: string): Promise<void> {\n    try {\n      await vscode.commands.executeCommand('prolog.lsp.executeQuery', query);\n      this._refreshStatus(); // Refresh to update history\n    } catch (error) {\n      vscode.window.showErrorMessage(`Failed to execute query: ${error}`);\n    }\n  }\n\n  private async _refreshStatus(): Promise<void> {\n    if (!this._view) {\n      return;\n    }\n\n    try {\n      // Get installation status\n      const installationStatus = await this.installationChecker.checkSwiplInstallation();\n\n      // Get recent queries\n      const recentQueries = await this.queryHistory.getRecentQueries(5);\n\n      // Get workspace Prolog files\n      const prologFiles = vscode.workspace.workspaceFolders\n        ? await vscode.workspace.findFiles('**/*.{pl,pro,prolog,plt,ecl}', '**/node_modules/**', 10)\n        : [];\n\n      // Get debug session status\n      const debugSession = vscode.debug.activeDebugSession;\n      const isDebugging = debugSession && debugSession.type === 'prolog';\n\n      const statusData = {\n        installation: {\n          isInstalled: installationStatus.isInstalled,\n          version: installationStatus.version || 'Unknown',\n          path: installationStatus.path || 'Not found',\n          issues: installationStatus.issues || [],\n        },\n        queries: recentQueries.map(q => ({\n          query: q.query,\n          success: q.success,\n          timestamp: q.timestamp,\n          result: q.result,\n        })),\n        files: prologFiles.map(file => ({\n          name: path.basename(file.fsPath),\n          path: file.fsPath,\n          relativePath: vscode.workspace.asRelativePath(file),\n        })),\n        debugging: {\n          isActive: isDebugging,\n          sessionName: debugSession?.name || null,\n        },\n        workspace: {\n          hasWorkspace: !!vscode.workspace.workspaceFolders,\n          workspaceName: vscode.workspace.workspaceFolders?.[0]?.name || null,\n        },\n      };\n\n      this._view.webview.postMessage({\n        type: 'statusUpdate',\n        data: statusData,\n      });\n    } catch (error) {\n      console.error('Error refreshing dashboard status:', error);\n      this._view.webview.postMessage({\n        type: 'error',\n        message: `Failed to refresh status: ${error}`,\n      });\n    }\n  }\n\n  private async _createNewFile(): Promise<void> {\n    try {\n      const fileName = await vscode.window.showInputBox({\n        prompt: 'Enter the name for the new Prolog file',\n        value: 'untitled.pl',\n        validateInput: value => {\n          if (!value) {\n            return 'File name cannot be empty';\n          }\n          if (!value.match(/\\.(pl|pro|prolog|plt|ecl)$/)) {\n            return 'File must have a Prolog extension (.pl, .pro, .prolog, .plt, .ecl)';\n          }\n          return null;\n        },\n      });\n\n      if (fileName) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (workspaceFolder) {\n          const filePath = vscode.Uri.joinPath(workspaceFolder.uri, fileName);\n          const edit = new vscode.WorkspaceEdit();\n          edit.createFile(filePath, { ignoreIfExists: false });\n          await vscode.workspace.applyEdit(edit);\n          await vscode.window.showTextDocument(filePath);\n        } else {\n          // Create untitled document\n          const doc = await vscode.workspace.openTextDocument({\n            language: 'prolog',\n            content: `% ${fileName}\\n% New Prolog file\\n\\n`,\n          });\n          await vscode.window.showTextDocument(doc);\n        }\n      }\n    } catch (error) {\n      vscode.window.showErrorMessage(`Failed to create new file: ${error}`);\n    }\n  }\n\n  private async _clearHistory(): Promise<void> {\n    try {\n      await this.queryHistory.clearHistory();\n      vscode.window.showInformationMessage('Query history cleared');\n      this._refreshStatus();\n    } catch (error) {\n      vscode.window.showErrorMessage(`Failed to clear history: ${error}`);\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview): string {\n    const _scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'dashboard.js')\n    );\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'dashboard.css')\n    );\n\n    return `<!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <link href=\"${styleUri}\" rel=\"stylesheet\">\n            <title>Prolog Dashboard</title>\n        </head>\n        <body>\n            <div class=\"dashboard-container\">\n                <div class=\"dashboard-header\">\n                    <h1>🔧 Prolog Toolkit</h1>\n                    <button id=\"refreshBtn\" class=\"action-btn\" title=\"Refresh Status\">🔄</button>\n                </div>\n\n                <!-- Installation Status -->\n                <div class=\"dashboard-section\">\n                    <h2>📦 Installation Status</h2>\n                    <div id=\"installationStatus\" class=\"status-card\">\n                        <div class=\"status-indicator loading\">\n                            <span class=\"status-icon\">🔄</span>\n                            <span class=\"status-text\">Checking installation...</span>\n                        </div>\n                        <div class=\"status-details\" id=\"installationDetails\" style=\"display: none;\">\n                            <div class=\"detail-item\">\n                                <strong>Version:</strong> <span id=\"installationVersion\">-</span>\n                            </div>\n                            <div class=\"detail-item\">\n                                <strong>Path:</strong> <span id=\"installationPath\">-</span>\n                            </div>\n                        </div>\n                        <div class=\"status-actions\">\n                            <button class=\"action-btn\" id=\"setupWizardBtn\">🧙‍♂️ Setup Wizard</button>\n                            <button class=\"action-btn\" id=\"openSettingsBtn\">⚙️ Settings</button>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Quick Query -->\n                <div class=\"dashboard-section\">\n                    <h2>⚡ Quick Query</h2>\n                    <div class=\"query-card\">\n                        <div class=\"query-input-container\">\n                            <input type=\"text\" id=\"queryInput\" placeholder=\"Enter Prolog query (e.g., member(X, [1,2,3]))\" />\n                            <button id=\"executeBtn\" class=\"action-btn primary\">▶️ Execute</button>\n                        </div>\n                        <div class=\"query-examples\">\n                            <span class=\"example-label\">Examples:</span>\n                            <button class=\"example-btn\" data-query=\"member(X, [1,2,3])\">member(X, [1,2,3])</button>\n                            <button class=\"example-btn\" data-query=\"append([1,2], [3,4], X)\">append([1,2], [3,4], X)</button>\n                            <button class=\"example-btn\" data-query=\"length([a,b,c], X)\">length([a,b,c], X)</button>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Recent Queries -->\n                <div class=\"dashboard-section\">\n                    <h2>📜 Recent Queries</h2>\n                    <div id=\"recentQueries\" class=\"queries-card\">\n                        <div class=\"loading-message\">Loading recent queries...</div>\n                    </div>\n                    <div class=\"queries-actions\">\n                        <button class=\"action-btn\" id=\"clearHistoryBtn\">🗑️ Clear History</button>\n                    </div>\n                </div>\n\n                <!-- Workspace Files -->\n                <div class=\"dashboard-section\">\n                    <h2>📁 Prolog Files</h2>\n                    <div id=\"workspaceFiles\" class=\"files-card\">\n                        <div class=\"loading-message\">Loading workspace files...</div>\n                    </div>\n                    <div class=\"files-actions\">\n                        <button class=\"action-btn\" id=\"newFileBtn\">➕ New File</button>\n                    </div>\n                </div>\n\n                <!-- Debug Status -->\n                <div class=\"dashboard-section\">\n                    <h2>🐛 Debug Status</h2>\n                    <div id=\"debugStatus\" class=\"debug-card\">\n                        <div class=\"status-indicator\">\n                            <span class=\"status-icon\">⏸️</span>\n                            <span class=\"status-text\">No active debug session</span>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Quick Actions -->\n                <div class=\"dashboard-section\">\n                    <h2>🚀 Quick Actions</h2>\n                    <div class=\"actions-grid\">\n                        <button class=\"quick-action-btn\" onclick=\"vscode.postMessage({type: 'openSettings'})\">\n                            <span class=\"action-icon\">⚙️</span>\n                            <span class=\"action-label\">Settings</span>\n                        </button>\n                        <button class=\"quick-action-btn\" onclick=\"vscode.postMessage({type: 'setupWizard'})\">\n                            <span class=\"action-icon\">🧙‍♂️</span>\n                            <span class=\"action-label\">Setup</span>\n                        </button>\n                        <button class=\"quick-action-btn\" onclick=\"vscode.postMessage({type: 'newFile'})\">\n                            <span class=\"action-icon\">📄</span>\n                            <span class=\"action-label\">New File</span>\n                        </button>\n                        <button class=\"quick-action-btn\" onclick=\"window.open('https://github.com/mediaprophet/VSCode-Prolog-Toolkit')\">\n                            <span class=\"action-icon\">📚</span>\n                            <span class=\"action-label\">Docs</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n            <script>\n                const vscode = acquireVsCodeApi();\n                \n                // Event listeners\n                document.getElementById('refreshBtn').addEventListener('click', () => {\n                    vscode.postMessage({ type: 'refreshStatus' });\n                });\n\n                document.getElementById('executeBtn').addEventListener('click', () => {\n                    const query = document.getElementById('queryInput').value.trim();\n                    if (query) {\n                        vscode.postMessage({ type: 'executeQuery', query: query });\n                        document.getElementById('queryInput').value = '';\n                    }\n                });\n\n                document.getElementById('queryInput').addEventListener('keypress', (e) => {\n                    if (e.key === 'Enter') {\n                        document.getElementById('executeBtn').click();\n                    }\n                });\n\n                document.getElementById('setupWizardBtn').addEventListener('click', () => {\n                    vscode.postMessage({ type: 'setupWizard' });\n                });\n\n                document.getElementById('openSettingsBtn').addEventListener('click', () => {\n                    vscode.postMessage({ type: 'openSettings' });\n                });\n\n                document.getElementById('newFileBtn').addEventListener('click', () => {\n                    vscode.postMessage({ type: 'newFile' });\n                });\n\n                document.getElementById('clearHistoryBtn').addEventListener('click', () => {\n                    vscode.postMessage({ type: 'clearHistory' });\n                });\n\n                // Example query buttons\n                document.querySelectorAll('.example-btn').forEach(btn => {\n                    btn.addEventListener('click', () => {\n                        const query = btn.getAttribute('data-query');\n                        document.getElementById('queryInput').value = query;\n                    });\n                });\n\n                // Handle messages from extension\n                window.addEventListener('message', event => {\n                    const message = event.data;\n                    \n                    switch (message.type) {\n                        case 'statusUpdate':\n                            updateDashboard(message.data);\n                            break;\n                        case 'error':\n                            showError(message.message);\n                            break;\n                    }\n                });\n\n                function updateDashboard(data) {\n                    // Update installation status\n                    const installationStatus = document.getElementById('installationStatus');\n                    const statusIndicator = installationStatus.querySelector('.status-indicator');\n                    const statusDetails = document.getElementById('installationDetails');\n                    \n                    if (data.installation.isInstalled) {\n                        statusIndicator.className = 'status-indicator success';\n                        statusIndicator.innerHTML = '<span class=\"status-icon\">✅</span><span class=\"status-text\">SWI-Prolog Installed</span>';\n                        document.getElementById('installationVersion').textContent = data.installation.version;\n                        document.getElementById('installationPath').textContent = data.installation.path;\n                        statusDetails.style.display = 'block';\n                    } else {\n                        statusIndicator.className = 'status-indicator error';\n                        statusIndicator.innerHTML = '<span class=\"status-icon\">❌</span><span class=\"status-text\">SWI-Prolog Not Found</span>';\n                        statusDetails.style.display = 'none';\n                    }\n\n                    // Update recent queries\n                    const queriesContainer = document.getElementById('recentQueries');\n                    if (data.queries.length === 0) {\n                        queriesContainer.innerHTML = '<div class=\"empty-message\">No recent queries</div>';\n                    } else {\n                        queriesContainer.innerHTML = data.queries.map(query => \n                            '<div class=\"query-item\">' +\n                            '<div class=\"query-text\">' + escapeHtml(query.query) + '</div>' +\n                            '<div class=\"query-status ' + (query.success ? 'success' : 'error') + '\">' +\n                            (query.success ? '✅' : '❌') +\n                            '</div>' +\n                            '</div>'\n                        ).join('');\n                    }\n\n                    // Update workspace files\n                    const filesContainer = document.getElementById('workspaceFiles');\n                    if (!data.workspace.hasWorkspace) {\n                        filesContainer.innerHTML = '<div class=\"empty-message\">No workspace open</div>';\n                    } else if (data.files.length === 0) {\n                        filesContainer.innerHTML = '<div class=\"empty-message\">No Prolog files found</div>';\n                    } else {\n                        filesContainer.innerHTML = data.files.map(file => \n                            '<div class=\"file-item\" onclick=\"vscode.postMessage({type: 'openFile', filePath: '' + file.path + ''})\">' +\n                            '<span class=\"file-icon\">📄</span>' +\n                            '<span class=\"file-name\">' + escapeHtml(file.name) + '</span>' +\n                            '<span class=\"file-path\">' + escapeHtml(file.relativePath) + '</span>' +\n                            '</div>'\n                        ).join('');\n                    }\n\n                    // Update debug status\n                    const debugStatus = document.getElementById('debugStatus');\n                    const debugIndicator = debugStatus.querySelector('.status-indicator');\n                    if (data.debugging.isActive) {\n                        debugIndicator.innerHTML = '<span class=\"status-icon\">🐛</span><span class=\"status-text\">Debugging: ' + escapeHtml(data.debugging.sessionName) + '</span>';\n                    } else {\n                        debugIndicator.innerHTML = '<span class=\"status-icon\">⏸️</span><span class=\"status-text\">No active debug session</span>';\n                    }\n                }\n\n                function showError(message) {\n                    // Simple error display - could be enhanced with a proper notification system\n                    console.error('Dashboard error:', message);\n                }\n\n                function escapeHtml(text) {\n                    const div = document.createElement('div');\n                    div.textContent = text;\n                    return div.innerHTML;\n                }\n\n                // Request initial status\n                vscode.postMessage({ type: 'refreshStatus' });\n            </script>\n        </body>\n        </html>`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologDebugSession.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'args' is not defined.","line":204,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":204,"endColumn":55}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  DebugSession,\n  ErrorDestination,\n  OutputEvent,\n  InitializedEvent,\n  StackFrame,\n  Source,\n  Scope,\n  Thread,\n} from '@vscode/debugadapter';\nimport { DebugProtocol } from '@vscode/debugprotocol';\nimport { ITraceCmds, LaunchRequestArguments, PrologDebugger } from './prologDebugger';\nimport * as path from 'path';\nimport { spawn, SpawnOptions } from 'process-promises';\n\n// Extends the DebugSession class, providing the implementation for a Prolog debugger\nexport class PrologDebugSession extends DebugSession {\n  private static SCOPEREF = 1;\n  public static THREAD_ID = 100;\n  private _prologDebugger!: PrologDebugger;\n  private _runtimeExecutable!: string;\n  // private _runtimeArgs: string[];\n  private _startupQuery!: string;\n  private _startFile!: string;\n  private _cwd!: string;\n  private _stopOnEntry!: boolean;\n  private _traceCmds!: ITraceCmds;\n  private _currentVariables: DebugProtocol.Variable[] = [];\n  private _stackFrames: DebugProtocol.StackFrame[] = [];\n  private _debugging!: boolean;\n\n  public constructor() {\n    super();\n    this.setDebuggerColumnsStartAt1(true);\n    this.setDebuggerLinesStartAt1(true);\n    this.setDebuggerPathFormat('native');\n  }\n  // Implements the initialization logic for the debugger\n  protected override initializeRequest(\n    response: DebugProtocol.InitializeResponse,\n    _args: DebugProtocol.InitializeRequestArguments\n  ): void {\n    // Configure the response body with supported features and options\n    response.body = {\n      supportsConfigurationDoneRequest: true,\n      supportTerminateDebuggee: true,\n      supportsConditionalBreakpoints: true,\n      supportsHitConditionalBreakpoints: true,\n      supportsFunctionBreakpoints: true,\n      supportsEvaluateForHovers: true,\n      supportsExceptionOptions: true,\n      supportsExceptionInfoRequest: true,\n      // Define exception breakpoint filters with associated labels\n      exceptionBreakpointFilters: [\n        {\n          filter: 'Notice',\n          label: 'Notices',\n        },\n        {\n          filter: 'Warning',\n          label: 'Warnings',\n        },\n        {\n          filter: 'Error',\n          label: 'Errors',\n        },\n        {\n          filter: 'Exception',\n          label: 'Exceptions',\n        },\n        {\n          filter: '*',\n          label: 'Everything',\n          default: true,\n        },\n      ],\n    };\n    // Send the initialized response back to the client\n    this.sendResponse(response);\n  }\n  //Handles the 'attach' request from the debugger client\n  protected override attachRequest(\n    response: DebugProtocol.AttachResponse,\n    _args: DebugProtocol.AttachRequestArguments\n  ) {\n    // Send an error response indicating that attach requests are not supported\n    this.sendErrorResponse(response, new Error('Attach requests are not supported'));\n    // Shutdown the debugger session\n    this.shutdown();\n  }\n\n  // Adds a stack frame to the list of stack frames during debugging\n  public addStackFrame(frame: {\n    id: number;\n    level: number;\n    name: string;\n    file: string;\n    line: number;\n    column: number;\n  }) {\n    // Construct a new StackFrame object with information from the provided frame\n    if (frame.file && frame.name) {\n      this._stackFrames.unshift(\n        new StackFrame(\n          frame.id,\n          `(${frame.level})${frame.name}`,\n          new Source(\n            path.basename(frame.file), // Extract the base name of the file\n            frame.file\n          ),\n          this.convertDebuggerLineToClient(frame.line), // Convert debugger line to client line\n          this.convertDebuggerColumnToClient(frame.column) // Convert debugger column to client column\n        )\n      );\n    }\n  }\n\n  //Sets the current variables in the debugger session\n  public setCurrentVariables(vars: DebugProtocol.Variable[]) {\n    this._currentVariables = []; // Clear existing variables in _currentVariables array\n    // Pop elements from the provided vars array and push them into _currentVariables\n    while (vars.length > 0) {\n      const variable = vars.pop();\n      if (variable?.name) {\n        this._currentVariables.push({ ...variable, variablesReference: 0 });\n      }\n    }\n  }\n\n  // Handles the 'launch' request from the debugger client\n  protected override launchRequest(\n    response: DebugProtocol.LaunchResponse,\n    args: DebugProtocol.LaunchRequestArguments,\n    _request?: DebugProtocol.Request\n  ) {\n    const richArgs = args as LaunchRequestArguments; // Cast arguments to LaunchRequestArguments for access to specific properties\n    // Set various parameters from the launch arguments or use defaults\n    this._startupQuery = richArgs.startupQuery || 'start';\n    this._startFile = richArgs.program ? path.resolve(richArgs.program) : '';\n    this._cwd = richArgs.cwd;\n    this._runtimeExecutable = richArgs.runtimeExecutable || 'swipl';\n    // this._runtimeArgs = args.runtimeArgs || null;\n    this._stopOnEntry = typeof richArgs.stopOnEntry === 'boolean' ? richArgs.stopOnEntry : true;\n    this._traceCmds = richArgs.traceCmds || ({} as ITraceCmds);\n    this._prologDebugger = new PrologDebugger(richArgs, this); // Initialize the Prolog debugger\n    // Add listeners for breakpoint responses\n    this._prologDebugger.addListener(\n      'responseBreakpoints',\n      (bps: DebugProtocol.SetBreakpointsResponse) => {\n        this.sendResponse(bps);\n      }\n    );\n    this._prologDebugger.addListener(\n      'responseFunctionBreakpoints',\n      (fbps: DebugProtocol.SetFunctionBreakpointsResponse) => {\n        this.sendResponse(fbps);\n      }\n    );\n    this.sendResponse(response); // Send the launch response back to the client\n    this.sendEvent(new InitializedEvent()); // Send an 'Initialized' event to the client, indicating that the debugger is ready\n  }\n\n  // Handles the 'threads' request from the debugger client\n  protected override threadsRequest(response: DebugProtocol.ThreadsResponse): void {\n    // Configure the response body with information about the threads\n    response.body = {\n      threads: [new Thread(PrologDebugSession.THREAD_ID, 'thread 1')],\n    };\n    this.sendResponse(response); // Send the threads response back to the client\n  }\n\n  // Handles the 'setBreakpoints' request from the debugger client\n  protected override setBreakPointsRequest(\n    response: DebugProtocol.SetBreakpointsResponse,\n    args: DebugProtocol.SetBreakpointsArguments\n  ) {\n    // Check if the debugger is currently in a debugging session\n    if (this._debugging) {\n      // Display a message indicating that breakpoints set during debugging will take effect in the next debugging process\n      this.debugOutput(\n        'Breakpoints set during debugging would take effect in next debugging process.'\n      );\n      return; // Return without setting breakpoints during an active debugging session\n    }\n    this._prologDebugger.setBreakpoints(args, response); // Delegate the task of setting breakpoints to the Prolog debugger\n  }\n\n  // Handles the 'setExceptionBreakpoints' request from the debugger client\n  protected override setExceptionBreakPointsRequest(\n    response: DebugProtocol.SetExceptionBreakpointsResponse,\n    _args: DebugProtocol.SetExceptionBreakpointsArguments\n  ): void {\n    // Send a response back to the client without modifying exception breakpoints\n    this.sendResponse(response);\n  }\n\n  // Handles the 'setFunctionBreakpoints' request from the debugger client\n  protected override setFunctionBreakPointsRequest(\n    response: DebugProtocol.SetFunctionBreakpointsResponse,\n    _args: DebugProtocol.SetFunctionBreakpointsArguments\n  ): void {\n    // Delegate the task of setting function breakpoints to the Prolog debugger\n    if (this._prologDebugger) {\n      this._prologDebugger.setFunctionBreakpoints(args, response);\n    }\n  }\n\n  // Handles the 'configurationDone' request from the debugger client\n  protected override configurationDoneRequest(\n    response: DebugProtocol.ConfigurationDoneResponse,\n    _args: DebugProtocol.ConfigurationDoneArguments\n  ): void {\n    this.sendResponse(response); // Send a response back to the client\n    if (this._prologDebugger) {\n      this._prologDebugger.startup(`${this._startupQuery}`); // Start the Prolog debugger and execute startup commands\n      // If not stopping on entry, continue the execution\n      if (!this._stopOnEntry && this._traceCmds?.continue?.[1]) {\n        this._prologDebugger.query(`cmd:${this._traceCmds.continue[1]}\\n`);\n      }\n      if (this._traceCmds?.stepinto?.[1]) {\n        this._prologDebugger.query(`cmd:${this._traceCmds.stepinto[1]}\\n`); // Issue a step into command to initiate the debugging process\n      }\n    }\n    this._debugging = true; // Set the debugging flag to true\n  }\n\n  // Evaluates the expression to retrieve the value of a variable\n  private evaluateExpression(exp: string) {\n    const vars = this._currentVariables;\n    // Iterate through the current variables\n    for (let i = 0; i < vars.length; i++) {\n      // Check if the variable name matches the provided expression\n      if (vars[i]?.name === exp) {\n        return vars[i]?.value; // Return the value of the variable\n      }\n    }\n    return null; // Return null if the variable is not found\n  }\n\n  // Handles the 'evaluate' request from the debugger client\n  protected override evaluateRequest(\n    response: DebugProtocol.EvaluateResponse,\n    args: DebugProtocol.EvaluateArguments\n  ): void {\n    const val = this.evaluateExpression(args.expression); // Evaluate the expression to retrieve the value\n    // If a value is found, send the result back to the client\n    if (val) {\n      response.body = {\n        result: val,\n        variablesReference: 0,\n      };\n      this.sendResponse(response);\n      return;\n    } else {\n      if (args.context === 'repl') {\n        const vars = this._currentVariables;\n        let exp = args.expression.trim();\n        if (exp.startsWith(':')) {\n          // Workaround for input from stdin\n          const input = 'input' + args.expression;\n          this._prologDebugger.query(input + '\\n');\n        } else {\n          // Replace variable references in the expression with their values\n          for (let i = 0; i < vars.length; i++) {\n            if (vars[i]?.name && vars[i]?.value) {\n              const re = new RegExp('\\\\b' + vars[i].name + '\\\\b', 'g');\n              exp = exp.replace(re, vars[i].value || '');\n            }\n          }\n          this.debugOutput(args.expression);\n          this.evaluate(exp); // Evaluate the modified expression\n        }\n        response.body = { result: '', variablesReference: 0 };\n      }\n      this.sendResponse(response); // Send the response back to the client\n      return;\n    }\n  }\n\n  // Handles the 'stackTrace' request from the debugger client\n  protected override stackTraceRequest(\n    response: DebugProtocol.StackTraceResponse,\n    _args: DebugProtocol.StackTraceArguments\n  ): void {\n    // Configure the response body with information about the stack frames\n    response.body = {\n      stackFrames: this._stackFrames,\n    };\n    this.sendResponse(response); // Send the stack trace response back to the client\n  }\n\n  // Handles the 'variables' request from the debugger client\n  protected override variablesRequest(\n    response: DebugProtocol.VariablesResponse,\n    _args: DebugProtocol.VariablesArguments\n  ): void {\n    const variables = new Array<DebugProtocol.Variable>();\n    // Copy variables from _currentVariables to the response\n    for (let i = 0; i < this._currentVariables.length; i++) {\n      const variable = this._currentVariables[i];\n      if (variable) {\n        variables.push(variable);\n      }\n    }\n    // Configure the response body with information about the variables\n    response.body = {\n      variables: variables,\n    };\n    this.sendResponse(response); // Send the variables response back to the client\n  }\n\n  //Handles the 'scopes' request from the debugger client\n  protected override scopesRequest(\n    response: DebugProtocol.ScopesResponse,\n    _args: DebugProtocol.ScopesArguments\n  ): void {\n    const scopes = new Array<Scope>();\n    scopes.push(new Scope('Local', PrologDebugSession.SCOPEREF++, false)); // Add a Local scope to the response\n    // Configure the response body with information about the scopes\n    response.body = {\n      scopes: scopes,\n    };\n    this.sendResponse(response); // Send the scopes response back to the client\n  }\n\n  // Handles the 'continue' request from the debugger client\n  protected override continueRequest(\n    response: DebugProtocol.ContinueResponse,\n    _args: DebugProtocol.ContinueArguments\n  ): void {\n    if (this._prologDebugger && this._traceCmds?.continue?.[1]) {\n      this._prologDebugger.query(`cmd:${this._traceCmds.continue[1]}\\n`); // Send a continue command to the Prolog debugger\n    }\n    this.sendResponse(response); // Send the continue response back to the client\n  }\n\n  // Handles the 'next' request from the debugger client\n  protected override nextRequest(\n    response: DebugProtocol.NextResponse,\n    _args: DebugProtocol.NextArguments\n  ): void {\n    if (this._prologDebugger && this._traceCmds?.stepover?.[1]) {\n      this._prologDebugger.query(`cmd:${this._traceCmds.stepover[1]}\\n`); // Send a step-over command to the Prolog debugger\n    }\n    this.sendResponse(response); // Send the next response back to the client\n  }\n\n  // Handles the 'stepIn' request from the debugger client\n  protected override stepInRequest(\n    response: DebugProtocol.StepInResponse,\n    _args: DebugProtocol.StepInArguments\n  ): void {\n    if (this._prologDebugger && this._traceCmds?.stepinto?.[1]) {\n      this._prologDebugger.query(`cmd:${this._traceCmds.stepinto[1]}\\n`); // Send a step-into command to the Prolog debugger\n    }\n    this.sendResponse(response); // Send the step-in response back to the client\n  }\n\n  // Handles the 'stepOut' request from the debugger client\n  protected override stepOutRequest(\n    response: DebugProtocol.StepOutResponse,\n    _args: DebugProtocol.StepOutArguments\n  ): void {\n    if (this._prologDebugger && this._traceCmds?.stepout?.[1]) {\n      this._prologDebugger.query(`cmd:${this._traceCmds.stepout[1]}\\n`); // Send a step-out command to the Prolog debugger\n    }\n    this.sendResponse(response); // Send the step-out response back to the client\n  }\n\n  // Handles the 'disconnect' request from the debugger client\n  protected override disconnectRequest(\n    response: DebugProtocol.DisconnectResponse,\n    _args: DebugProtocol.DisconnectArguments\n  ): void {\n    this._debugging = false; // Mark the end of the debugging session\n    if (this._prologDebugger) {\n      if (this._prologDebugger) {\n        this._prologDebugger.dispose(); // Dispose of the Prolog debugger\n      }\n    }\n    this.shutdown(); // Shutdown the debugger\n    this.sendResponse(response); // Send the disconnect response back to the client\n  }\n\n  // Handles the 'restart' request from the debugger client\n  protected override restartRequest(\n    response: DebugProtocol.RestartResponse,\n    _args: DebugProtocol.RestartArguments\n  ): void {\n    this._debugging = false; // Mark the end of the debugging session\n    this._prologDebugger.dispose(); // Dispose of the Prolog debugger\n    this.shutdown(); // Shutdown the debugger\n    this.sendResponse(response); // Send the restart response back to the client\n  }\n  // Sends an error response back to the debugger client\n  protected override sendErrorResponse(\n    response: DebugProtocol.Response,\n    error: Error,\n    dest?: ErrorDestination\n  ): void;\n\n  // Sends an error response back to the debugger client\n  protected override sendErrorResponse(\n    response: DebugProtocol.Response,\n    codeOrMessage: number | DebugProtocol.Message,\n    format?: string,\n    variables?: any,\n    dest?: ErrorDestination\n  ): void;\n\n  // Sends an error response back to the debugger client\n  protected override sendErrorResponse(response: DebugProtocol.Response) {\n    // Check if the second argument is an instance of Error\n    if (arguments[1] instanceof Error) {\n      // Extract error information from the second and third arguments\n      const error = arguments[1] as Error & {\n        code?: number | string;\n        errno?: number;\n      };\n      const dest = arguments[2] as ErrorDestination;\n      // Determine the error code\n      let code: number;\n      if (typeof error.code === 'number') {\n        code = error.code;\n      } else if (typeof error.errno === 'number') {\n        code = error.errno;\n      } else {\n        // Default to 0 if no valid code is found\n        code = 0;\n      }\n      super.sendErrorResponse(response, code, error.message, dest); // Forward the error response to the superclass method\n    } else {\n      // If the second argument is not an instance of Error, forward the response as is\n      super.sendErrorResponse(response, arguments[1], arguments[2], arguments[3], arguments[4]);\n    }\n  }\n\n  // Sends a debug output event with the specified message to the debugger client\n  public debugOutput(msg: string) {\n    // Send a debug output event with the specified message\n    this.sendEvent(new OutputEvent(msg));\n  }\n\n  // Evaluates the specified Prolog expression by spawning a new process\n  private evaluate(expression: string) {\n    // Get the runtime executable, program arguments, and input for the Prolog process\n    const exec = this._runtimeExecutable;\n    const args = ['-q', `${this._startFile}`];\n    const input = `\n    call((${expression})).\n    halt.\n    `;\n    // Configure spawn options with the current working directory\n    const spawnOptions: SpawnOptions = {\n      cwd: this._cwd,\n    };\n    // Spawn a new process for Prolog execution\n    spawn(exec, args, spawnOptions)\n      // If the process has a valid PID, write input to its stdin and end the input stream\n      .on('process', (proc: any) => {\n        if (proc.pid) {\n          proc.stdin.write(input);\n          proc.stdin.end();\n        }\n      })\n      .on('stdout', (data: any) => {\n        // Handle standard output by sending it as debug output\n        this.debugOutput('\\n' + data);\n      })\n      .on('stderr', (err: any) => {\n        // Handle standard error by sending it as debug output\n        this.debugOutput('\\n' + err);\n      })\n      .catch((err: any) => {\n        // Handle any errors by sending the error message as debug output\n        this.debugOutput(err.message);\n      });\n  }\n}\n\nDebugSession.run(PrologDebugSession); //start of the Prolog debug session\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologDebugger.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StackFrame' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Source' is defined but never used.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'basename' is defined but never used.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resolve' is defined but never used.","line":13,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":27},{"ruleId":"no-redeclare","severity":2,"message":"'ITraceCmds' is already defined.","line":38,"column":18,"nodeType":"Identifier","messageId":"redeclared","endLine":38,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":125,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":125,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pp' is assigned a value but never used.","line":244,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":244,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\nimport * as fs from 'fs';\nimport { spawn } from 'process-promises';\nimport { DebugProtocol } from '@vscode/debugprotocol';\nimport { PrologDebugSession } from './prologDebugSession';\nimport {\n  StoppedEvent,\n  StackFrame,\n  Source,\n  OutputEvent,\n  TerminatedEvent,\n} from '@vscode/debugadapter';\nimport { basename, resolve } from 'path';\nimport jsesc from 'jsesc';\nimport { InstallationGuide } from './installationGuide';\nimport { commands, window } from 'vscode';\nimport { PlatformUtils } from '../utils/platformUtils';\n\nexport interface ITraceCmds {\n  continue: string[2];\n  stepover: string[2];\n  stepinto: string[2];\n  stepout: string[2];\n}\nexport interface LaunchRequestArguments extends DebugProtocol.LaunchRequestArguments {\n  program?: string;\n  args?: string[];\n  cwd: string;\n  runtimeExecutable?: string;\n  runtimeArgs?: string[];\n  env?: { [key: string]: string };\n  startupQuery?: string;\n  stopOnEntry?: boolean;\n  terminalDebuggerPort?: number;\n  console?: string;\n  traceCmds?: ITraceCmds;\n}\nexport interface ITraceCmds {\n  Run: string[];\n  Stepin: string[];\n  Stepover: string[];\n  Stop: string[];\n}\n\nexport interface IBreakPoint {\n  sourceFile: string;\n  line: number;\n  id?: number;\n}\n\ninterface ISourceLineLocations {\n  [sourceFile: string]: number[];\n}\n// Define PrologDebugger class\nexport class PrologDebugger extends EventEmitter {\n  private _prologProc: any = null;\n  // private _traceCmds: ITraceCmds;\n  private _breakpoints: IBreakPoint[] = [];\n  private _launchRequestArguments: LaunchRequestArguments;\n  private _debugSession: PrologDebugSession;\n  private _bpResponse!: DebugProtocol.SetBreakpointsResponse;\n  private _fbpResponse!: DebugProtocol.SetFunctionBreakpointsResponse;\n  private _soureLineLocations: ISourceLineLocations;\n\n  // private _client: Net.Socket = null;\n\n  constructor(launchRequestArguments: LaunchRequestArguments, debugSession: PrologDebugSession) {\n    super();\n    this._launchRequestArguments = launchRequestArguments;\n    this._debugSession = debugSession;\n    this._soureLineLocations = {};\n    // this._client = client || null;\n    this.createPrologProc();\n\n    console.log('prolog debugger constructed');\n  }\n\n  // Helper function to retrieve source line locations\n  private getSourceLineLocations(source: string) {\n    // If line locations for this source file are already cached, return\n    if (this._soureLineLocations[source]) {\n      return;\n    }\n    // Read the content of the source file and split it into lines\n    const lines = fs.readFileSync(source).toString().split('\\n');\n    // Calculate the length of each line (including the newline character)\n    const lengths = lines.map(line => {\n      return line.length + 1;\n    });\n    lengths.unshift(0); // Add a starting index of 0 to the lengths array\n    // Accumulate the lengths to get the character position for each line\n    for (let i = 1; i < lengths.length; i++) {\n      lengths[i] += lengths[i - 1];\n    }\n    this._soureLineLocations[source] = lengths; // Cache the line locations for the source file\n  }\n\n  // Helper function to convert startChar to line and column\n  private fromStartCharToLineChar(source: string, startChar: number) {\n    this.getSourceLineLocations(source); // Ensure that line locations for the source file are available\n    let i = 0;\n    for (\n      ;\n      this._soureLineLocations[source]?.[i] !== undefined &&\n      this._soureLineLocations[source][i] < startChar;\n      i++\n    ); // Find the line index where the given character position is located\n    // Calculate the line number and column offset for the character position\n    return {\n      file: source,\n      line: i + 1,\n      startChar: startChar - (this._soureLineLocations[source]?.[i] ?? 0),\n    };\n  }\n  //Handles the output received from the Prolog debugger, parsing and processing relevant information.\n  private handleOutput(data: string) {\n    let resObj;\n    try {\n      // Attempt to parse the output data as JSON\n      resObj = JSON.parse(data);\n      // Check if the parsed object has a \"response\" key\n      if (Object.keys(resObj)[0] !== 'response') {\n        return;\n      }\n    } catch (error: unknown) {\n      return; // Exit if there is an error during JSON parsing\n    }\n    // Determine the type of response based on the first key in the \"response\" object\n    switch (Object.keys(resObj.response)[0]) {\n      // Process breakpoints response\n      case 'breakpoints':\n        if (this._bpResponse) {\n          this._bpResponse.body = {\n            breakpoints: resObj.response.breakpoints.map((b: any) => {\n              b.source = { path: b.source };\n              return b;\n            }),\n          };\n          this.emit('responseBreakpoints', this._bpResponse);\n        }\n        return;\n      // Process function breakpoints response\n      case 'functionbps':\n        if (this._fbpResponse) {\n          this._fbpResponse.body = {\n            breakpoints: resObj.response.functionbps,\n          };\n          this.emit('responseFunctionBreakpoints', this._fbpResponse);\n        }\n        return;\n      // Process frame response\n      case 'frame': {\n        const frame = resObj.response.frame;\n        if (frame) {\n          this._debugSession.addStackFrame(frame);\n          this._debugSession.sendEvent(\n            new StoppedEvent(frame.name || 'unknown', PrologDebugSession.THREAD_ID)\n          );\n        }\n        return;\n      }\n      // Process variables response\n      case 'variables':\n        this._debugSession.setCurrentVariables(resObj.response.variables);\n        return;\n\n      default:\n        break;\n    }\n  }\n\n  // Send a query to Prolog process\n  public query(goal: string) {\n    // Check if the goal is not an empty line\n    if (!/^\\n$/.test(goal)) {\n      goal = goal.replace(/\\n+/g, '\\n'); // Replace multiple consecutive newlines with a single newline\n      const from = goal.indexOf(':'); // Find the index of the colon in the goal\n      // If no colon is found, exit the function\n      if (from < 0) {\n        return;\n      }\n      // Write the Prolog query (substring after the colon) to the Prolog process stdin\n      if (this._prologProc?.stdin) {\n        this._prologProc.stdin.write(goal.substring(from + 1));\n      }\n    }\n  }\n\n  // Kill the Prolog process\n  private killPrologProc() {\n    if (this._prologProc && typeof this._prologProc.kill === 'function') {\n      this._prologProc.kill();\n    }\n  }\n\n  // Filter off unwanted output data\n  private filterOffOutput(data: string): boolean {\n    // Predefined regular expressions to filter off specific types of output\n    const regs = [\n      /^$/, // Empty line\n      /^TermToBeEvaluated/, // Output indicating a term to be evaluated\n      /^EvalTermAtom/, // Output indicating evaluation of a term atom\n      /^EvalVarNames/, // Output indicating evaluation of variable names\n      /^E =/, // Output indicating an assignment\n      /^true\\./, // Output indicating truth value 'true'\n    ];\n    // Iterate through the predefined regular expressions\n    for (let i = 0; i < regs.length; i++) {\n      // Test if the data matches any of the regular expressions\n      if (regs[i].test(data)) {\n        return true; // Return true if a match is found (filter off)\n      }\n    }\n    // Return false if no match is found (do not filter off)\n    return false;\n  }\n\n  // get the pid of the prolog processus\n  public get pid(): number {\n    return this._prologProc ? this._prologProc.pid : 0;\n  }\n\n  // Initialize Prolog debugger\n  public initPrologDebugger() {\n    // Obtain the directory path for the 'debugger' module and escape special characters\n    const dbg = jsesc(PlatformUtils.resolvePath(__dirname, 'debugger'));\n    console.log(dbg);\n    // Write Prolog commands to the process stdin for initialization\n    if (this._prologProc?.stdin) {\n      this._prologProc.stdin.write(`\n            use_module('${dbg}').\\n\n            prolog_debugger:load_source_file('${jsesc(\n              PlatformUtils.normalizePath(this._launchRequestArguments.program || '')\n            )}').\n              `);\n    }\n  }\n\n  // Create Prolog process\n  private async createPrologProc() {\n    console.log('path:' + this._launchRequestArguments.runtimeExecutable);\n    this.killPrologProc(); // Kill the existing Prolog process, if any\n    // Use 'spawn' to create a new Prolog process\n    const pp = await spawn(\n      PlatformUtils.normalizePath(this._launchRequestArguments.runtimeExecutable || 'swipl'),\n      (this._launchRequestArguments.runtimeArgs || []).concat('-q'),\n      { cwd: PlatformUtils.normalizePath(this._launchRequestArguments.cwd) }\n    )\n      .on('process', (proc: any) => {\n        // If the process has a valid PID, set it to the _prologProc and initialize the debugger\n        if (proc?.pid) {\n          this._prologProc = proc;\n          this.initPrologDebugger();\n        }\n      })\n      .on('stdout', (data: string) => {\n        //this._debugSession.debugOutput(\"\\n\" + data);\n        // Check if the data contains a \"response\" indicating debugger information\n        if (/\"response\":/.test(data)) {\n          this.handleOutput(data);\n        } else if (!this.filterOffOutput(data)) {\n          // If not a \"response\", output to the debug session (excluding filtered data)\n          this._debugSession.debugOutput('\\n' + data);\n        }\n      })\n      .on('stderr', (err: string) => {\n        // Output stderr data to the debug session\n        this._debugSession.sendEvent(new OutputEvent(err + '\\n', 'stderr'));\n      })\n      .on('exit', () => {\n        // Send termination event when the process exits\n        this._debugSession.sendEvent(new TerminatedEvent());\n      })\n      .then(result => {\n        // Log the exit code of the Prolog process\n        this._debugSession.debugOutput('\\nProlog process exit with code:' + result.exitCode);\n      })\n      .catch(async (error: unknown) => {\n        // Handle errors during process creation or execution\n        let message: string = '';\n        if (\n          error &&\n          typeof error === 'object' &&\n          'code' in error &&\n          (error as any).code === 'ENOENT'\n        ) {\n          message = `Cannot debug the prolog file. The Prolog executable '${\n            this._launchRequestArguments.runtimeExecutable || ''\n          }' was not found. Correct 'runtimeExecutable' setting in launch.json file.`;\n\n          // Show enhanced error message with installation guidance\n          const action = await window.showErrorMessage(\n            'SWI-Prolog executable not found. The debugger requires SWI-Prolog to debug your Prolog programs.',\n            'Install SWI-Prolog',\n            'Setup Wizard',\n            'Configure Path',\n            'Dismiss'\n          );\n\n          const installationGuide = InstallationGuide.getInstance();\n          switch (action) {\n            case 'Install SWI-Prolog':\n              await installationGuide.showInstallationGuideDialog();\n              break;\n            case 'Setup Wizard':\n              await commands.executeCommand('prolog.setupWizard');\n              break;\n            case 'Configure Path':\n              await commands.executeCommand(\n                'workbench.action.openSettings',\n                'prolog.executablePath'\n              );\n              break;\n            default:\n              break;\n          }\n        } else {\n          message =\n            error &&\n            typeof error === 'object' &&\n            'message' in error &&\n            typeof (error as any).message === 'string'\n              ? (error as any).message\n              : `Failed to run swipl using path: ${\n                  this._launchRequestArguments.runtimeExecutable || ''\n                }. Reason is unknown.`;\n        }\n        // Output the error message to the debug session and throw an error\n        this._debugSession.debugOutput('\\n' + message);\n        throw new Error(String(error));\n      });\n  }\n  //Sends Prolog consult command to the Prolog process.\n  private consult() {\n    const fileName = this._launchRequestArguments.program; // Get the file name from launch request arguments\n    const goals = \"['\" + (fileName || '') + \"'].\\n\"; // Prepare Prolog goals for consulting the specified file\n    if (this._prologProc?.stdin) {\n      this._prologProc.stdin.write(goals); // Write the goals to the Prolog process stdin\n    }\n  }\n\n  //Sets breakpoints for the Prolog debugger based on the specified arguments\n  public setBreakpoints(\n    breakpoints: DebugProtocol.SetBreakpointsArguments,\n    bpResponse: DebugProtocol.SetBreakpointsResponse\n  ) {\n    this._bpResponse = bpResponse; // Set the breakpoint response to be populated with results\n    const path = jsesc(PlatformUtils.toAbsolute(breakpoints.source?.path || '')); // Escape and resolve the path of the source file\n    // Map breakpoints to a serialized format for Prolog debugger\n    const bps = (breakpoints.breakpoints || []).map(bp => {\n      return JSON.stringify({\n        line: bp.line,\n        column: bp.column,\n        condition: bp.condition,\n        hitCondition: bp.hitCondition,\n      });\n    });\n    // Construct Prolog debugger command to set breakpoints\n    const cmd = `cmd:prolog_debugger:set_breakpoints('${path}', ${JSON.stringify(\n      bps.join(';')\n    )}).\\n`;\n    // Send the command to the Prolog process\n    this.query(cmd);\n  }\n\n  //Sets function breakpoints for the Prolog debugger based on the specified arguments\n  public setFunctionBreakpoints(\n    args: DebugProtocol.SetFunctionBreakpointsArguments,\n    response: DebugProtocol.SetFunctionBreakpointsResponse\n  ) {\n    // Extract predicate names from the function breakpoint arguments\n    const preds = (args.breakpoints || []).map(bp => {\n      return bp.name;\n    });\n    this._fbpResponse = response; // Set the function breakpoint response to be populated with results\n    const cmd = `cmd:prolog_debugger:spy_predicates([${preds}]).\\n`; // Construct Prolog debugger command to spy on predicates\n    this.query(cmd); // Send the command to the Prolog process\n  }\n\n  //Initiates the Prolog debugger startup with the specified goal\n  public startup(goal: string) {\n    const cmd = `cmd:prolog_debugger:startup(${goal}).\\n`; // Construct Prolog debugger command for startup with the specified goal\n    this.query(cmd); // Send the command to the Prolog process\n  }\n\n  //Disposes of the Prolog debugger instance by killing the Prolog process\n  public dispose(): void {\n    this.killPrologProc();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologFormatter.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":289,"column":25,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":289,"endColumn":26,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11702,11703],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11702,11702],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":289,"column":41,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":289,"endColumn":42,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11718,11719],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11718,11718],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":337,"column":34,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":337,"endColumn":35,"suggestions":[{"messageId":"removeEscape","fix":{"range":[13759,13760],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[13759,13759],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\}.","line":337,"column":36,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":337,"endColumn":37,"suggestions":[{"messageId":"removeEscape","fix":{"range":[13761,13762],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[13761,13761],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":337,"column":51,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":337,"endColumn":52,"suggestions":[{"messageId":"removeEscape","fix":{"range":[13776,13777],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[13776,13776],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\}.","line":337,"column":53,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":337,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[13778,13779],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[13778,13778],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  CancellationToken,\n  commands,\n  DocumentFormattingEditProvider,\n  DocumentRangeFormattingEditProvider,\n  FormattingOptions,\n  OutputChannel,\n  ProviderResult,\n  Range,\n  TextDocument,\n  TextEdit,\n  window,\n  workspace,\n  WorkspaceConfiguration,\n} from 'vscode';\nimport { ExecutableFinder } from '../utils/executableFinder';\nimport { PlatformUtils } from '../utils/platformUtils';\nimport { InstallationGuide } from './installationGuide';\n\nexport class PrologFormatter\n  implements DocumentRangeFormattingEditProvider, DocumentFormattingEditProvider {\n  private _section: WorkspaceConfiguration;\n  private _tabSize!: number;\n  private _insertSpaces!: boolean;\n  private _tabDistance!: number;\n  private _executable: string;\n  private _args: string[];\n  private _outputChannel: OutputChannel;\n  private _textEdits: TextEdit[] = [];\n  private _startChars!: number;\n\n  // Constructor for the PrologFormatter class\n  constructor() {\n    this._section = workspace.getConfiguration('prolog');\n    const execPath = this._section.get('executablePath', PlatformUtils.getDefaultExecutablePath());\n    this._executable = PlatformUtils.normalizePath(execPath);\n    this._args = [];\n    this._outputChannel = window.createOutputChannel('PrologFormatter');\n\n    // Initialize with better executable resolution\n    this.initializeExecutable();\n  }\n\n  /**\n   * Initialize executable with enhanced detection and permission checking\n   */\n  private async initializeExecutable(): Promise<void> {\n    const configuredPath = this._section.get<string>(\n      'executablePath',\n      PlatformUtils.getDefaultExecutablePath()\n    );\n\n    // Check if configured path exists and is executable\n    if (await PlatformUtils.pathExists(configuredPath)) {\n      if (await PlatformUtils.isExecutable(configuredPath)) {\n        this._executable = PlatformUtils.normalizePath(configuredPath);\n        return;\n      } else {\n        // Path exists but lacks execute permissions\n        const platform = PlatformUtils.getPlatform();\n        if (platform !== 'windows') {\n          window\n            .showWarningMessage(\n              `SWI-Prolog executable at '${configuredPath}' lacks execute permissions. Try: chmod +x \"${configuredPath}\"`,\n              'Fix Permissions'\n            )\n            .then(action => {\n              if (action === 'Fix Permissions') {\n                const terminal = window.createTerminal('Fix Prolog Permissions');\n                terminal.sendText(`chmod +x \"${configuredPath}\"`);\n                terminal.show();\n              }\n            });\n        }\n      }\n    }\n\n    // Try to find executable using comprehensive detection\n    const executableFinder = new ExecutableFinder();\n    const detectionResult = await executableFinder.findSwiplExecutable();\n\n    if (detectionResult.found && detectionResult.path) {\n      if (detectionResult.permissions?.executable) {\n        this._executable = detectionResult.path;\n\n        // Update configuration if we found a different path\n        if (detectionResult.path !== configuredPath) {\n          window\n            .showInformationMessage(\n              `Found SWI-Prolog at '${detectionResult.path}' via ${detectionResult.detectionMethod}. Update configuration?`,\n              'Yes',\n              'No'\n            )\n            .then(action => {\n              if (action === 'Yes') {\n                this._section.update('executablePath', detectionResult.path, true);\n              }\n            });\n        }\n      } else {\n        // Found executable but has permission issues\n        const platform = PlatformUtils.getPlatform();\n        if (platform !== 'windows') {\n          window\n            .showWarningMessage(\n              `Found SWI-Prolog at '${detectionResult.path}' but it lacks execute permissions. Try: chmod +x \"${detectionResult.path}\"`,\n              'Fix Permissions'\n            )\n            .then(action => {\n              if (action === 'Fix Permissions') {\n                const terminal = window.createTerminal('Fix Prolog Permissions');\n                terminal.sendText(`chmod +x \"${detectionResult.path}\"`);\n                terminal.show();\n              }\n            });\n        }\n        this._executable = detectionResult.path; // Use it anyway, will fail with better error\n      }\n    }\n  }\n\n  // Enhanced error handling for SWI-Prolog executable issues\n  private async handleExecutableError(error: any): Promise<void> {\n    if (error.code === 'ENOENT') {\n      const action = await window.showErrorMessage(\n        'SWI-Prolog executable not found. The formatter requires SWI-Prolog to format your code properly.',\n        'Install SWI-Prolog',\n        'Setup Wizard',\n        'Configure Path',\n        'Dismiss'\n      );\n\n      const installationGuide = InstallationGuide.getInstance();\n      switch (action) {\n        case 'Install SWI-Prolog':\n          await installationGuide.showInstallationGuideDialog();\n          break;\n        case 'Setup Wizard':\n          await commands.executeCommand('prolog.setupWizard');\n          break;\n        case 'Configure Path':\n          await commands.executeCommand('workbench.action.openSettings', 'prolog.executablePath');\n          break;\n        default:\n          break;\n      }\n    } else {\n      const message =\n        error.message || `Failed to run SWI-Prolog formatter using path: ${this._executable}`;\n      window.showErrorMessage(`Prolog formatting failed: ${message}`);\n    }\n  }\n  public provideDocumentRangeFormattingEdits(\n    doc: TextDocument,\n    range: Range,\n    _options: FormattingOptions,\n    _token: CancellationToken\n  ): ProviderResult<TextEdit[]> {\n    const docContent = doc.getText(range); // Get the content of the document;\n    const offset = doc.getText(new Range(doc.positionAt(0), range.start)).length;\n    let regexp = /%.*|\\/\\*[\\w\\W]*?\\*\\//gm; // Define regular expression for matching comments\n    const array = [...docContent.matchAll(regexp)]; // Match all occurrences of comments in the substring\n    // Replace comments with placeholder characters in the clause\n    let clauseComment = docContent;\n    array.forEach(Comment => {\n      clauseComment = clauseComment.replace(Comment[0], new Array(Comment[0].length + 1).join('☻'));\n    });\n    regexp = /^\\s*([a-z][a-zA-Z0-9_]*)/gm; // Define a regular expression for identifying Prolog clauses\n    const arrayStart = [...clauseComment.matchAll(regexp)]; // Match all occurrences of Prolog clauses in the document\n    regexp = /\\.\\s*$/gm; // Define a regular expression for identifying Prolog clauses end\n    const arrayEnd = [...clauseComment.matchAll(regexp)]; // Match all occurrences of Prolog clauses in the document\n    let min = 0;\n    const clausesArray = [];\n    for (let i = 0; i < arrayStart.length; i++) {\n      if (arrayStart[i] && typeof arrayStart[i].index === 'number' && arrayStart[i].index >= min) {\n        for (let j = 0; j < arrayEnd.length; j++) {\n          if (\n            arrayEnd[j] &&\n            typeof arrayEnd[j].index === 'number' &&\n            arrayEnd[j].index > (arrayStart[i]?.index ?? 0)\n          ) {\n            min = arrayEnd[j].index;\n            clausesArray.push([\n              (arrayStart[i]?.index ?? 0) + (typeof offset === 'number' ? offset : 0),\n              (arrayEnd[j]?.index ?? 0) + (typeof offset === 'number' ? offset : 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let result: TextEdit[] = [];\n    // Iterate over each matched clause and format it\n    clausesArray.forEach(clause => {\n      const clauseArray = this.getClauseString(doc, clause);\n      clauseArray[0] = this.formatClause(clauseArray[0]);\n      result = result.concat(TextEdit.replace(clauseArray[1], clauseArray[0]));\n    });\n\n    return result; // Return the formatted result\n  }\n\n  // Implementation of the provideDocumentFormattingEdits method required by DocumentFormattingEditProvider\n  public provideDocumentFormattingEdits(\n    document: TextDocument,\n    _options: FormattingOptions,\n    _token: CancellationToken\n  ): ProviderResult<TextEdit[]> {\n    const docContent = document.getText(); // Get the content of the document\n    let regexp = /%.*|\\/\\*[\\w\\W]*?\\*\\//gm; // Define regular expression for matching comments\n    const array = [...docContent.matchAll(regexp)]; // Match all occurrences of comments in the substring\n    // Replace comments with placeholder characters in the clause\n    let clauseComment = docContent;\n    array.forEach(Comment => {\n      clauseComment = clauseComment.replace(Comment[0], new Array(Comment[0].length + 1).join('☻'));\n    });\n    regexp = /^\\s*([a-z][a-zA-Z0-9_]*)/gm; // Define a regular expression for identifying Prolog clauses\n    const arrayStart = [...clauseComment.matchAll(regexp)]; // Match all occurrences of Prolog clauses in the document\n    regexp = /\\.\\s*$/gm; // Define a regular expression for identifying Prolog clauses end\n    const arrayEnd = [...clauseComment.matchAll(regexp)]; // Match all occurrences of Prolog clauses in the document\n    let min = 0;\n    const clausesArray = [];\n\n    for (let i = 0; i < arrayStart.length; i++) {\n      if (arrayStart[i] && typeof arrayStart[i].index === 'number' && arrayStart[i].index >= min) {\n        for (let j = 0; j < arrayEnd.length; j++) {\n          if (\n            arrayEnd[j] &&\n            typeof arrayEnd[j].index === 'number' &&\n            arrayEnd[j].index > (arrayStart[i]?.index ?? 0)\n          ) {\n            min = arrayEnd[j].index;\n            clausesArray.push([\n              arrayStart[i]?.index ?? 0,\n              arrayEnd[j]?.index ?? 0,\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let result: TextEdit[] = [];\n    // Iterate over each matched clause and format it\n    clausesArray.forEach(clause => {\n      const clauseArray = this.getClauseString(document, clause);\n      clauseArray[0] = this.formatClause(clauseArray[0]);\n      result = result.concat(TextEdit.replace(clauseArray[1], clauseArray[0]));\n    });\n\n    return result; // Return the formatted result\n  }\n\n  // Helper method to get the clause string and its range from the document\n  private getClauseString(doc: TextDocument, range: number[]): [string, Range] {\n    const docContent = doc.getText();\n    if (\n      Array.isArray(range) &&\n      range.length === 2 &&\n      typeof range[0] === 'number' &&\n      typeof range[1] === 'number'\n    ) {\n      let sub = docContent.substring(range[0], range[1] + 1); // Extract the substring from the starting position to the end of the document\n      const regexp = /^\\s+/gm; // Define regular expression for matching comments\n      const array = [...sub.matchAll(regexp)]; // Match all occurrences of starting spaces in the substring\n      if (array.length !== 0 && array[0]) {\n        sub = sub.slice(array[0][0].length);\n        return [\n          sub,\n          new Range(doc.positionAt(range[0] + array[0][0].length), doc.positionAt(range[1] + 1)),\n        ]; // Return the clause string and its range\n      }\n      return [sub, new Range(doc.positionAt(range[0]), doc.positionAt(range[1] + 1))]; // Return the clause string and its range\n    }\n    // fallback for invalid range\n    return ['', new Range(0, 0, 0, 0)];\n  }\n\n  // Helper method to format a Prolog clause\n  private formatClause(clause: string): string {\n    // COMMENT\n    let regexpComment = /%.*|\\/\\*[\\w\\W]*?\\*\\//gm;\n    let arrayComment = [...clause.matchAll(regexpComment)];\n    let clauseComment = clause;\n    // Replace comments with placeholder characters in the clause\n    arrayComment.forEach(Comment => {\n      clauseComment = clauseComment.replace(Comment[0], new Array(Comment[0].length).join('☻') + '♥');\n    });\n    // STRING\n    let regexpString = /\\\"((\\\\\\(?:[^\"])*\\\")/gm;\n    let arrayString = [...clauseComment.matchAll(regexpString)];\n    // Replace strings with placeholder characters in the clause\n    arrayString.forEach(String => {\n      clauseComment = clauseComment.replace(String[0], new Array(String[0].length + 1).join('☺'));\n    });\n    //EXTRACT HEAD\n    let regexpHead = /^\\s*[a-z][a-zA-Z0-9_]*(\\\\\\(?([^.]|\\.[^\\s])*?(:-|=>|-->)|[^(,\\n]*?(\\.\\s*?$)|\\\\\\(([^.]*|\\.[^\\s]*?)\\\\\\)\\s*\\.\\s*?)$/gm;\n    let arrayHead = [...clauseComment.matchAll(regexpHead)];\n    if (arrayHead.length === 0 || !arrayHead[0]) {\n      return clause; // Return original clause if no head found\n    }\n    let headComment = arrayHead[0][0];\n    let head = clause.slice(0, (arrayHead[0].index ?? 0) + arrayHead[0][0].length);\n    // Remove head from the clause and clauseComment\n    clause = clause.slice((arrayHead[0].index ?? 0) + arrayHead[0][0].length);\n    clauseComment = clauseComment.replace(headComment, '');\n    //CONDENSATE\n    let regexp = /(?<!\\sis|mod|div|rem|xor|rdiv|in)\\s(?!is\\s|:-|mod|div|rem|xor|rdiv|in)/gm;\n    let array = [...clauseComment.matchAll(regexp)];\n    let offset = 0;\n    // Remove unnecessary spaces in the clause and clauseComment\n    array.forEach(space => {\n      clause = [\n        clause.slice(0, space.index + offset),\n        clause.slice(space.index + space[0].length + offset),\n      ].join('');\n      clauseComment = [\n        clauseComment.slice(0, space.index + offset),\n        clauseComment.slice(space.index + space[0].length + offset),\n      ].join('');\n      offset -= space[0].length;\n    });\n    array = [...headComment.matchAll(regexp)];\n    offset = 0;\n    array.forEach(space => {\n      head = [\n        head.slice(0, space.index + offset),\n        head.slice(space.index + space[0].length + offset),\n      ].join('');\n      headComment = [\n        headComment.slice(0, space.index + offset),\n        headComment.slice(space.index + space[0].length + offset),\n      ].join('');\n      offset -= space[0].length;\n    });\n\n    //OPERATOR\n    let regexpOperator = /(?<=[\\]\\)\\}])ins|(?<=[\\]\\)\\}])in|[-*]?->|=>|\\?-|:-|=?:=|\\\\\\+|(?:<|=|@|@=||:|>:)<|(?:\\\\?)(?<![><#])=(?:\\.\\.|@=|=|\\\\=|)|@?>(?:=|>|)|:|\\+|-|\\\\\\/|\\/\\\\|#=|#>|#\\\\=|#<==>|#/gm;\n    let arrayOperator = [...clauseComment.matchAll(regexpOperator)];\n    offset = 0;\n    // Add spaces around operators in the clause and clauseComment\n    arrayOperator.forEach(operator => {\n      clause = [\n        clause.slice(0, operator.index + offset),\n        ' ' + operator[0] + ' ',\n        clause.slice(operator.index + operator[0].length + offset),\n      ].join('');\n      clauseComment = [\n        clauseComment.slice(0, operator.index + offset),\n        ' ' + operator[0] + ' ',\n        clauseComment.slice(operator.index + operator[0].length + offset),\n      ].join('');\n      offset += 2;\n    });\n    // Special case for '->'\n    regexp = /^(\\s*).*->\\s/gm;\n    array = [...clauseComment.matchAll(regexp)];\n    offset = 0;\n    // Split lines with '->' and add indentation\n    array.forEach(l => {\n      regexp = /->\\s/gm;\n      const array2 = [...l[0].matchAll(regexp)];\n      array2.forEach(f => {\n        const indentLength = l[1]?.length ?? 0;\n        clause = [\n          clause.slice(0, (l.index ?? 0) + (f.index ?? 0) + offset),\n          '->\\n' + new Array(indentLength + 2).join('\\t'),\n          clause.slice((l.index ?? 0) + (f.index ?? 0) + f[0].length + offset),\n        ].join('');\n        clauseComment = [\n          clauseComment.slice(0, (l.index ?? 0) + (f.index ?? 0) + offset),\n          '->\\n' + new Array(indentLength + 2).join('\\t'),\n          clauseComment.slice((l.index ?? 0) + (f.index ?? 0) + f[0].length + offset),\n        ].join('');\n        offset += indentLength + 1;\n      });\n    });\n    // Special case for ';'\n    regexp = /^(\\s*).*;(?=\\S)/gm;\n    array = [...clauseComment.matchAll(regexp)];\n    offset = 0;\n    array.forEach(l => {\n      regexp = /;/gm;\n      const array2 = [...l[0].matchAll(regexp)];\n      array2.forEach(f => {\n        const indentLength = l[1]?.length ?? 0;\n        clause = [\n          clause.slice(0, (l.index ?? 0) + (f.index ?? 0) + offset),\n          ';\\n' + new Array(indentLength + 1).join('\\t'),\n          clause.slice((l.index ?? 0) + (f.index ?? 0) + f[0].length + offset),\n        ].join('');\n        clauseComment = [\n          clauseComment.slice(0, (l.index ?? 0) + (f.index ?? 0) + offset),\n          ';\\n' + new Array(indentLength + 1).join('\\t'),\n          clauseComment.slice((l.index ?? 0) + (f.index ?? 0) + f[0].length + offset),\n        ].join('');\n        offset += indentLength + 1;\n      });\n    });\n    //NESTED\n    const result = this.formatNested(clause, clauseComment);\n    clause = result[0];\n    clauseComment = result[1];\n    //COMMAS\n    const formatConfig = this._section.get('format') as { addSpace?: boolean } | undefined;\n    if (formatConfig?.addSpace) {\n      regexp = /,(?!\\s)/gm;\n      array = [...clauseComment.matchAll(regexp)];\n      offset = 0;\n      // Add space after commas in the clause and clauseComment\n      array.forEach(comma => {\n        clause = [\n          clause.slice(0, comma.index + offset),\n          comma[0] + ' ',\n          clause.slice(comma.index + comma[0].length + offset),\n        ].join('');\n        clauseComment = [\n          clauseComment.slice(0, comma.index + offset),\n          comma[0] + ' ',\n          clauseComment.slice(comma.index + comma[0].length + offset),\n        ].join('');\n        offset += 1;\n      });\n\n      array = [...headComment.matchAll(regexp)];\n      offset = 0;\n      array.forEach(comma => {\n        head = [\n          head.slice(0, comma.index + offset),\n          comma[0] + ' ',\n          head.slice(comma.index + comma[0].length + offset),\n        ].join('');\n        headComment = [\n          headComment.slice(0, comma.index + offset),\n          comma[0] + ' ',\n          headComment.slice(comma.index + comma[0].length + offset),\n        ].join('');\n        offset += 1;\n      });\n    }\n    //REPLACE COMMENT\n    regexp = /^(\\s*).*(♥)/gm;\n    array = [...clauseComment.matchAll(regexp)];\n    let offset2 = 0;\n    array.forEach(Comment => {\n      regexp = /♥/gm;\n      const array2 = [...Comment[0].matchAll(regexp)];\n      // Add newline and indentation after comments in the clause\n      array2.forEach(h => {\n        clause = [\n          clause.slice(0, (Comment.index ?? 0) + (h.index ?? 0) + 1 + offset2),\n          '\\n' + new Array((Comment[1]?.length ?? 0) + 1).join('\\t'),\n          clause.slice((Comment.index ?? 0) + (h.index ?? 0) + 1 + offset2),\n        ].join('');\n        offset2 += 1 + (Comment[1]?.length ?? 0);\n      });\n    });\n\n    array = [...headComment.matchAll(regexp)];\n    let offset3 = 0;\n    array.forEach(Comment => {\n      regexp = /♥/gm;\n      const array2 = [...Comment[0].matchAll(regexp)];\n      // Add newline and indentation after comments in the clause\n      array2.forEach(h => {\n        head = [\n          head.slice(0, (Comment.index ?? 0) + (h.index ?? 0) + 1 + offset3),\n          '\\n' + new Array((Comment[1]?.length ?? 0) + 1).join(' '),\n          head.slice((Comment.index ?? 0) + (h.index ?? 0) + 1 + offset3),\n        ].join('');\n        offset3 += 1 + (Comment[1]?.length ?? 0);\n      });\n    });\n    if (clause !== '') {\n      head = head + '\\n\\t';\n      return head + clause; // Return the formatted clause\n    } else {\n      return head; // Return the formatted clause\n    }\n  }\n\n  // Helper method to format nested expressions within a Prolog clause\n  private formatNested(clause: string, clauseComment: string): [string, string] {\n    let regexpNested = new RegExp('\\\\[[^\\\\[\\\\]]*?\\\\]|\\\\([^()]*?\\\\)|{\\\\|[\\\\w\\\\W]*?\\\\|}', 'gm'); // Define regular expression to find 0 deep expressions\n    const array0deep = [...clauseComment.matchAll(regexpNested)]; // Find all occurrences of 0 deep expressions\n    regexpNested = new RegExp('.(?=},?)|,|{|\\\\[', 'gm'); // Define regular expression to find 0 deep expressions\n    const endLine = [...clauseComment.matchAll(regexpNested)]; // Find all end line\n\n    let deep = 1;\n    let offset = 0;\n    const arrayDeep = [];\n\n    // Deepness calculation per index\n    for (let i = 0; i < clauseComment.length; i++) {\n      const char = clauseComment[i];\n      if (char && ['{', '[', '('].includes(char)) {\n        deep = deep + 1;\n      }\n      if (char && ['}', ']', ')'].includes(char)) {\n        deep = deep - 1;\n      }\n      arrayDeep.push(deep);\n    }\n    // For each line end verify if it's inside a 0 deep element\n    for (let i = 0; i < endLine.length; i++) {\n      let verif = true;\n      for (let j = 0; j < array0deep.length; j++) {\n        const endLineIndex = endLine[i]?.index ?? 0;\n        const endLineLength = endLine[i]?.[0]?.length ?? 0;\n        const array0deepIndex = array0deep[j]?.index ?? 0;\n        const array0deepLength = array0deep[j]?.[0]?.length ?? 0;\n        \n        if (\n          endLineIndex >= array0deepIndex &&\n          endLineIndex + endLineLength < array0deepIndex + array0deepLength\n        ) {\n          verif = false;\n        }\n      }\n      // If verif add line breaks and indentation depending of the deepness\n      if (verif) {\n        const endLineIndex = endLine[i]?.index ?? 0;\n        const endLineLength = endLine[i]?.[0]?.length ?? 0;\n        deep = arrayDeep[endLineIndex] ?? 1;\n\n        clauseComment = [\n          clauseComment.slice(0, endLineIndex + endLineLength + offset),\n          '\\n' + new Array(deep + 1).join('\\t'),\n          clauseComment.slice(endLineIndex + endLineLength + offset),\n        ].join('');\n        clause = [\n          clause.slice(0, endLineIndex + endLineLength + offset),\n          '\\n' + new Array(deep + 1).join('\\t'),\n          clause.slice(endLineIndex + endLineLength + offset),\n        ].join('');\n\n        offset += 1 + deep;\n      }\n    }\n    return [clause, clauseComment]; // Return the formatted clause and clauseComment\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologLSPClient.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'line' is assigned a value but never used.","line":172,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  LanguageClient,\n  LanguageClientOptions,\n  ServerOptions,\n  TransportKind,\n  RevealOutputChannelOn,\n} from 'vscode-languageclient/node';\nimport { ExtensionContext, workspace, window } from 'vscode';\nimport * as path from 'path';\n\nexport class PrologLSPClient {\n  private client: LanguageClient | null = null;\n  private context: ExtensionContext;\n\n  constructor(context: ExtensionContext) {\n    this.context = context;\n  }\n\n  public async start(): Promise<void> {\n    if (this.client) {\n      return; // Already started\n    }\n\n    try {\n      // The server is implemented as a separate Node.js module\n      const serverModule = this.context.asAbsolutePath(\n        path.join('out', 'pub', 'features', 'prologLSPServer.js')\n      );\n\n      // The debug options for the server\n      const debugOptions = { execArgv: ['--nolazy', '--inspect=6009'] };\n\n      // If the extension is launched in debug mode then the debug server options are used\n      // Otherwise the run options are used\n      const serverOptions: ServerOptions = {\n        run: { module: serverModule, transport: TransportKind.ipc },\n        debug: {\n          module: serverModule,\n          transport: TransportKind.ipc,\n          options: debugOptions,\n        },\n      };\n\n      // Options to control the language client\n      const clientOptions: LanguageClientOptions = {\n        // Register the server for Prolog documents\n        documentSelector: [\n          { scheme: 'file', language: 'prolog' },\n          { scheme: 'untitled', language: 'prolog' },\n        ],\n        synchronize: {\n          // Notify the server about file changes to '.pl', '.pro', '.prolog' files contained in the workspace\n          fileEvents: workspace.createFileSystemWatcher('**/*.{pl,pro,prolog,plt,ecl}'),\n        },\n        revealOutputChannelOn: RevealOutputChannelOn.Never,\n        initializationOptions: {\n          // Pass configuration to the server\n          settings: workspace.getConfiguration('prolog'),\n        },\n        middleware: {\n          // Add custom middleware for enhanced functionality\n          provideCompletionItem: async (document, position, context, token, next) => {\n            const result = await next(document, position, context, token);\n\n            // Enhance completions with custom logic if needed\n            if (Array.isArray(result)) {\n              return this.enhanceCompletions(result, document, position);\n            }\n\n            return result;\n          },\n\n          provideHover: async (document, position, token, next) => {\n            const result = await next(document, position, token);\n\n            // Enhance hover information\n            if (result) {\n              return this.enhanceHover(result, document, position);\n            }\n\n            return result;\n          },\n        },\n      };\n\n      // Create the language client and start the client.\n      this.client = new LanguageClient(\n        'prologLSP',\n        'Prolog Language Server',\n        serverOptions,\n        clientOptions\n      );\n\n      // Register client event handlers\n      this.registerEventHandlers();\n\n      // Start the client. This will also launch the server\n      await this.client.start();\n\n      window.showInformationMessage('Prolog LSP Server started successfully');\n    } catch (error) {\n      window.showErrorMessage(`Failed to start Prolog LSP Server: ${error}`);\n      throw error;\n    }\n  }\n\n  public async stop(): Promise<void> {\n    if (this.client) {\n      await this.client.stop();\n      this.client = null;\n    }\n  }\n\n  public async restart(): Promise<void> {\n    await this.stop();\n    await this.start();\n  }\n\n  public isRunning(): boolean {\n    return this.client !== null && this.client.state === 2; // Running state\n  }\n\n  private registerEventHandlers(): void {\n    if (!this.client) {\n      return;\n    }\n\n    // Handle server ready - use the client.start() promise instead of onReady()\n    // The onReady() method has been removed in newer versions of vscode-languageclient\n    // We'll register custom handlers after the client starts successfully\n\n    // Handle server errors\n    this.client.onDidChangeState(event => {\n      console.log(`LSP Client state changed: ${event.oldState} -> ${event.newState}`);\n\n      if (event.newState === 2) {\n        // Running state - register handlers when client becomes ready\n        console.log('Prolog LSP Server is ready');\n        this.registerCustomHandlers();\n      } else if (event.newState === 3) {\n        // Stopped state\n        window.showWarningMessage('Prolog LSP Server stopped unexpectedly');\n      }\n    });\n  }\n\n  private registerCustomHandlers(): void {\n    if (!this.client) {\n      return;\n    }\n\n    // Register custom request handlers for enhanced functionality\n    this.client.onRequest('prolog/queryResult', params => {\n      // Handle query results from server\n      return this.handleQueryResult(params);\n    });\n\n    this.client.onRequest('prolog/helpResult', params => {\n      // Handle help results from server\n      return this.handleHelpResult(params);\n    });\n\n    this.client.onNotification('prolog/diagnosticsUpdate', params => {\n      // Handle diagnostic updates\n      this.handleDiagnosticsUpdate(params);\n    });\n  }\n\n  private enhanceCompletions(completions: any[], document: any, position: any): any[] {\n    // Add context-aware completions\n    const text = document.getText();\n    const line = text.split('\\n')[position.line];\n\n    // Add N3/RDF completions if in semantic web context\n    if (this.isSemanticWebContext(text)) {\n      const semanticCompletions = this.getSemanticWebCompletions();\n      completions.push(...semanticCompletions);\n    }\n\n    // Add project-specific completions\n    const projectCompletions = this.getProjectSpecificCompletions(document);\n    completions.push(...projectCompletions);\n\n    return completions;\n  }\n\n  private enhanceHover(hover: any, document: any, position: any): any {\n    // Enhance hover with additional information\n    const word = this.getWordAtPosition(document.getText(), position);\n\n    if (word && this.isBuiltinPredicate(word)) {\n      // Add links to documentation\n      if (hover.contents) {\n        const enhanced =\n          hover.contents +\n          '\\n\\n[📖 View full documentation](https://www.swi-prolog.org/pldoc/man?predicate=' +\n          word +\n          ')';\n        return { ...hover, contents: enhanced };\n      }\n    }\n\n    return hover;\n  }\n\n  private isSemanticWebContext(text: string): boolean {\n    return (\n      text.includes('@prefix') ||\n      text.includes('rdf:') ||\n      text.includes('rdfs:') ||\n      text.includes('owl:')\n    );\n  }\n\n  private getSemanticWebCompletions(): any[] {\n    return [\n      {\n        label: 'rdf_load',\n        kind: 3, // Function\n        detail: 'rdf_load/2',\n        documentation: 'Load RDF data from file or URL',\n      },\n      {\n        label: 'rdf_assert',\n        kind: 3,\n        detail: 'rdf_assert/3',\n        documentation: 'Assert RDF triple',\n      },\n      {\n        label: 'rdf_retract',\n        kind: 3,\n        detail: 'rdf_retract/3',\n        documentation: 'Retract RDF triple',\n      },\n    ];\n  }\n\n  private getProjectSpecificCompletions(document: any): any[] {\n    // Analyze project structure and provide relevant completions\n    const workspaceFolder = workspace.getWorkspaceFolder(document.uri);\n    if (!workspaceFolder) {\n      return [];\n    }\n\n    // This could be enhanced to scan project files for predicates\n    return [];\n  }\n\n  private getWordAtPosition(text: string, position: any): string | null {\n    const lines = text.split('\\n');\n    const line = lines[position.line];\n    if (!line) {\n      return null;\n    }\n\n    const char = position.character;\n    let start = char;\n    let end = char;\n\n    while (start > 0 && /[a-zA-Z0-9_]/.test(line[start - 1])) {\n      start--;\n    }\n    while (end < line.length && /[a-zA-Z0-9_]/.test(line[end])) {\n      end++;\n    }\n\n    return start < end ? line.substring(start, end) : null;\n  }\n\n  private isBuiltinPredicate(predicate: string): boolean {\n    const builtins = [\n      'member',\n      'append',\n      'length',\n      'reverse',\n      'sort',\n      'findall',\n      'bagof',\n      'setof',\n      'assert',\n      'retract',\n      'write',\n      'writeln',\n      'nl',\n      'is',\n      'var',\n      'nonvar',\n    ];\n    return builtins.includes(predicate);\n  }\n\n  private handleQueryResult(params: any): any {\n    // Handle query results from server\n    console.log('Query result received:', params);\n    return null;\n  }\n\n  private handleHelpResult(params: any): any {\n    // Handle help results from server\n    console.log('Help result received:', params);\n    return null;\n  }\n\n  private handleDiagnosticsUpdate(params: any): void {\n    // Handle diagnostic updates\n    console.log('Diagnostics updated:', params);\n  }\n\n  // Public API for external use\n  public async executeQuery(query: string): Promise<any> {\n    if (!this.client) {\n      throw new Error('LSP client not started');\n    }\n\n    return await this.client.sendRequest('prolog/executeQuery', { query });\n  }\n\n  public async getHelp(predicate: string): Promise<any> {\n    if (!this.client) {\n      throw new Error('LSP client not started');\n    }\n\n    return await this.client.sendRequest('prolog/getHelp', { predicate });\n  }\n\n  public async consultFile(filePath: string): Promise<any> {\n    if (!this.client) {\n      throw new Error('LSP client not started');\n    }\n\n    return await this.client.sendRequest('prolog/consultFile', { filePath });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologLSPExtension.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":147,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":147,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'token' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'token' is defined but never used. Allowed unused args must match /^_/u.","line":202,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":202,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'prefix' is assigned a value but never used.","line":208,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":208,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":225,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":225,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ExtensionContext,\n  languages,\n  workspace,\n  window,\n  commands,\n  Uri,\n  Range,\n  Position,\n  TextDocument,\n  CancellationToken,\n  ProviderResult,\n  CodeAction,\n  CodeActionKind,\n  CodeActionContext,\n  Diagnostic,\n  DiagnosticSeverity,\n  DiagnosticCollection,\n  CompletionItem,\n  CompletionItemKind,\n  MarkdownString,\n} from 'vscode';\nimport { PrologBackend } from '../prologBackend';\n\n/**\n * LSP Extension for Prolog that provides custom requests for queries, help, and N3 diagnostics\n * This works alongside existing language providers to enhance the development experience\n */\nexport class PrologLSPExtension {\n  private backend: PrologBackend | null = null;\n  private diagnosticCollection: DiagnosticCollection;\n  private context: ExtensionContext;\n\n  constructor(context: ExtensionContext, backend: PrologBackend | null) {\n    this.context = context;\n    this.backend = backend;\n    this.diagnosticCollection = languages.createDiagnosticCollection('prolog-lsp');\n    context.subscriptions.push(this.diagnosticCollection);\n  }\n\n  /**\n   * Register all LSP extension features\n   */\n  public registerFeatures() {\n    // Register custom commands for LSP-style operations\n    this.registerCustomCommands();\n\n    // Register enhanced code actions\n    this.registerCodeActionProvider();\n\n    // Register enhanced completion provider\n    this.registerEnhancedCompletionProvider();\n\n    // Register N3 diagnostics\n    this.registerN3DiagnosticsProvider();\n  }\n\n  /**\n   * Register custom LSP-style commands\n   */\n  private registerCustomCommands() {\n    // Custom query execution command\n    const queryCommand = commands.registerCommand(\n      'prolog.lsp.executeQuery',\n      async (query?: string) => {\n        if (!query) {\n          query = await window.showInputBox({\n            prompt: 'Enter Prolog query',\n            placeHolder: 'member(X, [1,2,3])',\n          });\n        }\n\n        if (query && this.backend?.isRunning()) {\n          try {\n            const response = await this.backend.sendRequest('query', {\n              goal: query,\n              timeoutMs: 10000,\n            });\n\n            if (response.status === 'ok') {\n              this.showQueryResults(response.results || []);\n            } else {\n              window.showErrorMessage(`Query failed: ${response.error}`);\n            }\n          } catch (error) {\n            window.showErrorMessage(`Query error: ${error}`);\n          }\n        }\n      }\n    );\n\n    // Custom help lookup command\n    const helpCommand = commands.registerCommand(\n      'prolog.lsp.getHelp',\n      async (predicate?: string) => {\n        if (!predicate) {\n          predicate = await window.showInputBox({\n            prompt: 'Enter predicate name',\n            placeHolder: 'member/2',\n          });\n        }\n\n        if (predicate && this.backend?.isRunning()) {\n          try {\n            const response = await this.backend.sendRequest('help', {\n              predicate,\n              timeoutMs: 5000,\n            });\n\n            if (response.status === 'ok' && response.doc) {\n              this.showHelpDocumentation(response.doc);\n            } else {\n              window.showInformationMessage(`No help found for ${predicate}`);\n            }\n          } catch (error) {\n            window.showErrorMessage(`Help lookup error: ${error}`);\n          }\n        }\n      }\n    );\n\n    // N3 diagnostics command\n    const n3DiagnosticsCommand = commands.registerCommand(\n      'prolog.lsp.runN3Diagnostics',\n      async (uri?: Uri) => {\n        const document = uri\n          ? await workspace.openTextDocument(uri)\n          : window.activeTextEditor?.document;\n\n        if (document && document.languageId === 'prolog') {\n          await this.runN3Diagnostics(document);\n        }\n      }\n    );\n\n    this.context.subscriptions.push(queryCommand, helpCommand, n3DiagnosticsCommand);\n  }\n\n  /**\n   * Register enhanced code action provider\n   */\n  private registerCodeActionProvider() {\n    const provider = languages.registerCodeActionsProvider('prolog', {\n      provideCodeActions: (\n        document: TextDocument,\n        range: Range,\n        context: CodeActionContext,\n        token: CancellationToken\n      ): ProviderResult<CodeAction[]> => {\n        const actions: CodeAction[] = [];\n\n        // Add query execution action\n        const queryAction = new CodeAction('Execute as Query', CodeActionKind.Empty);\n        queryAction.command = {\n          command: 'prolog.lsp.executeQuery',\n          title: 'Execute as Query',\n          arguments: [document.getText(range)],\n        };\n        actions.push(queryAction);\n\n        // Add help lookup action for predicates\n        const text = document.getText(range);\n        const predicateMatch = text.match(/([a-z][a-zA-Z0-9_]*)\\s*\\(/);\n        if (predicateMatch) {\n          const helpAction = new CodeAction('Get Help', CodeActionKind.Empty);\n          helpAction.command = {\n            command: 'prolog.lsp.getHelp',\n            title: 'Get Help',\n            arguments: [predicateMatch[1]],\n          };\n          actions.push(helpAction);\n        }\n\n        // Add N3 diagnostics action\n        if (this.isN3Content(document.getText())) {\n          const n3Action = new CodeAction('Run N3 Diagnostics', CodeActionKind.Source);\n          n3Action.command = {\n            command: 'prolog.lsp.runN3Diagnostics',\n            title: 'Run N3 Diagnostics',\n            arguments: [document.uri],\n          };\n          actions.push(n3Action);\n        }\n\n        return actions;\n      },\n    });\n\n    this.context.subscriptions.push(provider);\n  }\n\n  /**\n   * Register enhanced completion provider with backend integration\n   */\n  private registerEnhancedCompletionProvider() {\n    const provider = languages.registerCompletionItemProvider(\n      'prolog',\n      {\n        provideCompletionItems: async (\n          document: TextDocument,\n          position: Position,\n          token: CancellationToken\n        ): Promise<CompletionItem[]> => {\n          const items: CompletionItem[] = [];\n\n          // Get context around cursor\n          const line = document.lineAt(position);\n          const prefix = line.text.substring(0, position.character);\n\n          // Add built-in predicate completions\n          if (this.backend?.isRunning()) {\n            try {\n              // This would require extending the backend to support predicate listing\n              const builtins = await this.getBuiltinPredicates();\n              builtins.forEach(predicate => {\n                const item = new CompletionItem(predicate.name, CompletionItemKind.Function);\n                item.detail = predicate.arity\n                  ? `${predicate.name}/${predicate.arity}`\n                  : predicate.name;\n                item.documentation = new MarkdownString(\n                  predicate.description || 'Built-in predicate'\n                );\n                items.push(item);\n              });\n            } catch (_error) {\n              // Fallback to static completions\n            }\n          }\n\n          // Add N3 specific completions if in N3 context\n          if (this.isN3Content(document.getText())) {\n            items.push(...this.getN3Completions());\n          }\n\n          return items;\n        },\n      },\n      '(',\n      ',',\n      ' '\n    );\n\n    this.context.subscriptions.push(provider);\n  }\n\n  /**\n   * Register N3 diagnostics provider\n   */\n  private registerN3DiagnosticsProvider() {\n    // Run diagnostics on document changes\n    const disposable = workspace.onDidChangeTextDocument(async event => {\n      if (event.document.languageId === 'prolog' && this.isN3Content(event.document.getText())) {\n        await this.runN3Diagnostics(event.document);\n      }\n    });\n\n    this.context.subscriptions.push(disposable);\n  }\n\n  /**\n   * Run N3 diagnostics on a document\n   */\n  private async runN3Diagnostics(document: TextDocument) {\n    if (!this.backend?.isRunning()) {\n      return;\n    }\n\n    try {\n      const diagnostics: Diagnostic[] = [];\n      const content = document.getText();\n\n      // Try to load N3 content and check for errors\n      const response = await this.backend.sendRequest('n3_load', {\n        content,\n        validate: true,\n        timeoutMs: 5000,\n      });\n\n      if (response.status === 'error') {\n        // Parse error information and create diagnostics\n        const diagnostic = new Diagnostic(\n          new Range(0, 0, 0, 0), // Would need better error location parsing\n          response.error || 'N3 validation error',\n          DiagnosticSeverity.Error\n        );\n        diagnostic.source = 'prolog-n3';\n        diagnostics.push(diagnostic);\n      }\n\n      // Check for common N3 issues\n      diagnostics.push(...this.checkN3CommonIssues(document));\n\n      this.diagnosticCollection.set(document.uri, diagnostics);\n    } catch (error) {\n      console.error('N3 diagnostics error:', error);\n    }\n  }\n\n  /**\n   * Check for common N3 issues\n   */\n  private checkN3CommonIssues(document: TextDocument): Diagnostic[] {\n    const diagnostics: Diagnostic[] = [];\n    const text = document.getText();\n    const lines = text.split('\\n');\n\n    lines.forEach((line, index) => {\n      // Check for missing prefixes\n      if (\n        line.includes(':') &&\n        !line.includes('@prefix') &&\n        !text.includes(`@prefix ${line.split(':')[0]}:`)\n      ) {\n        const diagnostic = new Diagnostic(\n          new Range(index, 0, index, line.length),\n          `Undefined prefix: ${line.split(':')[0]}`,\n          DiagnosticSeverity.Warning\n        );\n        diagnostic.source = 'prolog-n3';\n        diagnostics.push(diagnostic);\n      }\n\n      // Check for malformed triples\n      if (line.trim().endsWith('.') && !line.includes('@') && line.split(/\\s+/).length < 3) {\n        const diagnostic = new Diagnostic(\n          new Range(index, 0, index, line.length),\n          'Incomplete triple statement',\n          DiagnosticSeverity.Error\n        );\n        diagnostic.source = 'prolog-n3';\n        diagnostics.push(diagnostic);\n      }\n    });\n\n    return diagnostics;\n  }\n\n  /**\n   * Show query results in a user-friendly way\n   */\n  private showQueryResults(results: any[]) {\n    if (results.length === 0) {\n      window.showInformationMessage('Query succeeded with no results');\n      return;\n    }\n\n    // Format results for display\n    const formatted = results\n      .map((result, index) => {\n        if (typeof result === 'object' && result !== null) {\n          const bindings = Object.entries(result)\n            .map(([key, value]) => `${key} = ${value}`)\n            .join(', ');\n          return `Solution ${index + 1}: ${bindings}`;\n        }\n        return `Solution ${index + 1}: ${JSON.stringify(result)}`;\n      })\n      .join('\\n');\n\n    // Show in output channel or information message\n    window.showInformationMessage(`Query Results:\\n${formatted}`, { modal: true });\n  }\n\n  /**\n   * Show help documentation\n   */\n  private showHelpDocumentation(doc: any) {\n    const content = `# ${doc.name}/${doc.arity}\\n\\n${doc.summary || 'No description available'}`;\n\n    // Could create a webview or show in information message\n    window.showInformationMessage(content, { modal: true });\n  }\n\n  /**\n   * Check if document contains N3 content\n   */\n  private isN3Content(text: string): boolean {\n    return (\n      text.includes('@prefix') ||\n      text.includes('@base') ||\n      text.includes('rdf:') ||\n      text.includes('rdfs:')\n    );\n  }\n\n  /**\n   * Get built-in predicates (would need backend support)\n   */\n  private async getBuiltinPredicates(): Promise<\n    Array<{ name: string; arity?: number; description?: string }>\n  > {\n    // This would require extending the backend to list predicates\n    // For now, return a static list of common predicates\n    return [\n      { name: 'member', arity: 2, description: 'True if Elem is a member of List' },\n      {\n        name: 'append',\n        arity: 3,\n        description: 'True if List3 is the concatenation of List1 and List2',\n      },\n      { name: 'findall', arity: 3, description: 'Find all solutions to Goal' },\n      { name: 'bagof', arity: 3, description: 'Collect solutions to Goal' },\n      { name: 'setof', arity: 3, description: 'Collect unique solutions to Goal' },\n      { name: 'length', arity: 2, description: 'True if Length is the length of List' },\n      { name: 'reverse', arity: 2, description: 'True if List2 is the reverse of List1' },\n      { name: 'sort', arity: 2, description: 'True if Sorted is the sorted version of List' },\n    ];\n  }\n\n  /**\n   * Get N3-specific completions\n   */\n  private getN3Completions(): CompletionItem[] {\n    const items: CompletionItem[] = [];\n\n    // Common N3 prefixes\n    const prefixes = [\n      { name: '@prefix rdf:', detail: 'RDF namespace' },\n      { name: '@prefix rdfs:', detail: 'RDF Schema namespace' },\n      { name: '@prefix owl:', detail: 'OWL namespace' },\n      { name: '@prefix xsd:', detail: 'XML Schema namespace' },\n    ];\n\n    prefixes.forEach(prefix => {\n      const item = new CompletionItem(prefix.name, CompletionItemKind.Keyword);\n      item.detail = prefix.detail;\n      items.push(item);\n    });\n\n    // Common N3 properties\n    const properties = [\n      'rdf:type',\n      'rdfs:label',\n      'rdfs:comment',\n      'owl:sameAs',\n      'owl:differentFrom',\n    ];\n\n    properties.forEach(prop => {\n      const item = new CompletionItem(prop, CompletionItemKind.Property);\n      item.detail = 'N3 property';\n      items.push(item);\n    });\n\n    return items;\n  }\n\n  /**\n   * Dispose of resources\n   */\n  public dispose() {\n    this.diagnosticCollection.dispose();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologLSPServer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_hasDiagnosticRelatedInformationCapability' is assigned a value but never used.","line":65,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":521,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":521,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_prefix' is assigned a value but never used.","line":540,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":540,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":605,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":605,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":710,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":710,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":780,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":780,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_markdown' is assigned a value but never used.","line":1001,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":1001,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":1082,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1082,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  createConnection,\n  TextDocuments,\n  Diagnostic,\n  DiagnosticSeverity,\n  ProposedFeatures,\n  InitializeParams,\n  DidChangeConfigurationNotification,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocumentPositionParams,\n  TextDocumentSyncKind,\n  InitializeResult,\n  HoverParams,\n  Hover,\n  MarkupKind,\n  CodeActionParams,\n  CodeAction,\n  CodeActionKind,\n  ExecuteCommandParams,\n  DefinitionParams,\n  Definition,\n  Location,\n  Range,\n  Position,\n  DocumentSymbolParams,\n  DocumentSymbol,\n  SymbolKind,\n  WorkspaceSymbolParams,\n  SymbolInformation,\n  ReferenceParams,\n  DocumentHighlightParams,\n  DocumentHighlight,\n  DocumentHighlightKind,\n  SignatureHelpParams,\n  SignatureHelp,\n  SignatureInformation,\n  DocumentFormattingParams,\n  TextEdit,\n  DocumentRangeFormattingParams,\n  RenameParams,\n  WorkspaceEdit,\n  PrepareRenameParams,\n  FoldingRangeParams,\n  FoldingRange,\n  FoldingRangeKind,\n  SemanticTokensParams,\n  SemanticTokens,\n  SemanticTokensBuilder,\n  SemanticTokensLegend,\n} from 'vscode-languageserver/node';\n\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { PrologBackend } from '../prologBackend';\n\n// Create a connection for the server, using Node's IPC as a transport.\n// Also include all preview / proposed LSP features.\nconst connection = createConnection(ProposedFeatures.all);\n\n// Create a simple text document manager.\nconst documents: TextDocuments<TextDocument> = new TextDocuments(TextDocument);\n\nlet hasConfigurationCapability = false;\nlet hasWorkspaceFolderCapability = false;\nlet _hasDiagnosticRelatedInformationCapability = false;\n\n// Prolog backend instance\nlet prologBackend: PrologBackend | null = null;\n\n// Document settings cache\ninterface PrologSettings {\n  executablePath: string;\n  dialect: 'swi' | 'ecl';\n  linter: {\n    run: 'onSave' | 'onType' | 'never';\n    delay: number;\n    enableMsgInOutput: boolean;\n  };\n  format: {\n    addSpace: boolean;\n  };\n  terminal: {\n    runtimeArgs: string[];\n  };\n}\n\nconst defaultSettings: PrologSettings = {\n  executablePath: 'swipl',\n  dialect: 'swi',\n  linter: {\n    run: 'onType',\n    delay: 500,\n    enableMsgInOutput: false,\n  },\n  format: {\n    addSpace: true,\n  },\n  terminal: {\n    runtimeArgs: [],\n  },\n};\n\nlet globalSettings: PrologSettings = defaultSettings;\nconst documentSettings: Map<string, Promise<PrologSettings>> = new Map();\n\n// Semantic tokens legend\nconst semanticTokensLegend: SemanticTokensLegend = {\n  tokenTypes: [\n    'namespace',\n    'type',\n    'class',\n    'enum',\n    'interface',\n    'struct',\n    'typeParameter',\n    'parameter',\n    'variable',\n    'property',\n    'enumMember',\n    'event',\n    'function',\n    'method',\n    'macro',\n    'keyword',\n    'modifier',\n    'comment',\n    'string',\n    'number',\n    'regexp',\n    'operator',\n    'decorator',\n  ],\n  tokenModifiers: [\n    'declaration',\n    'definition',\n    'readonly',\n    'static',\n    'deprecated',\n    'abstract',\n    'async',\n    'modification',\n    'documentation',\n    'defaultLibrary',\n  ],\n};\n\nconnection.onInitialize((params: InitializeParams) => {\n  const capabilities = params.capabilities;\n\n  // Does the client support the `workspace/configuration` request?\n  hasConfigurationCapability = !!(capabilities.workspace && !!capabilities.workspace.configuration);\n  hasWorkspaceFolderCapability = !!(\n    capabilities.workspace && !!capabilities.workspace.workspaceFolders\n  );\n  _hasDiagnosticRelatedInformationCapability = !!(\n    capabilities.textDocument?.publishDiagnostics &&\n    capabilities.textDocument.publishDiagnostics.relatedInformation\n  );\n\n  const result: InitializeResult = {\n    capabilities: {\n      textDocumentSync: TextDocumentSyncKind.Incremental,\n      // Tell the client that this server supports code completion.\n      completionProvider: {\n        resolveProvider: true,\n        triggerCharacters: ['(', ',', ' ', '.', ':', '-', '_'],\n      },\n      // Hover support\n      hoverProvider: true,\n      // Code actions\n      codeActionProvider: {\n        codeActionKinds: [\n          CodeActionKind.QuickFix,\n          CodeActionKind.Refactor,\n          CodeActionKind.Source,\n          CodeActionKind.SourceOrganizeImports,\n        ],\n      },\n      // Execute command\n      executeCommandProvider: {\n        commands: [\n          'prolog.executeQuery',\n          'prolog.consultFile',\n          'prolog.getHelp',\n          'prolog.runN3Diagnostics',\n          'prolog.formatDocument',\n          'prolog.organizeImports',\n        ],\n      },\n      // Definition provider\n      definitionProvider: true,\n      // Document symbol provider\n      documentSymbolProvider: true,\n      // Workspace symbol provider\n      workspaceSymbolProvider: true,\n      // References provider\n      referencesProvider: true,\n      // Document highlight provider\n      documentHighlightProvider: true,\n      // Signature help provider\n      signatureHelpProvider: {\n        triggerCharacters: ['(', ','],\n      },\n      // Document formatting\n      documentFormattingProvider: true,\n      documentRangeFormattingProvider: true,\n      // Rename provider\n      renameProvider: {\n        prepareProvider: true,\n      },\n      // Folding range provider\n      foldingRangeProvider: true,\n      // Semantic tokens provider\n      semanticTokensProvider: {\n        legend: semanticTokensLegend,\n        range: true,\n        full: {\n          delta: true,\n        },\n      },\n      // Document color provider\n      colorProvider: true,\n      // Call hierarchy provider\n      callHierarchyProvider: true,\n      // Linked editing range provider\n      linkedEditingRangeProvider: true,\n      // Moniker provider\n      monikerProvider: true,\n      // Type definition provider\n      typeDefinitionProvider: true,\n      // Implementation provider\n      implementationProvider: true,\n      // Declaration provider\n      declarationProvider: true,\n      // Selection range provider\n      selectionRangeProvider: true,\n    },\n  };\n\n  if (hasWorkspaceFolderCapability) {\n    result.capabilities.workspace = {\n      workspaceFolders: {\n        supported: true,\n      },\n    };\n  }\n\n  return result;\n});\n\nconnection.onInitialized(() => {\n  if (hasConfigurationCapability) {\n    // Register for all configuration changes.\n    connection.client.register(DidChangeConfigurationNotification.type, undefined);\n  }\n  if (hasWorkspaceFolderCapability) {\n    connection.workspace.onDidChangeWorkspaceFolders(_event => {\n      connection.console.log('Workspace folder change event received.');\n    });\n  }\n\n  // Initialize Prolog backend\n  initializePrologBackend();\n});\n\nasync function initializePrologBackend() {\n  try {\n    const settings = await getGlobalSettings();\n    prologBackend = new PrologBackend({\n      swiplPath: settings.executablePath,\n      port: 3061, // Different port for LSP server\n      streamingEnabled: true,\n      maxResultsPerChunk: 50,\n    });\n\n    prologBackend.on('ready', () => {\n      connection.console.log('Prolog backend ready for LSP server');\n    });\n\n    prologBackend.on('error', error => {\n      connection.console.error(`Prolog backend error: ${error}`);\n    });\n\n    prologBackend.start();\n  } catch (error: unknown) {\n    connection.console.error(`Failed to initialize Prolog backend: ${error}`);\n  }\n}\n\nconnection.onDidChangeConfiguration(change => {\n  if (hasConfigurationCapability) {\n    // Reset all cached document settings\n    documentSettings.clear();\n  } else {\n    globalSettings = <PrologSettings>(change.settings.prolog || defaultSettings);\n  }\n\n  // Revalidate all open text documents\n  documents.all().forEach(validateTextDocument);\n});\n\nfunction getDocumentSettings(resource: string): Promise<PrologSettings> {\n  if (!hasConfigurationCapability) {\n    return Promise.resolve(globalSettings);\n  }\n  let result = documentSettings.get(resource);\n  if (!result) {\n    result = connection.workspace.getConfiguration({\n      scopeUri: resource,\n      section: 'prolog',\n    });\n    documentSettings.set(resource, result);\n  }\n  return result;\n}\n\nfunction getGlobalSettings(): Promise<PrologSettings> {\n  if (!hasConfigurationCapability) {\n    return Promise.resolve(globalSettings);\n  }\n  return connection.workspace.getConfiguration('prolog');\n}\n\n// Only keep settings for open documents\ndocuments.onDidClose(e => {\n  documentSettings.delete(e.document.uri);\n});\n\n// The content of a text document has changed. This event is emitted\n// when the text document first opened or when its content has changed.\ndocuments.onDidChangeContent(change => {\n  validateTextDocument(change.document);\n});\n\nasync function validateTextDocument(textDocument: TextDocument): Promise<void> {\n  const settings = await getDocumentSettings(textDocument.uri);\n\n  if (settings.linter.run === 'never') {\n    return;\n  }\n\n  const diagnostics: Diagnostic[] = [];\n  const text = textDocument.getText();\n  const lines = text.split('\\n');\n\n  // Basic Prolog syntax validation\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmedLine = line.trim();\n\n    if (trimmedLine === '' || trimmedLine.startsWith('%')) {\n      continue; // Skip empty lines and comments\n    }\n\n    // Check for common syntax errors\n    const diagnosticsForLine = validatePrologLine(line, i, textDocument);\n    diagnostics.push(...diagnosticsForLine);\n  }\n\n  // Advanced validation using Prolog backend\n  if (prologBackend?.isRunning()) {\n    try {\n      const backendDiagnostics = await validateWithBackend(textDocument);\n      diagnostics.push(...backendDiagnostics);\n    } catch (error: unknown) {\n      connection.console.error(`Backend validation error: ${error}`);\n    }\n  }\n\n  // Send the computed diagnostics to VSCode.\n  connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });\n}\n\nfunction validatePrologLine(\n  line: string,\n  lineNumber: number,\n  _document: TextDocument\n): Diagnostic[] {\n  const diagnostics: Diagnostic[] = [];\n  const trimmedLine = line.trim();\n\n  // Check for unmatched parentheses\n  const openParens = (line.match(/\\(/g) || []).length;\n  const closeParens = (line.match(/\\)/g) || []).length;\n\n  if (openParens !== closeParens) {\n    const diagnostic: Diagnostic = {\n      severity: DiagnosticSeverity.Error,\n      range: {\n        start: { line: lineNumber, character: 0 },\n        end: { line: lineNumber, character: line.length },\n      },\n      message: `Unmatched parentheses: ${openParens} opening, ${closeParens} closing`,\n      source: 'prolog-lsp',\n    };\n    diagnostics.push(diagnostic);\n  }\n\n  // Check for missing periods at end of clauses\n  if (\n    trimmedLine.length > 0 &&\n    !trimmedLine.endsWith('.') &&\n    !trimmedLine.endsWith(':-') &&\n    !trimmedLine.startsWith('?-') &&\n    !trimmedLine.startsWith(':-')\n  ) {\n    const diagnostic: Diagnostic = {\n      severity: DiagnosticSeverity.Warning,\n      range: {\n        start: { line: lineNumber, character: line.length - 1 },\n        end: { line: lineNumber, character: line.length },\n      },\n      message: 'Clause should end with a period',\n      source: 'prolog-lsp',\n    };\n    diagnostics.push(diagnostic);\n  }\n\n  // Check for undefined predicates (basic heuristic)\n  const predicateMatch = trimmedLine.match(/^([a-z][a-zA-Z0-9_]*)\\s*\\(/);\n  if (predicateMatch) {\n    const predicate = predicateMatch[1];\n    if (isLikelyUndefinedPredicate(predicate)) {\n      const diagnostic: Diagnostic = {\n        severity: DiagnosticSeverity.Information,\n        range: {\n          start: { line: lineNumber, character: line.indexOf(predicate) },\n          end: { line: lineNumber, character: line.indexOf(predicate) + predicate.length },\n        },\n        message: `Predicate '${predicate}' may be undefined`,\n        source: 'prolog-lsp',\n      };\n      diagnostics.push(diagnostic);\n    }\n  }\n\n  return diagnostics;\n}\n\nfunction isLikelyUndefinedPredicate(predicate: string): boolean {\n  // List of common built-in predicates\n  const builtins = [\n    'member',\n    'append',\n    'length',\n    'reverse',\n    'sort',\n    'findall',\n    'bagof',\n    'setof',\n    'assert',\n    'retract',\n    'asserta',\n    'assertz',\n    'retracta',\n    'retractall',\n    'write',\n    'writeln',\n    'read',\n    'get',\n    'put',\n    'nl',\n    'tab',\n    'is',\n    'var',\n    'nonvar',\n    'atom',\n    'number',\n    'compound',\n    'atomic',\n    'functor',\n    'arg',\n    'univ',\n    'copy_term',\n    'numbervars',\n    'call',\n    'once',\n    'ignore',\n    'forall',\n    'between',\n    'succ',\n    'true',\n    'fail',\n    'halt',\n    'abort',\n    'trace',\n    'notrace',\n    'spy',\n    'nospy',\n  ];\n\n  return !builtins.includes(predicate);\n}\n\nasync function validateWithBackend(document: TextDocument): Promise<Diagnostic[]> {\n  if (!prologBackend?.isRunning()) {\n    return [];\n  }\n\n  try {\n    // Try to consult the document content\n    const response = await prologBackend.sendRequest('validate', {\n      content: document.getText(),\n      uri: document.uri,\n      timeoutMs: 5000,\n    });\n\n    if (response.status === 'error' && response.errors) {\n      return response.errors.map(\n        (error: { line?: number; column?: number; length?: number; message?: string }) => ({\n          severity: DiagnosticSeverity.Error,\n          range: {\n            start: { line: error.line || 0, character: error.column || 0 },\n            end: { line: error.line || 0, character: (error.column || 0) + (error.length || 1) },\n          },\n          message: error.message || 'Validation error',\n          source: 'prolog-backend',\n        })\n      );\n    }\n  } catch (_error: unknown) {\n    // Backend validation failed, return empty array\n  }\n\n  return [];\n}\n\n// Completion provider\nconnection.onCompletion(\n  async (_textDocumentPosition: TextDocumentPositionParams): Promise<CompletionItem[]> => {\n    const document = documents.get(_textDocumentPosition.textDocument.uri);\n    if (!document) {\n      return [];\n    }\n\n    const position = _textDocumentPosition.position;\n    const text = document.getText();\n    const lines = text.split('\\n');\n    const currentLine = lines[position.line] || '';\n    const _prefix = currentLine.substring(0, position.character);\n\n    const completions: CompletionItem[] = [];\n\n    // Built-in predicates\n    const builtinPredicates = [\n      { name: 'member', arity: 2, description: 'True if Elem is a member of List' },\n      {\n        name: 'append',\n        arity: 3,\n        description: 'True if List3 is the concatenation of List1 and List2',\n      },\n      { name: 'length', arity: 2, description: 'True if Length is the length of List' },\n      { name: 'reverse', arity: 2, description: 'True if List2 is the reverse of List1' },\n      { name: 'sort', arity: 2, description: 'True if Sorted is the sorted version of List' },\n      { name: 'findall', arity: 3, description: 'Find all solutions to Goal' },\n      { name: 'bagof', arity: 3, description: 'Collect solutions to Goal' },\n      { name: 'setof', arity: 3, description: 'Collect unique solutions to Goal' },\n      { name: 'assert', arity: 1, description: 'Add clause to database' },\n      { name: 'retract', arity: 1, description: 'Remove clause from database' },\n      { name: 'write', arity: 1, description: 'Write term to output' },\n      { name: 'writeln', arity: 1, description: 'Write term followed by newline' },\n      { name: 'nl', arity: 0, description: 'Write newline to output' },\n      { name: 'is', arity: 2, description: 'Arithmetic evaluation' },\n      { name: 'var', arity: 1, description: 'True if argument is unbound variable' },\n      { name: 'nonvar', arity: 1, description: 'True if argument is not unbound variable' },\n      { name: 'atom', arity: 1, description: 'True if argument is an atom' },\n      { name: 'number', arity: 1, description: 'True if argument is a number' },\n      { name: 'compound', arity: 1, description: 'True if argument is a compound term' },\n      { name: 'functor', arity: 3, description: 'Relate compound term to functor name and arity' },\n      { name: 'arg', arity: 3, description: 'Extract argument from compound term' },\n      { name: 'univ', arity: 2, description: 'Convert between term and list representation' },\n      { name: 'call', arity: 1, description: 'Call goal dynamically' },\n      { name: 'once', arity: 1, description: 'Succeed at most once' },\n      {\n        name: 'forall',\n        arity: 2,\n        description: 'For all solutions of Condition, Action must succeed',\n      },\n      { name: 'between', arity: 3, description: 'Generate integers between bounds' },\n      { name: 'succ', arity: 2, description: 'Successor relation for integers' },\n    ];\n\n    builtinPredicates.forEach(pred => {\n      const item: CompletionItem = {\n        label: pred.name,\n        kind: CompletionItemKind.Function,\n        detail: `${pred.name}/${pred.arity}`,\n        documentation: pred.description,\n        insertText: pred.arity > 0 ? `${pred.name}(` : pred.name,\n      };\n      completions.push(item);\n    });\n\n    // N3/RDF completions if in N3 context\n    if (isN3Context(text)) {\n      const n3Completions = getN3Completions();\n      completions.push(...n3Completions);\n    }\n\n    // Dynamic completions from backend\n    if (prologBackend?.isRunning()) {\n      try {\n        const dynamicCompletions = await getDynamicCompletions(document, position);\n        completions.push(...dynamicCompletions);\n      } catch (error: unknown) {\n        // Ignore errors in dynamic completion\n      }\n    }\n\n    return completions;\n  }\n);\n\nfunction isN3Context(text: string): boolean {\n  return (\n    text.includes('@prefix') ||\n    text.includes('@base') ||\n    text.includes('rdf:') ||\n    text.includes('rdfs:') ||\n    text.includes('owl:')\n  );\n}\n\nfunction getN3Completions(): CompletionItem[] {\n  const completions: CompletionItem[] = [];\n\n  // N3 prefixes\n  const prefixes = [\n    { name: '@prefix rdf:', detail: '<http://www.w3.org/1999/02/22-rdf-syntax-ns#>' },\n    { name: '@prefix rdfs:', detail: '<http://www.w3.org/2000/01/rdf-schema#>' },\n    { name: '@prefix owl:', detail: '<http://www.w3.org/2002/07/owl#>' },\n    { name: '@prefix xsd:', detail: '<http://www.w3.org/2001/XMLSchema#>' },\n    { name: '@prefix foaf:', detail: '<http://xmlns.com/foaf/0.1/>' },\n    { name: '@prefix dc:', detail: '<http://purl.org/dc/elements/1.1/>' },\n  ];\n\n  prefixes.forEach(prefix => {\n    completions.push({\n      label: prefix.name,\n      kind: CompletionItemKind.Keyword,\n      detail: prefix.detail,\n      insertText: `${prefix.name} ${prefix.detail} .`,\n    });\n  });\n\n  // Common RDF properties\n  const properties = [\n    'rdf:type',\n    'rdfs:label',\n    'rdfs:comment',\n    'rdfs:seeAlso',\n    'rdfs:isDefinedBy',\n    'owl:sameAs',\n    'owl:differentFrom',\n    'owl:equivalentClass',\n    'owl:equivalentProperty',\n    'foaf:name',\n    'foaf:knows',\n    'foaf:mbox',\n    'dc:title',\n    'dc:creator',\n    'dc:date',\n  ];\n\n  properties.forEach(prop => {\n    completions.push({\n      label: prop,\n      kind: CompletionItemKind.Property,\n      detail: 'RDF property',\n    });\n  });\n\n  return completions;\n}\n\nasync function getDynamicCompletions(\n  document: TextDocument,\n  position: Position\n): Promise<CompletionItem[]> {\n  if (!prologBackend?.isRunning()) {\n    return [];\n  }\n\n  try {\n    const response = await prologBackend.sendRequest('completions', {\n      uri: document.uri,\n      content: document.getText(),\n      line: position.line,\n      character: position.character,\n      timeoutMs: 2000,\n    });\n\n    if (response.status === 'ok' && response.completions) {\n      return response.completions.map(\n        (comp: {\n          label: string;\n          kind?: string;\n          detail?: string;\n          documentation?: string;\n          insertText?: string;\n        }) => ({\n          label: comp.label,\n          kind: getCompletionItemKind(comp.kind),\n          detail: comp.detail,\n          documentation: comp.documentation,\n          insertText: comp.insertText || comp.label,\n        })\n      );\n    }\n  } catch (error: unknown) {\n    // Ignore errors\n  }\n\n  return [];\n}\n\nfunction getCompletionItemKind(kind: string): CompletionItemKind {\n  switch (kind) {\n    case 'predicate': {\n      return CompletionItemKind.Function;\n    }\n    case 'variable': {\n      return CompletionItemKind.Variable;\n    }\n    case 'atom': {\n      return CompletionItemKind.Constant;\n    }\n    case 'module': {\n      return CompletionItemKind.Module;\n    }\n    case 'operator': {\n      return CompletionItemKind.Operator;\n    }\n    default: {\n      return CompletionItemKind.Text;\n    }\n  }\n}\n\n// Completion resolve\nconnection.onCompletionResolve((item: CompletionItem): CompletionItem => {\n  // Add more detailed documentation if needed\n  return item;\n});\n\n// Hover provider\nconnection.onHover(async (params: HoverParams): Promise<Hover | null> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return null;\n  }\n\n  const position = params.position;\n  const text = document.getText();\n  const word = getWordAtPosition(text, position);\n\n  if (!word) {\n    return null;\n  }\n\n  // Try to get help from backend\n  if (prologBackend?.isRunning()) {\n    try {\n      const response = await prologBackend.sendRequest('help', {\n        predicate: word,\n        timeoutMs: 3000,\n      });\n\n      if (response.status === 'ok' && response.doc) {\n        const doc = response.doc;\n        const markdown = formatHelpAsMarkdown(doc);\n\n        return {\n          contents: {\n            kind: MarkupKind.Markdown,\n            value: markdown,\n          },\n        };\n      }\n    } catch (error) {\n      // Fall back to static help\n    }\n  }\n\n  // Static help for common predicates\n  const staticHelp = getStaticHelp(word);\n  if (staticHelp) {\n    return {\n      contents: {\n        kind: MarkupKind.Markdown,\n        value: staticHelp,\n      },\n    };\n  }\n\n  return null;\n});\n\nfunction getWordAtPosition(text: string, position: Position): string | null {\n  const lines = text.split('\\n');\n  const line = lines[position.line];\n  if (!line) {\n    return null;\n  }\n\n  const char = position.character;\n  let start = char;\n  let end = char;\n\n  // Find word boundaries\n  while (start > 0 && /[a-zA-Z0-9_]/.test(line[start - 1])) {\n    start--;\n  }\n  while (end < line.length && /[a-zA-Z0-9_]/.test(line[end])) {\n    end++;\n  }\n\n  return start < end ? line.substring(start, end) : null;\n}\n\nfunction formatHelpAsMarkdown(doc: {\n  name: string;\n  arity: number;\n  summary?: string;\n  args?: Array<{ name: string; description: string }>;\n  examples?: string[];\n}): string {\n  let markdown = `# ${doc.name}/${doc.arity}\\n\\n`;\n\n  if (doc.summary) {\n    markdown += `${doc.summary}\\n\\n`;\n  }\n\n  if (doc.args && doc.args.length > 0) {\n    markdown += '## Arguments\\n\\n';\n    doc.args.forEach((arg: any, index: number) => {\n      markdown += `**${index + 1}. ${arg.name}** - ${arg.description}\\n\\n`;\n    });\n  }\n\n  if (doc.examples && doc.examples.length > 0) {\n    markdown += '## Examples\\n\\n';\n    doc.examples.forEach((example: string) => {\n      markdown += `\\`\\`\\`prolog\\n${example}\\n\\`\\`\\`\\n\\n`;\n    });\n  }\n\n  return markdown;\n}\n\nfunction getStaticHelp(word: string): string | null {\n  const staticHelp: Record<string, string> = {\n    member:\n      '# member/2\\n\\nTrue if Elem is a member of List.\\n\\n```prolog\\nmember(X, [1,2,3]).\\n```',\n    append:\n      '# append/3\\n\\nTrue if List3 is the concatenation of List1 and List2.\\n\\n```prolog\\nappend([1,2], [3,4], X).\\n```',\n    length:\n      '# length/2\\n\\nTrue if Length is the length of List.\\n\\n```prolog\\nlength([1,2,3], X).\\n```',\n    findall:\n      '# findall/3\\n\\nFind all solutions to Goal.\\n\\n```prolog\\nfindall(X, member(X, [1,2,3]), L).\\n```',\n  };\n\n  return staticHelp[word] || null;\n}\n\n// Code actions provider\nconnection.onCodeAction(async (params: CodeActionParams): Promise<CodeAction[]> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return [];\n  }\n\n  const actions: CodeAction[] = [];\n  const range = params.range;\n  const selectedText = document.getText(range);\n\n  // Quick fix actions for diagnostics\n  for (const diagnostic of params.context.diagnostics) {\n    if (diagnostic.source === 'prolog-lsp') {\n      if (diagnostic.message.includes('missing period')) {\n        const fix: CodeAction = {\n          title: 'Add missing period',\n          kind: CodeActionKind.QuickFix,\n          diagnostics: [diagnostic],\n          edit: {\n            changes: {\n              [params.textDocument.uri]: [\n                {\n                  range: {\n                    start: diagnostic.range.end,\n                    end: diagnostic.range.end,\n                  },\n                  newText: '.',\n                },\n              ],\n            },\n          },\n        };\n        actions.push(fix);\n      }\n    }\n  }\n\n  // Refactor actions\n  if (selectedText.trim()) {\n    // Execute as query\n    const executeAction: CodeAction = {\n      title: 'Execute as Prolog query',\n      kind: CodeActionKind.Source,\n      command: {\n        title: 'Execute Query',\n        command: 'prolog.executeQuery',\n        arguments: [selectedText.trim()],\n      },\n    };\n    actions.push(executeAction);\n\n    // Get help for predicate\n    const predicateMatch = selectedText.match(/([a-z][a-zA-Z0-9_]*)/);\n    if (predicateMatch) {\n      const helpAction: CodeAction = {\n        title: `Get help for ${predicateMatch[1]}`,\n        kind: CodeActionKind.Source,\n        command: {\n          title: 'Get Help',\n          command: 'prolog.getHelp',\n          arguments: [predicateMatch[1]],\n        },\n      };\n      actions.push(helpAction);\n    }\n  }\n\n  // Source actions\n  const formatAction: CodeAction = {\n    title: 'Format document',\n    kind: CodeActionKind.SourceOrganizeImports,\n    command: {\n      title: 'Format Document',\n      command: 'prolog.formatDocument',\n      arguments: [params.textDocument.uri],\n    },\n  };\n  actions.push(formatAction);\n\n  return actions;\n});\n\n// Execute command handler\nconnection.onExecuteCommand(async (params: ExecuteCommandParams): Promise<any> => {\n  const command = params.command;\n  const args = params.arguments || [];\n\n  switch (command) {\n    case 'prolog.executeQuery': {\n      if (args.length > 0 && prologBackend?.isRunning()) {\n        try {\n          const response = await prologBackend.sendRequest('query', {\n            goal: args[0],\n            timeoutMs: 10000,\n          });\n          connection.window.showInformationMessage(\n            response.status === 'ok'\n              ? `Query result: ${JSON.stringify(response.results)}`\n              : `Query failed: ${response.error}`\n          );\n          return response;\n        } catch (error: unknown) {\n          connection.window.showErrorMessage(`Query error: ${error}`);\n        }\n      }\n      break;\n    }\n    case 'prolog.consultFile': {\n      if (args.length > 0 && prologBackend?.isRunning()) {\n        try {\n          const response = await prologBackend.sendRequest('consult', {\n            file: args[0],\n            timeoutMs: 15000,\n          });\n          connection.window.showInformationMessage(\n            response.status === 'ok'\n              ? `File consulted: ${args[0]}`\n              : `Consult failed: ${response.error}`\n          );\n          return response;\n        } catch (error: unknown) {\n          connection.window.showErrorMessage(`Consult error: ${error}`);\n        }\n      }\n      break;\n    }\n    case 'prolog.getHelp': {\n      if (args.length > 0 && prologBackend?.isRunning()) {\n        try {\n          const response = await prologBackend.sendRequest('help', {\n            predicate: args[0],\n            timeoutMs: 5000,\n          });\n          if (response.status === 'ok' && response.doc) {\n            const _markdown = formatHelpAsMarkdown(response.doc);\n            connection.window.showInformationMessage(\n              `Help for ${args[0]}: ${response.doc.summary || 'No description'}`\n            );\n          }\n          return response;\n        } catch (error: unknown) {\n          connection.window.showErrorMessage(`Help error: ${error}`);\n        }\n      }\n      break;\n    }\n    case 'prolog.runN3Diagnostics': {\n      if (args.length > 0) {\n        const document = documents.get(args[0]);\n        if (document) {\n          await validateTextDocument(document);\n          connection.window.showInformationMessage('N3 diagnostics completed');\n        }\n      }\n      break;\n    }\n    case 'prolog.formatDocument': {\n      if (args.length > 0) {\n        const document = documents.get(args[0]);\n        if (document) {\n          const formatted = await formatPrologDocument(document);\n          return formatted;\n        }\n      }\n      break;\n    }\n    case 'prolog.organizeImports': {\n      if (args.length > 0) {\n        const document = documents.get(args[0]);\n        if (document) {\n          const organized = await organizeImports(document);\n          return organized;\n        }\n      }\n      break;\n    }\n  }\n\n  return null;\n});\n\n// Definition provider\nconnection.onDefinition(async (params: DefinitionParams): Promise<Definition | null> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return null;\n  }\n\n  const position = params.position;\n  const word = getWordAtPosition(document.getText(), position);\n\n  if (!word) {\n    return null;\n  }\n\n  // Try to find definition using backend\n  if (prologBackend?.isRunning()) {\n    try {\n      const response = await prologBackend.sendRequest('definition', {\n        predicate: word,\n        uri: params.textDocument.uri,\n        line: position.line,\n        character: position.character,\n        timeoutMs: 3000,\n      });\n\n      if (response.status === 'ok' && response.locations) {\n        return response.locations.map((loc: { uri: string; line: number; character: number }) => ({\n          uri: loc.uri,\n          range: {\n            start: { line: loc.line, character: loc.character },\n            end: { line: loc.line, character: loc.character + word.length },\n          },\n        }));\n      }\n    } catch (_error: unknown) {\n      // Fall back to local search\n    }\n  }\n\n  // Local definition search\n  return findLocalDefinition(document, word);\n});\n\nfunction findLocalDefinition(document: TextDocument, predicate: string): Location[] {\n  const text = document.getText();\n  const lines = text.split('\\n');\n  const locations: Location[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const regex = new RegExp(`^\\\\s*${predicate}\\\\s*\\\\(`, 'g');\n    const match = regex.exec(line);\n\n    if (match) {\n      locations.push({\n        uri: document.uri,\n        range: {\n          start: { line: i, character: match.index },\n          end: { line: i, character: match.index + predicate.length },\n        },\n      });\n    }\n  }\n\n  return locations;\n}\n\n// Document symbol provider\nconnection.onDocumentSymbol(async (params: DocumentSymbolParams): Promise<DocumentSymbol[]> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return [];\n  }\n\n  const symbols: DocumentSymbol[] = [];\n  const text = document.getText();\n  const lines = text.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    if (line.startsWith('%') || line === '') {\n      continue;\n    }\n\n    // Match predicate definitions\n    const predicateMatch = line.match(/^([a-z][a-zA-Z0-9_]*)\\s*\\(/);\n    if (predicateMatch) {\n      const name = predicateMatch[1];\n      const arity = countArity(line);\n\n      symbols.push({\n        name: `${name}/${arity}`,\n        kind: SymbolKind.Function,\n        range: {\n          start: { line: i, character: 0 },\n          end: { line: i, character: line.length },\n        },\n        selectionRange: {\n          start: { line: i, character: 0 },\n          end: { line: i, character: name.length },\n        },\n      });\n    }\n\n    // Match directives\n    const directiveMatch = line.match(/^:-\\s*(.+)\\./);\n    if (directiveMatch) {\n      symbols.push({\n        name: `:- ${directiveMatch[1]}`,\n        kind: SymbolKind.Namespace,\n        range: {\n          start: { line: i, character: 0 },\n          end: { line: i, character: line.length },\n        },\n        selectionRange: {\n          start: { line: i, character: 0 },\n          end: { line: i, character: 2 },\n        },\n      });\n    }\n  }\n\n  return symbols;\n});\n\nfunction countArity(line: string): number {\n  const match = line.match(/\\(([^)]*)\\)/);\n  if (!match) return 0;\n\n  const args = match[1].trim();\n  if (args === '') return 0;\n\n  // Simple arity counting (doesn't handle nested structures perfectly)\n  return args.split(',').length;\n}\n\n// Workspace symbol provider\nconnection.onWorkspaceSymbol(\n  async (params: WorkspaceSymbolParams): Promise<SymbolInformation[]> => {\n    const symbols: SymbolInformation[] = [];\n    const query = params.query.toLowerCase();\n\n    // Search through all open documents\n    for (const document of documents.all()) {\n      const documentSymbols = await connection.sendRequest('textDocument/documentSymbol', {\n        textDocument: { uri: document.uri },\n      });\n\n      for (const symbol of documentSymbols) {\n        if (symbol.name.toLowerCase().includes(query)) {\n          symbols.push({\n            name: symbol.name,\n            kind: symbol.kind,\n            location: {\n              uri: document.uri,\n              range: symbol.range,\n            },\n          });\n        }\n      }\n    }\n\n    return symbols;\n  }\n);\n\n// References provider\nconnection.onReferences(async (params: ReferenceParams): Promise<Location[]> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return [];\n  }\n\n  const position = params.position;\n  const word = getWordAtPosition(document.getText(), position);\n\n  if (!word) {\n    return [];\n  }\n\n  const locations: Location[] = [];\n\n  // Search in current document\n  const text = document.getText();\n  const lines = text.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const regex = new RegExp(`\\\\b${word}\\\\b`, 'g');\n    let match;\n\n    while ((match = regex.exec(line)) !== null) {\n      locations.push({\n        uri: document.uri,\n        range: {\n          start: { line: i, character: match.index },\n          end: { line: i, character: match.index + word.length },\n        },\n      });\n    }\n  }\n\n  return locations;\n});\n\n// Document highlight provider\nconnection.onDocumentHighlight(\n  async (params: DocumentHighlightParams): Promise<DocumentHighlight[]> => {\n    const document = documents.get(params.textDocument.uri);\n    if (!document) {\n      return [];\n    }\n\n    const position = params.position;\n    const word = getWordAtPosition(document.getText(), position);\n\n    if (!word) {\n      return [];\n    }\n\n    const highlights: DocumentHighlight[] = [];\n    const text = document.getText();\n    const lines = text.split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const regex = new RegExp(`\\\\b${word}\\\\b`, 'g');\n      let match;\n\n      while ((match = regex.exec(line)) !== null) {\n        highlights.push({\n          range: {\n            start: { line: i, character: match.index },\n            end: { line: i, character: match.index + word.length },\n          },\n          kind: DocumentHighlightKind.Text,\n        });\n      }\n    }\n\n    return highlights;\n  }\n);\n\n// Signature help provider\nconnection.onSignatureHelp(async (params: SignatureHelpParams): Promise<SignatureHelp | null> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return null;\n  }\n\n  const position = params.position;\n  const text = document.getText();\n  const line = text.split('\\n')[position.line];\n\n  // Find the predicate being called\n  const beforeCursor = line.substring(0, position.character);\n  const predicateMatch = beforeCursor.match(/([a-z][a-zA-Z0-9_]*)\\s*\\([^)]*$/);\n\n  if (!predicateMatch) {\n    return null;\n  }\n\n  const predicate = predicateMatch[1];\n\n  // Get signature information\n  const signature = getPredicateSignature(predicate);\n  if (!signature) {\n    return null;\n  }\n\n  // Count current parameter\n  const openParen = beforeCursor.lastIndexOf('(');\n  const args = beforeCursor.substring(openParen + 1);\n  const parameterIndex = args.split(',').length - 1;\n\n  return {\n    signatures: [signature],\n    activeSignature: 0,\n    activeParameter: Math.min(parameterIndex, signature.parameters.length - 1),\n  };\n});\n\nfunction getPredicateSignature(predicate: string): SignatureInformation | null {\n  const signatures: Record<string, SignatureInformation> = {\n    member: {\n      label: 'member(Elem, List)',\n      documentation: 'True if Elem is a member of List',\n      parameters: [\n        { label: 'Elem', documentation: 'Element to check' },\n        { label: 'List', documentation: 'List to search in' },\n      ],\n    },\n    append: {\n      label: 'append(List1, List2, List3)',\n      documentation: 'True if List3 is the concatenation of List1 and List2',\n      parameters: [\n        { label: 'List1', documentation: 'First list' },\n        { label: 'List2', documentation: 'Second list' },\n        { label: 'List3', documentation: 'Concatenated result' },\n      ],\n    },\n    findall: {\n      label: 'findall(Template, Goal, List)',\n      documentation: 'Find all solutions to Goal',\n      parameters: [\n        { label: 'Template', documentation: 'Template for solutions' },\n        { label: 'Goal', documentation: 'Goal to solve' },\n        { label: 'List', documentation: 'List of solutions' },\n      ],\n    },\n  };\n\n  return signatures[predicate] || null;\n}\n\n// Document formatting provider\nconnection.onDocumentFormatting(async (params: DocumentFormattingParams): Promise<TextEdit[]> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return [];\n  }\n\n  return await formatPrologDocument(document);\n});\n\nconnection.onDocumentRangeFormatting(\n  async (params: DocumentRangeFormattingParams): Promise<TextEdit[]> => {\n    const document = documents.get(params.textDocument.uri);\n    if (!document) {\n      return [];\n    }\n\n    return await formatPrologDocumentRange(document, params.range);\n  }\n);\n\nasync function formatPrologDocument(document: TextDocument): Promise<TextEdit[]> {\n  const settings = await getDocumentSettings(document.uri);\n  const text = document.getText();\n  const lines = text.split('\\n');\n  const edits: TextEdit[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const formatted = formatPrologLine(line, settings);\n\n    if (formatted !== line) {\n      edits.push({\n        range: {\n          start: { line: i, character: 0 },\n          end: { line: i, character: line.length },\n        },\n        newText: formatted,\n      });\n    }\n  }\n\n  return edits;\n}\n\nasync function formatPrologDocumentRange(\n  document: TextDocument,\n  range: Range\n): Promise<TextEdit[]> {\n  const settings = await getDocumentSettings(document.uri);\n  const text = document.getText(range);\n  const lines = text.split('\\n');\n  const edits: TextEdit[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const formatted = formatPrologLine(line, settings);\n\n    if (formatted !== line) {\n      edits.push({\n        range: {\n          start: { line: range.start.line + i, character: 0 },\n          end: { line: range.start.line + i, character: line.length },\n        },\n        newText: formatted,\n      });\n    }\n  }\n\n  return edits;\n}\n\nfunction formatPrologLine(line: string, settings: PrologSettings): string {\n  let formatted = line;\n\n  // Add spaces after commas if enabled\n  if (settings.format.addSpace) {\n    formatted = formatted.replace(/,(?!\\s)/g, ', ');\n  }\n\n  // Basic indentation for clauses\n  const trimmed = formatted.trim();\n  if (trimmed.startsWith(':-') || trimmed.startsWith('?-')) {\n    // Directives and queries - no extra indentation\n    return trimmed;\n  } else if (trimmed.includes(':-')) {\n    // Rules - no extra indentation for head\n    return trimmed;\n  } else if (trimmed.match(/^\\s*[a-z]/)) {\n    // Facts - no extra indentation\n    return trimmed;\n  }\n\n  return formatted;\n}\n\nasync function organizeImports(document: TextDocument): Promise<TextEdit[]> {\n  const text = document.getText();\n  const lines = text.split('\\n');\n  const imports: string[] = [];\n  const otherLines: string[] = [];\n  const edits: TextEdit[] = [];\n\n  // Separate imports from other content\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (trimmed.startsWith(':- use_module(') || trimmed.startsWith(':- include(')) {\n      imports.push(line);\n    } else {\n      otherLines.push(line);\n    }\n  }\n\n  // Sort imports\n  imports.sort();\n\n  // Create new content\n  const newContent = [...imports, '', ...otherLines].join('\\n');\n\n  if (newContent !== text) {\n    edits.push({\n      range: {\n        start: { line: 0, character: 0 },\n        end: { line: lines.length - 1, character: lines[lines.length - 1].length },\n      },\n      newText: newContent,\n    });\n  }\n\n  return edits;\n}\n\n// Rename provider\nconnection.onPrepareRename(async (params: PrepareRenameParams): Promise<Range | null> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return null;\n  }\n\n  const position = params.position;\n  const word = getWordAtPosition(document.getText(), position);\n\n  if (!word || !/^[a-z][a-zA-Z0-9_]*$/.test(word)) {\n    return null;\n  }\n\n  const line = document.getText().split('\\n')[position.line];\n  const start = line.indexOf(word, position.character - word.length);\n\n  return {\n    start: { line: position.line, character: start },\n    end: { line: position.line, character: start + word.length },\n  };\n});\n\nconnection.onRenameRequest(async (params: RenameParams): Promise<WorkspaceEdit | null> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return null;\n  }\n\n  const position = params.position;\n  const oldName = getWordAtPosition(document.getText(), position);\n  const newName = params.newName;\n\n  if (!oldName || !newName) {\n    return null;\n  }\n\n  const changes: { [uri: string]: TextEdit[] } = {};\n  const text = document.getText();\n  const lines = text.split('\\n');\n  const edits: TextEdit[] = [];\n\n  // Find all occurrences in the document\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const regex = new RegExp(`\\\\b${oldName}\\\\b`, 'g');\n    let match;\n\n    while ((match = regex.exec(line)) !== null) {\n      edits.push({\n        range: {\n          start: { line: i, character: match.index },\n          end: { line: i, character: match.index + oldName.length },\n        },\n        newText: newName,\n      });\n    }\n  }\n\n  changes[document.uri] = edits;\n\n  return { changes };\n});\n\n// Folding range provider\nconnection.onFoldingRanges(async (params: FoldingRangeParams): Promise<FoldingRange[]> => {\n  const document = documents.get(params.textDocument.uri);\n  if (!document) {\n    return [];\n  }\n\n  const ranges: FoldingRange[] = [];\n  const text = document.getText();\n  const lines = text.split('\\n');\n\n  let commentStart = -1;\n  let ruleStart = -1;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Handle comment blocks\n    if (line.startsWith('/*')) {\n      commentStart = i;\n    } else if (line.endsWith('*/') && commentStart >= 0) {\n      ranges.push({\n        startLine: commentStart,\n        endLine: i,\n        kind: FoldingRangeKind.Comment,\n      });\n      commentStart = -1;\n    }\n\n    // Handle multi-line rules\n    if (line.includes(':-') && !line.endsWith('.')) {\n      ruleStart = i;\n    } else if (ruleStart >= 0 && line.endsWith('.')) {\n      if (i > ruleStart) {\n        ranges.push({\n          startLine: ruleStart,\n          endLine: i,\n        });\n      }\n      ruleStart = -1;\n    }\n  }\n\n  return ranges;\n});\n\n// Semantic tokens provider\nconnection.onRequest(\n  'textDocument/semanticTokens/full',\n  async (params: SemanticTokensParams): Promise<SemanticTokens> => {\n    const document = documents.get(params.textDocument.uri);\n    if (!document) {\n      return { data: [] };\n    }\n\n    const builder = new SemanticTokensBuilder(semanticTokensLegend);\n    const text = document.getText();\n    const lines = text.split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n\n      // Tokenize the line\n      tokenizePrologLine(line, i, builder);\n    }\n\n    return builder.build();\n  }\n);\n\nfunction tokenizePrologLine(line: string, lineNumber: number, builder: SemanticTokensBuilder) {\n  // Comments\n  const commentMatch = line.match(/%.*$/);\n  if (commentMatch) {\n    const start = line.indexOf(commentMatch[0]);\n    builder.push(lineNumber, start, commentMatch[0].length, 17, 0); // comment token\n  }\n\n  // Strings\n  const stringRegex = /'([^'\\\\]|\\\\.)*'|\"([^\"\\\\]|\\\\.)*\"/g;\n  let stringMatch;\n  while ((stringMatch = stringRegex.exec(line)) !== null) {\n    builder.push(lineNumber, stringMatch.index, stringMatch[0].length, 18, 0); // string token\n  }\n\n  // Numbers\n  const numberRegex = /\\b\\d+(\\.\\d+)?\\b/g;\n  let numberMatch;\n  while ((numberMatch = numberRegex.exec(line)) !== null) {\n    builder.push(lineNumber, numberMatch.index, numberMatch[0].length, 19, 0); // number token\n  }\n\n  // Predicates\n  const predicateRegex = /\\b[a-z][a-zA-Z0-9_]*(?=\\s*\\()/g;\n  let predicateMatch;\n  while ((predicateMatch = predicateRegex.exec(line)) !== null) {\n    builder.push(lineNumber, predicateMatch.index, predicateMatch[0].length, 12, 0); // function token\n  }\n\n  // Variables\n  const variableRegex = /\\b[A-Z_][a-zA-Z0-9_]*\\b/g;\n  let variableMatch;\n  while ((variableMatch = variableRegex.exec(line)) !== null) {\n    builder.push(lineNumber, variableMatch.index, variableMatch[0].length, 8, 0); // variable token\n  }\n\n  // Operators\n  const operatorRegex = /:-|->|;|,|\\+|-|\\*|\\/|=|\\\\=|==|\\\\==|@<|@>|@=<|@>=/g;\n  let operatorMatch;\n  while ((operatorMatch = operatorRegex.exec(line)) !== null) {\n    builder.push(lineNumber, operatorMatch.index, operatorMatch[0].length, 21, 0); // operator token\n  }\n}\n\n// Additional LSP features can be added here...\n\n// Make the text document manager listen on the connection\n// for open, change and close text document events\ndocuments.listen(connection);\n\n// Listen on the connection\nconnection.listen();\n\nexport { connection, documents, prologBackend };\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologLinter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pred' is assigned a value but never used.","line":191,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":191,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":717,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":717,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import jsesc from 'jsesc';\nimport { spawn } from 'process-promises';\nimport {\n  CancellationToken,\n  CodeActionContext,\n  CodeActionProvider,\n  Command,\n  commands,\n  Diagnostic,\n  DiagnosticCollection,\n  DiagnosticSeverity,\n  Disposable,\n  ExtensionContext,\n  languages,\n  OutputChannel,\n  Position,\n  Range,\n  Selection,\n  TextDocument,\n  TextEditorRevealType,\n  Uri,\n  window,\n  workspace,\n  WorkspaceEdit,\n} from 'vscode';\nimport { Utils, IPredicate } from '../utils/utils';\nimport fg from 'fast-glob';\nimport * as path from 'path';\nimport * as which from 'which';\nimport { InstallationGuide } from './installationGuide';\nimport { PlatformUtils } from '../utils/platformUtils';\nimport { ExecutableFinder } from '../utils/executableFinder';\n\n// Enum for different triggers that can run the linter\nexport enum RunTrigger {\n  onType,\n  onSave,\n  never,\n}\n// Main class for the Prolog Linter, implementing CodeActionProvider\nexport default class PrologLinter implements CodeActionProvider {\n  private commandAddDynamic: Disposable;\n  private commandAddDynamicId: string;\n  private commandAddUseModule: Disposable;\n  private commandAddUseModuleId: string;\n  private commandExportPredicate!: Disposable;\n  private commandExportPredicateId!: string;\n\n  private diagnosticCollection!: DiagnosticCollection;\n  private diagnostics: { [docName: string]: Diagnostic[] } = {};\n  private filePathIds: { [id: string]: string } = {};\n  private sortedDiagIndex: { [docName: string]: number[] } = {};\n  // Regular expression to parse SWI-Prolog errors and warnings\n  private swiRegex = /([^:]+?):\\s*(.+?):(\\d+):((\\d+):)?((\\d+):)?\\s*([\\s\\S]*)/;\n  // Configuration parameters\n  private executable!: string;\n  private trigger!: RunTrigger;\n  private timer: ReturnType<typeof setTimeout> | null = null;\n  private delay!: number;\n  private documentListener!: Disposable;\n  private openDocumentListener!: Disposable;\n  private outputChannel: OutputChannel | null = null;\n  private enableOutput: boolean = false;\n\n  constructor(private context: ExtensionContext) {\n    this.executable = '';\n    // dynamically declare a predicate as dynamic in Prolog code. Dynamic predicates are those whose clauses can be modified at runtime.\n    this.commandAddDynamicId = 'prolog.addDynamicDirective';\n    this.commandAddDynamic = commands.registerCommand(\n      this.commandAddDynamicId,\n      this.addDynamicDirective,\n      this\n    );\n    // include a Prolog module in the code\n    this.commandAddUseModuleId = 'prolog.addUseModule';\n    this.commandAddUseModule = commands.registerCommand(\n      this.commandAddUseModuleId,\n      this.addUseModule,\n      this\n    );\n    // facilitate the process of exporting a predicate, making it visible to other Prolog modules\n    /*\n    this.commandExportPredicateId = \"prolog.exportPredicate\";\n    this.commandExportPredicate = commands.registerCommand(\n      this.commandExportPredicateId,\n      this.exportPredicateUnderCursor,\n      this\n    );*/\n    // Get configuration settings from VS Code\n    this.enableOutput =\n      workspace.getConfiguration('prolog').get<boolean>('linter.enableMsgInOutput') ?? false;\n  }\n  // Method to get lines where a directive should be added based on predicate and range\n  private getDirectiveLines(\n    doc: TextDocument,\n    declarativePredicate: string,\n    range: Range\n  ): number[] {\n    const textlines: string[] = doc.getText().split('\\n'); // Split the document text into lines\n    const re = new RegExp('^\\\\s*:-\\\\s+\\\\(?\\\\s*' + declarativePredicate + '\\\\b'); // Regular expression to match the declarative predicate directive\n    let lines: number[] = [];\n    let line = 0;\n    while (line < textlines.length) {\n      // Iterate through each line in the document\n      if (re.test(textlines[line] || '')) {\n        lines = lines.concat(line);\n      }\n      line++;\n    }\n    // If lines with the directive are found, return the array of line numbers\n    if (lines.length > 0) {\n      return lines;\n    }\n\n    line = -1;\n    // Find the first line starting with \":-\"\n    textlines.filter((item, index) => {\n      if (/^\\s*:-/.test(item)) {\n        line = index;\n        return true;\n      }\n    });\n    // Continue iterating to find the end of the directive or the end of the document\n    while (line >= 0 && line < textlines.length && !/.+\\.(\\s*%.*)*/.test(textlines[line] || '')) {\n      line++;\n    }\n    // If the line is before the specified range, return an array with the next line\n    if (line >= 0 && line < range.start.line) {\n      return [++line];\n    }\n\n    line = 0;\n    // Check for the presence of a comment block at the beginning of the document\n    let inComment = /\\s*\\/\\*/.test(textlines[0]);\n    // Continue iterating until the end of the comment block is found\n    while (inComment && line < textlines.length) {\n      if (/\\*\\//.test(textlines[line] || '')) {\n        inComment = false;\n        line++;\n        break;\n      }\n      line++;\n    }\n    // Return an array with the line number after the comment block\n    return [line];\n  }\n\n  // Method to add a dynamic directive to the document\n  private addDynamicDirective(\n    doc: TextDocument,\n    predicate: string, //the predicate for which the 'dynamic' directive is being added\n    uri: Uri,\n    range: Range\n  ): Promise<boolean> {\n    const edit = new WorkspaceEdit(); // Initialize a WorkspaceEdit for making changes to the document\n    const line = this.getDirectiveLines(doc, 'dynamic', range)[0]; // Get the line number where the 'dynamic' directive should be added\n\n    const text = doc.lineAt(line || 0).text; // Extract the current line text\n    let pos: Position; // Position to insert the 'dynamic' declaration\n    // Check if an existing 'dynamic' declaration is present\n    if (/:-\\s+\\(?dynamic/.test(text)) {\n      // If present, find the start character of the list and position the cursor after it\n      const startChar = text.indexOf('dynamic') + 7;\n      pos = new Position(line || 0, startChar);\n      edit.insert(uri, pos, ' ' + predicate + ','); // Insert the predicate into the existing 'dynamic' declaration list\n    } else {\n      // If not present, insert a new 'dynamic' declaration with the specified predicate\n      pos = new Position(line || 0, 0);\n      edit.insert(uri, pos, ':- dynamic ' + predicate + '.\\n');\n    }\n    // Apply the WorkspaceEdit to the document\n    let result: Promise<boolean> | null = null;\n    try {\n      result = workspace.applyEdit(edit);\n    } catch (e) {\n      console.log('Error in add dynamic declaration: ' + e);\n    }\n    return result;\n  }\n\n  // Method to add a \"use_module\" directive to the document\n  private addUseModule(\n    doc: TextDocument,\n    predicate: string, // The predicate for which the 'use_module' directive is being added\n    module: string, // The module to be used in the 'use_module' directive\n    uri: Uri,\n    range: Range\n  ): Promise<boolean> {\n    const edit = new WorkspaceEdit(); // Initialize a WorkspaceEdit for making changes to the document\n    const lines = this.getDirectiveLines(doc, 'use_module', range); // Get the lines where the 'use_module' directive is defined\n    const pred: string = predicate.match(/(.+)\\/\\d+/)?.[1] || predicate; // Extract the base predicate without arity\n    const re = new RegExp('^:-\\\\s+use_module\\\\s*\\\\(\\\\s*.+\\\\b' + module + '\\\\b'); // Regular expression to match an existing 'use_module' directive with the specified module\n    let directiveLine: number = -1;\n    let pos: Position;\n    // Iterate through the lines to find an existing 'use_module' directive with the specified module\n    lines.forEach(line => {\n      if (re.test(doc.lineAt(line).text)) {\n        directiveLine = line;\n      }\n    });\n    // If an existing directive is found, add the predicate to the existing list\n    if (directiveLine >= 0) {\n      let line = directiveLine;\n      // Move down to find the position where the predicate should be added\n      while (doc.lineAt(line).text.indexOf('[') < 0) line++;\n      // Find the start character of the list and position the cursor after it\n      const startChar = doc.lineAt(line).text.indexOf('[');\n      pos = new Position(line, startChar + 1);\n      edit.insert(uri, pos, predicate + ','); // Insert the predicate into the list\n    } else {\n      // If no existing directive is found, add a new 'use_module' directive\n      pos = new Position(lines[lines.length - 1], 0);\n      edit.insert(uri, pos, `:- use_module(library(${module}), [${predicate}]).\\n`);\n    }\n    // Apply the WorkspaceEdit to the document\n    let result: Promise<boolean>;\n    try {\n      result = workspace.applyEdit(edit);\n    } catch (e) {\n      console.log('Error in add dynamic declaration: ' + e);\n    }\n    return result;\n  }\n\n  // Implementation of CodeActionProvider interface method\n  provideCodeActions(\n    document: TextDocument,\n    range: Range,\n    context: CodeActionContext,\n    _token: CancellationToken\n  ): Command[] | Promise<Command[]> {\n    const codeActions: Command[] = []; // Initialize an array to store the generated code actions\n    // Iterate through each diagnostic in the context\n    context.diagnostics.forEach(diagnostic => {\n      const regex = /Predicate (.+) not defined/;\n      let match = diagnostic.message.match(regex);\n      // Check if a match is found in the diagnostic message\n      if (match[1]) {\n        let pred = match[1];\n        // Get modules associated with the predicate using utility function\n        const modules = Utils.getPredModules(pred);\n        // Check if modules are found for the predicate\n        if (modules.length > 0) {\n          // Generate code actions for each module and add them to the array\n          modules.forEach(module => {\n            codeActions.push({\n              title: \"Add ':- use_module(library(\" + module + '), [' + pred + \"]).'\",\n              command: this.commandAddUseModuleId,\n              arguments: [document, pred, module, document.uri, diagnostic.range],\n            });\n          });\n        }\n        // Extract module information from the document\n        match = document.getText().match(/:-\\s*module\\((\\w+),/);\n        let module: string = '';\n        if (match) {\n          module = match[1];\n        }\n        // Handle predicates with namespace (module)\n        if (pred.indexOf(':') > -1) {\n          const [mod, pred1] = pred.split(':');\n          if (mod === module) {\n            pred = pred1;\n          }\n        }\n        // Generate code action for adding 'dynamic' directive and add it to the array\n        codeActions.push({\n          title: \"Add ':- dynamic \" + pred + \".'\",\n          command: this.commandAddDynamicId,\n          arguments: [document, pred, document.uri, diagnostic.range],\n        });\n      }\n    });\n    return codeActions; //An array of CodeAction commands or a Promise that resolves to an array of CodeAction commands\n  }\n\n  // Method to parse an issue string obtained from the linter output\n  private parseIssue(issue: string) {\n    // Use regular expression to match different components of the issue\n    const match = issue.match(this.swiRegex);\n\n    // Check if a match is found\n    if (match == null) return null;\n\n    // Extract relevant information from the match\n    const fileName = this.filePathIds[match[2]] ? this.filePathIds[match[2]] : match[2];\n    let severity: DiagnosticSeverity;\n\n    // Determine severity based on the issue type\n    if (match[1] == 'ERROR') severity = DiagnosticSeverity.Error;\n    else if (match[1] == 'Warning') severity = DiagnosticSeverity.Warning;\n\n    // Parse line, column, and error message information\n    const line = parseInt(match[3]) - 1;\n    let fromCol = match[5] ? parseInt(match[5]) : 0;\n    fromCol = fromCol < 0 ? 0 : fromCol;\n    const toCol = match[7] ? parseInt(match[7]) : 200;\n    const fromPos = new Position(line, fromCol);\n    const toPos = new Position(line, toCol);\n    const range = new Range(fromPos, toPos);\n    const errMsg = match[8];\n\n    // Create a new Diagnostic object\n    const diag = new Diagnostic(range, errMsg, severity);\n\n    // Add the Diagnostic object to the diagnostics collection\n    if (diag) {\n      if (!this.diagnostics[fileName]) {\n        this.diagnostics[fileName] = [diag];\n      } else {\n        this.diagnostics[fileName].push(diag);\n      }\n    }\n  }\n\n  // Method to perform linting of a Prolog file\n  private doPlint(textDocument: TextDocument) {\n    // Check if the language of the document is Prolog\n    if (textDocument.languageId != 'prolog') {\n      return;\n    }\n\n    // Initialize diagnostic-related data structures\n    this.diagnostics = {};\n    this.sortedDiagIndex = {};\n    this.diagnosticCollection.delete(textDocument.uri);\n\n    // Configure options for executing Prolog\n    const options = workspace.workspaceFolders[0].uri.fsPath\n      ? { cwd: workspace.workspaceFolders[0].uri.fsPath }\n      : undefined;\n\n    // Initialize arguments, goals, and other variables\n    let args: string[] = [];\n    let goals: string = '';\n    let lineErr: string = '';\n    const docTxt = textDocument.getText();\n    const docTxtEsced = jsesc(docTxt, { quotes: 'double' });\n    const fname = jsesc(PlatformUtils.toAbsolute(textDocument.fileName));\n\n    // Determine Prolog dialect and set arguments accordingly\n    switch (Utils.DIALECT) {\n      case 'swi': {\n        if (this.trigger === RunTrigger.onSave) {\n          args = ['-g', 'halt', fname];\n        }\n        if (this.trigger === RunTrigger.onType) {\n          args = ['-q'];\n          goals = `\n            open_string(\"${docTxtEsced}\", S),\n            load_files('${fname}', [stream(S),if(true)]).\n            list_undefined.\n          `;\n        }\n        break;\n      }\n      case 'ecl': {\n        const dir = jsesc(path.resolve(`${this.context.extensionPath}/out/src/features`));\n        if (this.trigger === RunTrigger.onSave) {\n          const fdir = path.dirname(fname);\n          const file = path.basename(fname);\n          goals = `(cd(\"${dir}\"),\n          use_module('load_modules'),\n          cd(\"${fdir}\"),\n          load_modules_from_file('${file}'),\n          compile('${file}', [debug:off]),halt)`;\n          args = ['-e', goals];\n        }\n        if (this.trigger === RunTrigger.onType) {\n          goals = `(cd(\"${dir}\"),\n          use_module(load_modules),\n          load_modules_from_text(\"${docTxtEsced}\"),\n          open(string(\"${docTxtEsced}\"), read, S),\n          compile(stream(S), [debug:off]),\n          close(S),halt)`;\n          args = ['-e', goals];\n        }\n        break;\n      }\n      default:\n        break;\n    }\n\n    // Execute the Prolog process\n    spawn(this.executable, args, options)\n      .on('process', process => {\n        // Handle the Prolog process\n        if (process.pid) {\n          if (this.trigger === RunTrigger.onType) {\n            process.stdin.write(goals);\n            process.stdin.end();\n          }\n          if (this.enableOutput) {\n            this.outputChannel.clear();\n          }\n        }\n      })\n      .on('stdout', out => {\n        // Handle standard output\n        if (Utils.DIALECT === 'ecl' && !/checking completed/.test(out)) {\n          if (/^File\\s*/.test(out)) {\n            if (lineErr) {\n              this.parseIssue(lineErr + '\\n');\n              lineErr = '';\n            }\n            const match = out.match(/File\\s*([^,]+),.*line\\s*(\\d+):\\s*(.*)/);\n            let fullName: string;\n            if (match[1] === 'string') {\n              fullName = textDocument.fileName;\n            } else {\n              // Use fast-glob to find the file matching the pattern\n              const files = fg.sync([`**/${match[1]}`], {\n                cwd: workspace.workspaceFolders[0].uri.fsPath,\n                absolute: true,\n              });\n              fullName = files.length > 0 ? files[0] : match[1];\n            }\n            lineErr = 'Warning:' + fullName + ':' + match[2] + ':' + match[3];\n          } else if (/^|/.test(out)) {\n            lineErr += out;\n          } else if (/WARNING/.test(out) && this.enableOutput) {\n            this.outputMsg(out);\n          }\n        }\n      })\n      .on('stderr', (errStr: string) => {\n        // Handle standard error\n        switch (Utils.DIALECT) {\n          case 'swi': {\n            if (/which is referenced by/.test(errStr)) {\n              const regex = /Warning:\\s*(.+),/;\n              const match = errStr.match(regex);\n              lineErr = ' Predicate ' + match[1] + ' not defined';\n            } else if (/clause of /.test(errStr)) {\n              const regex = /^(Warning:\\s*(.+?):)(\\d+):(\\d+)?/;\n              const match = errStr.match(regex);\n              const line = parseInt(match[3]);\n              const char = match[4] ? parseInt(match[4]) : 0;\n              const rangeStr = line + ':' + char + ':200: ';\n              const lineMsg = match[1] + rangeStr + lineErr;\n              this.parseIssue(lineMsg + '\\n');\n            } else if (/:\\s*$/.test(errStr)) {\n              lineErr = errStr;\n            } else {\n              if (errStr.startsWith('ERROR') || errStr.startsWith('Warning')) {\n                lineErr = errStr;\n              } else {\n                lineErr = lineErr.concat(errStr);\n              }\n              this.parseIssue(lineErr + '\\n');\n              lineErr = '';\n            }\n            break;\n          }\n          case 'ecl': {\n            if (this.enableOutput) {\n              this.outputChannel.clear();\n            }\n            if (/^[fF]ile|^string stream|^Stream/.test(errStr)) {\n              if (lineErr !== '') {\n                this.parseIssue(lineErr + '\\n');\n                if (this.enableOutput) {\n                  this.outputMsg(lineErr);\n                }\n                lineErr = '';\n              }\n              let fullName: string, line: string, msg: string;\n              let match = errStr.match(/[fF]ile\\s*([^,]+),\\s*line\\s*(\\d+):\\s*(.*)/);\n\n              if (match) {\n                // Use fast-glob to find the file matching the pattern\n                const files = fg.sync([`**/${match[1]}`], {\n                  cwd: workspace.workspaceFolders[0].uri.fsPath,\n                  absolute: true,\n                });\n                fullName = files.length > 0 ? files[0] : match[1];\n                line = match[2];\n                msg = match[3];\n              } else {\n                fullName = textDocument.fileName;\n                match = errStr.match(/line\\s*(\\d+):\\s*(.*)/);\n                if (!match) {\n                  match = errStr.match(/:(\\d+):\\s*(.*)/);\n                }\n                line = match[1];\n                msg = match[2];\n              }\n              const msgType = /error:|[sS]tream/.test(lineErr) ? 'ERROR:' : 'WARNING:';\n              lineErr = msgType + fullName + ':' + line + ':' + msg;\n            } else if (!/^\\s*$/.test(errStr)) {\n              lineErr += '\\n' + errStr;\n            }\n            break;\n          }\n          default: {\n            break;\n          }\n        }\n      })\n      .then(_result => {\n        // Handle the completion of the Prolog process\n        if (lineErr !== '') {\n          this.parseIssue(lineErr + '\\n');\n          lineErr = '';\n        }\n        for (const doc in this.diagnostics) {\n          const index = this.diagnostics[doc]\n            .map((diag, i) => {\n              return [diag.range.start.line, i];\n            })\n            .sort((a, b) => {\n              return a[0] - b[0];\n            });\n          this.sortedDiagIndex[doc] = index.map(item => {\n            return item[1];\n          });\n          this.diagnosticCollection.set(Uri.file(doc), this.diagnostics[doc]);\n        }\n        if (this.enableOutput) {\n          this.outputChannel.clear();\n        }\n        for (const doc in this.sortedDiagIndex) {\n          const si = this.sortedDiagIndex[doc];\n          for (let i = 0; i < si.length; i++) {\n            const diag = this.diagnostics[doc][si[i]];\n            const severity = diag.severity === DiagnosticSeverity.Error ? 'ERROR' : 'Warning';\n            const msg = `${path.basename(doc)}:${\n              diag.range.start.line + 1\n            }:\\t${severity}:\\t${diag.message}\\n`;\n            if (this.enableOutput) {\n              this.outputChannel.append(msg);\n            }\n          }\n          if (si.length > 0 && this.enableOutput) {\n            this.outputChannel.show(true);\n          }\n        }\n      })\n      .catch(async error => {\n        // Handle error event\n        let message: string = null;\n        if (error.code === 'ENOENT') {\n          message =\n            \"Cannot lint the prolog file. The Prolog executable was not found. Use the 'prolog.executablePath' setting to configure\";\n\n          // Show enhanced error message with installation guidance\n          const action = await window.showErrorMessage(\n            'SWI-Prolog executable not found. The linter requires SWI-Prolog to check your code for errors and warnings.',\n            'Install SWI-Prolog',\n            'Setup Wizard',\n            'Configure Path',\n            'Dismiss'\n          );\n\n          const installationGuide = InstallationGuide.getInstance();\n          switch (action) {\n            case 'Install SWI-Prolog': {\n              await installationGuide.showInstallationGuideDialog();\n              break;\n            }\n            case 'Setup Wizard': {\n              await commands.executeCommand('prolog.setupWizard');\n              break;\n            }\n            case 'Configure Path': {\n              await commands.executeCommand(\n                'workbench.action.openSettings',\n                'prolog.executablePath'\n              );\n              break;\n            }\n            default:\n              break;\n          }\n        } else {\n          message = error.message\n            ? error.message\n            : `Failed to run prolog executable using path: ${this.executable}. Reason is unknown.`;\n        }\n        this.outputMsg(message);\n      });\n  }\n\n  // Method to load configuration settings\n  private async loadConfiguration(): Promise<void> {\n    // Get the configuration section for the Prolog extension\n    const section = workspace.getConfiguration('prolog');\n    // Check if the configuration section is available\n    if (section) {\n      this.executable = await this.resolveExecutablePath(section);\n      // Determine the trigger type for the linter (onSave, onType, never)\n      if (Utils.LINTERTRIGGER === 'onSave') {\n        this.trigger = RunTrigger.onSave;\n      } else if (Utils.LINTERTRIGGER === 'onType') {\n        this.trigger = RunTrigger.onType;\n      } else {\n        this.trigger = RunTrigger.never;\n      }\n      // Dispose existing document and open document listeners if they exist\n      if (this.documentListener) {\n        this.documentListener.dispose();\n      }\n      if (this.openDocumentListener) {\n        this.openDocumentListener.dispose();\n      }\n    }\n    // Set up a listener for changes in the open text documents\n    this.openDocumentListener = workspace.onDidOpenTextDocument(e => {\n      this.triggerLinter(e);\n    });\n    // If the linter is triggered on type, set up a listener for document changes\n    if (this.trigger === RunTrigger.onType) {\n      this.delay = section.get<number>('linter.delay');\n      this.documentListener = workspace.onDidChangeTextDocument(e => {\n        this.triggerLinter(e.document);\n      });\n    } else {\n      // If the linter is triggered on save or never, set up a listener for document save\n      if (this.timer) {\n        clearTimeout(this.timer);\n      }\n      this.documentListener = workspace.onDidSaveTextDocument(this.doPlint, this);\n    }\n    // Trigger linting for existing text documents\n    workspace.textDocuments.forEach(this.triggerLinter, this);\n  }\n\n  /**\n   * Resolve the executable path with enhanced validation and permission checking\n   */\n  private async resolveExecutablePath(section: workspace.WorkspaceConfiguration): Promise<string> {\n    const configuredPath = section.get<string>(\n      'executablePath',\n      PlatformUtils.getDefaultExecutablePath()\n    );\n\n    // First try the configured path\n    if (configuredPath && configuredPath !== PlatformUtils.getDefaultExecutablePath()) {\n      const normalizedPath = PlatformUtils.normalizePath(configuredPath);\n\n      // Check if the configured path exists and has proper permissions\n      if (await PlatformUtils.pathExists(normalizedPath)) {\n        if (await PlatformUtils.isExecutable(normalizedPath)) {\n          return normalizedPath;\n        } else {\n          // Path exists but is not executable - show permission error\n          const platform = PlatformUtils.getPlatform();\n          let permissionFix = '';\n          if (platform !== 'windows') {\n            permissionFix = `\\n\\nTry fixing permissions with: chmod +x \"${normalizedPath}\"`;\n          }\n\n          window\n            .showWarningMessage(\n              `SWI-Prolog executable at '${normalizedPath}' exists but lacks execute permissions.${permissionFix}`,\n              'Fix Permissions',\n              'Choose Different Path'\n            )\n            .then(async action => {\n              if (action === 'Fix Permissions' && platform !== 'windows') {\n                // On Unix systems, suggest the chmod command\n                const terminal = window.createTerminal('Fix Prolog Permissions');\n                terminal.sendText(`chmod +x \"${normalizedPath}\"`);\n                terminal.show();\n              } else if (action === 'Choose Different Path') {\n                await commands.executeCommand(\n                  'workbench.action.openSettings',\n                  'prolog.executablePath'\n                );\n              }\n            });\n        }\n      }\n    }\n\n    // Try to find executable using comprehensive detection\n    const executableFinder = new ExecutableFinder();\n    const detectionResult = await executableFinder.findSwiplExecutable();\n\n    if (detectionResult.found && detectionResult.path) {\n      // Check permissions on the found executable\n      if (detectionResult.permissions?.executable) {\n        return detectionResult.path;\n      } else {\n        // Found executable but has permission issues\n        const platform = PlatformUtils.getPlatform();\n        let permissionFix = '';\n        if (platform !== 'windows') {\n          permissionFix = `\\n\\nTry fixing permissions with: chmod +x \"${detectionResult.path}\"`;\n        }\n\n        window\n          .showWarningMessage(\n            `Found SWI-Prolog at '${detectionResult.path}' but it lacks execute permissions.${permissionFix}`,\n            'Fix Permissions',\n            'Install SWI-Prolog'\n          )\n          .then(async action => {\n            if (action === 'Fix Permissions' && platform !== 'windows') {\n              const terminal = window.createTerminal('Fix Prolog Permissions');\n              terminal.sendText(`chmod +x \"${detectionResult.path}\"`);\n              terminal.show();\n            } else if (action === 'Install SWI-Prolog') {\n              const installationGuide = InstallationGuide.getInstance();\n              await installationGuide.showInstallationGuideDialog();\n            }\n          });\n\n        return detectionResult.path; // Return the path anyway, the spawn will fail with a better error\n      }\n    }\n\n    // Fallback to the configured path or default, even if it might not work\n    try {\n      const fallbackPath = which.sync(configuredPath);\n      return fallbackPath;\n    } catch (_e) {\n      return PlatformUtils.normalizePath(configuredPath);\n    }\n  }\n\n  // Method to trigger linting based on various events\n  private triggerLinter(textDocument: TextDocument) {\n    // Check if the document is a Prolog source file\n    if (textDocument.languageId !== 'prolog') {\n      return;\n    }\n    // If the linter is set to trigger on type and there's a delay configured,use a timer to wait for typing to settle before linting\n    if (this.trigger === RunTrigger.onType) {\n      if (this.timer) {\n        clearTimeout(this.timer);\n      }\n      this.timer = setTimeout(() => {\n        this.doPlint(textDocument);\n      }, this.delay);\n    } else if (this.trigger !== RunTrigger.never) {\n      // Trigger linting immediately for onSave or never-trigger scenarios\n      this.doPlint(textDocument);\n    }\n  }\n\n  // Activate method to initialize the extension\n  public activate(): void {\n    const subscriptions: Disposable[] = this.context.subscriptions; // Get the existing subscriptions or create an empty array\n    this.diagnosticCollection = languages.createDiagnosticCollection(); // Create a diagnostic collection for handling linting results\n    // Register a listener for configuration changes\n    workspace.onDidChangeConfiguration(() => this.loadConfiguration(), this, subscriptions);\n    // Load the initial configuration\n    this.loadConfiguration();\n    // Initialize the output channel if not created already\n    if (this.outputChannel === null) {\n      this.outputChannel = window.createOutputChannel('PrologLinter');\n      this.outputChannel.clear();\n    }\n    // Register listeners based on the specified trigger (e.g., onSave)\n    if (this.trigger === RunTrigger.onSave) {\n      workspace.onDidOpenTextDocument(this.doPlint, this, subscriptions);\n    }\n    // Register a listener for text document closure to clear diagnostics\n    workspace.onDidCloseTextDocument(\n      textDocument => {\n        this.diagnosticCollection.delete(textDocument.uri);\n      },\n      null,\n      subscriptions\n    );\n  }\n\n  // Output message to the console\n  private outputMsg(msg: string) {\n    this.outputChannel.append(msg + '\\n');\n    this.outputChannel.show(true);\n  }\n\n  // Method to get information about a clause in a Prolog document\n  private getClauseInfo(doc: TextDocument, pred: IPredicate): [string, number] | null {\n    const docTxt = jsesc(doc.getText(), { quotes: 'double' }); // Escape special characters in the document text and convert it to a Prolog-compatible string\n    // Construct the Prolog query to retrieve clause location\n    const input = `\n    clause_location(Pred) :-\n      open_string(\"${docTxt}\", S),\n      load_files('${jsesc(doc.fileName)}', [module(user), stream(S), if(true)]),\n      close(S),\n      (   functor(Pred, :, 2)\n      ->  Pred1 = pred\n      ;   context_module(Mod),\n          Pred1 = Mod:Pred\n      ),\n      clause(Pred1, _, R),\n      clause_property(R, file(File)),\n      clause_property(R, line_count(Line)), !,\n      format('File=~s;Line=~d~n', [File, Line]).\n    `;\n    // Execute the Prolog query synchronously using the Utils.execPrologSync method\n    const clauseInfo = Utils.execPrologSync(\n      ['-q'],\n      input,\n      `clause_location(${pred.wholePred.split(':')[1]})`,\n      'true',\n      /File=(.+);Line=(\\d+)/\n    );\n    // Return the clause location as a tuple [file path, line number] or null if not found\n    return clauseInfo ? [clauseInfo[1], parseInt(clauseInfo[2])] : null;\n  }\n\n  // Method to export a predicate under the cursor\n  /*\n  public exportPredicateUnderCursor() {\n    // Check if the dialect is ECL, as the export helper only works for SWI-Prolog\n    if (Utils.DIALECT === \"ecl\") {\n      this.outputMsg(\"export helper only works for SWI-Prolog now.\");\n      return;\n    }\n    // Get the active text editor and document\n    let editor = window.activeTextEditor;\n    let doc = editor.document;\n    let docTxt = jsesc(doc.getText(), { quotes: \"double\" });\n    // Get the cursor position and the predicate information under the cursor\n    let pos = editor.selection.active;\n    let pred = Utils.getPredicateUnderCursor(doc, pos);\n    // Check if the predicate is valid for export\n    if (pred.arity < 0) {\n      this.outputMsg(`${pred.functor} is not a valid predicate to export.`);\n      return;\n    }\n\n    let clauseInfo = this.getClauseInfo(doc, pred);// Get the clause information for the predicate\n    // Check if the clause information is available\n    if (clauseInfo == null) {\n      this.outputMsg(`${pred.wholePred} is not a valid predicate to export.`);\n      return;\n    }\n    // Check if the predicate is defined in the active source file\n    if (clauseInfo[0] !== doc.fileName) {\n      this.outputMsg(`${pred.wholePred} is not defined in active source file.`);\n      return;\n    }\n    // Construct the Prolog query for rewriting the module declaration\n    let input = `\n    rewrite_module_declaration(Module, PI) :-\n        setup_call_cleanup(\n            open_string(\"${docTxt}\", S),\n            (   read_term(S, Term, [term_position(Pos)]),\n                stream_position_data(line_count, Pos, Line),\n                stream_position_data(line_position, Pos, Start),\n                (   Term=(:-module(Module1, Exports))\n                ->  (   memberchk(PI, Exports)\n                    ->  ReTerm=none,\n                        Action=none\n                    ;   NewExp=[PI|Exports],\n                        ReTerm=(:-module(Module1, NewExp)),\n                        Action=replace\n                    )\n                ;   ReTerm=(:-module(Module, [PI])),\n                    Action=insert\n                ),\n                format('Action=~s;Mod=~w;Line=~d;Start=~d;~n',\n                    [Action, ReTerm, Line, Start])\n            ),\n            close(S)\n        ).\n    `;\n    let modname = path.basename(doc.fileName).split(\".\")[0];// Get the module name from the document file name\n    // Execute the Prolog query synchronously to get the module declaration information\n    let modDec = Utils.execPrologSync(\n      [\"-q\"],\n      input,\n      `rewrite_module_declaration('${modname}', ${pred.pi.split(\":\")[1]})`,\n      \"true\",\n      /Action=(\\w+);Mod=(.+);Line=(\\d+);Start=(\\d+)/\n    );\n    // Extract the action, modified module declaration string, and line/start positions\n    let action = modDec[1];\n    let edit = new WorkspaceEdit();\n    let lines = doc.getText().split(\"\\n\");\n    let newModStr = modDec[2].replace(\":-\", \":- \") + \".\\n\\n\";\n    let modStartLine = parseInt(modDec[3]);\n    let modStartChar = parseInt(modDec[4]);\n    // Apply the edit based on the action (insert or replace)\n    if (action === \"insert\") {\n      edit.insert(\n        Uri.file(doc.fileName),\n        new Position(modStartLine - 1, modStartChar),\n        newModStr\n      );\n      workspace.applyEdit(edit);\n    } else if (action === \"replace\") {\n      // For replace, find the end of the existing module declaration\n      let modEndLine = parseInt(modDec[3]);\n      while (!/\\.\\s*$/.test(lines[modEndLine - 1])) modEndLine++;\n      let modEndChar = lines[modEndLine - 1].indexOf(\".\");\n      let modRange = new Range(\n        modStartLine - 1,\n        modStartChar,\n        modEndLine,\n        modEndChar + 1\n      );\n      // Replace the existing module declaration with the modified one\n      edit.replace(Uri.file(doc.fileName), modRange, newModStr);\n      workspace.applyEdit(edit);\n    }\n    // Ask the user if they want to add structured comments to the exported predicate\n    window\n      .showInformationMessage(\n        `'${pred.pi}' exported. Add structured comments to it?`,\n        \"yes\",\n        \"no\"\n      )\n      .then(answer => {\n        if (answer !== \"yes\") {\n          return;\n        }\n        // Add structured comments\n        let comm = \"%!\\t\" + pred.functor + \"\\n%\\n%\\n\";\n        let newClauseInfo = this.getClauseInfo(doc, pred);\n        edit = new WorkspaceEdit();\n        edit.insert(\n          Uri.file(doc.fileName),\n          new Position(newClauseInfo[1] - 1, 0),\n          comm\n        );\n        workspace.applyEdit(edit);\n      });\n  }*/\n\n  // Cleanup method to dispose of resources when the extension is deactivated\n  public dispose(): void {\n    this.documentListener.dispose();\n    this.openDocumentListener.dispose();\n    this.diagnosticCollection.clear();\n    this.diagnosticCollection.dispose();\n    this.commandAddDynamic.dispose();\n    this.commandAddUseModule.dispose();\n    this.commandExportPredicate.dispose();\n  }\n\n  // Method to navigate to the next error or warning line\n  public nextErrLine() {\n    this.gotoErrLine(0);\n  }\n  // Method to navigate to the previous error or warning line\n  public prevErrLine() {\n    this.gotoErrLine(1);\n  }\n\n  // Method to navigate to the error or warning line based on direction\n  private gotoErrLine(direction: number) {\n    //direction: 0: next, 1: previous\n    const editor = window.activeTextEditor; // Get the active text editor\n    const diagnostics = this.diagnosticCollection.get(editor.document.uri); // Get the diagnostics for the active document\n    // If there are no diagnostics, display a message and return\n    if (!diagnostics || diagnostics.length == 0) {\n      this.outputMsg('No errors or warnings :)');\n      return;\n    }\n    this.outputChannel.clear(); // Clear the output channel\n    const activeLine = editor.selection.active.line; // Get the active line in the editor\n    let position: Position, i: number;\n    const si = this.sortedDiagIndex[editor.document.uri.fsPath]; // Get the sorted diagnostic index for the active document\n    // Determine the navigation direction (next or previous)\n    if (direction === 0) {\n      i = 0;\n      // If the active line is greater than or equal to the last diagnostic's start line,navigate to the start of the first diagnostic; otherwise, find the next diagnostic\n      if (activeLine >= diagnostics[si[si.length - 1]].range.start.line) {\n        position = diagnostics[si[0]].range.start;\n      } else {\n        // Find the next diagnostic based on the active line\n        while (diagnostics[si[i]].range.start.line <= activeLine) {\n          i = i === si.length - 1 ? 0 : i + 1;\n        }\n        position = diagnostics[si[i]].range.start;\n      }\n    } else {\n      // If the active line is less than or equal to the first diagnostic's start line, navigate to the start of the last diagnostic; otherwise, find the previous diagnostic\n      i = si.length - 1;\n      if (activeLine <= diagnostics[si[0]].range.start.line) {\n        position = diagnostics[si[i]].range.start;\n      } else {\n        // Find the previous diagnostic based on the active line\n        while (diagnostics[si[i]].range.start.line >= activeLine) {\n          i = i === 0 ? si.length - 1 : i - 1;\n        }\n        position = diagnostics[si[i]].range.start;\n      }\n    }\n    editor.revealRange(diagnostics[si[i]].range, TextEditorRevealType.InCenter); // Reveal the range of the diagnostic in the editor\n    // Iterate through the diagnostics and display the one at the selected position\n    diagnostics.forEach(item => {\n      if (item.range.start.line === position.line) {\n        const severity = item.severity === DiagnosticSeverity.Error ? 'ERROR:\\t\\t' : 'Warning:\\t';\n        this.outputChannel.append(severity + item.message + '\\n');\n      }\n    });\n    editor.selection = new Selection(position, position); // Set the editor selection to the diagnostic's start position\n    this.outputChannel.show(true); // Show the output channel\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologPackageCommands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologPackageManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologRefactor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is assigned a value but never used.","line":253,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":253,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Location,\n  TextDocument,\n  Position,\n  workspace,\n  Uri,\n  Range,\n  OutputChannel,\n  WorkspaceEdit,\n  window,\n} from 'vscode';\nimport { IPredicate, Utils } from '../utils/utils';\nimport { spawn } from 'process-promises';\nimport fg from 'fast-glob';\nimport * as fs from 'fs';\nimport jsesc from 'jsesc';\n// import { resolve } from 'path';\nimport * as path from 'path';\n\ninterface IClauseRefs {\n  [file: string]: { [clauseLine: number]: number };\n}\n\nexport class PrologRefactor {\n  private _executable: string;\n  private _locations: Location[] = [];\n  private _clauseRefs: IClauseRefs = {};\n  private _outputChannel: OutputChannel;\n  private _isBuiltin: boolean = false;\n  private _defLocFound: boolean = false;\n\n  // pick predicate at pos in doc\n  constructor() {\n    this._executable = Utils.RUNTIMEPATH || '';\n    this._outputChannel = window.createOutputChannel('PrologFormatter');\n    this._locations = [];\n    this._clauseRefs = {};\n  }\n\n  // Initiates the refactoring process for the predicate currently under the cursor\n  public refactorPredUnderCursor() {\n    // Get the current document and cursor position\n    if (!window.activeTextEditor) {\n      return;\n    }\n    const doc: TextDocument = window.activeTextEditor.document;\n    const pos: Position = window.activeTextEditor.selection.active;\n\n    const pred: IPredicate = Utils.getPredicateUnderCursor(doc, pos); // Get the predicate information under the cursor using utility function\n    // Find all references to the predicate\n    this.findFilesAndRefs(pred, true, doc).then(refLocs => {\n      // Check if the predicate is a built-in predicate\n      if (this._isBuiltin) {\n        // If built-in, ask for confirmation before refactoring references\n        window\n          .showInformationMessage(\n            `'${pred.pi}' is a builtin predicate, so its definition cannot be refactored. Are you still SURE to refactor its all references?`,\n            'yes',\n            'no'\n          )\n          .then(answer => {\n            // If the user confirms, apply the refactoring\n            if (answer !== 'yes') {\n              return;\n            }\n            this.applyRefactoring(pred, refLocs);\n          });\n      } else {\n        // If not built-in, ask for confirmation to refactor both definition and references\n        window\n          .showInformationMessage(\n            `'Are you SURE to refactor '${pred.pi}' in all its references and definition? You'd better to commit current stage of the VCS to rollback refactoring if necessary.`,\n            'yes',\n            'no'\n          )\n          .then(answer => {\n            // If the user confirms, apply the refactoring\n            if (answer !== 'yes') {\n              return;\n            }\n            this.applyRefactoring(pred, refLocs);\n          });\n      }\n    });\n  }\n\n  // Applies the refactoring by replacing all occurrences of the predicate with a new name in the given reference locations\n  private async applyRefactoring(pred: IPredicate, refLocs: Location[]) {\n    // Prompt the user to input a new predicate name\n    const newPredName = await window.showInputBox({\n      prompt: `Input new predicate name to replace ${pred.functor}`,\n      placeHolder: pred.functor,\n      ignoreFocusOut: true,\n      validateInput: value => {\n        // Validate the input for the new predicate name\n        if (/\\s/.test(value) && !/^'[^']+'$/.test(value)) {\n          return 'Predicate name must not contain any spaces, tab and new line.';\n        }\n        if (/^[^a-z']/.test(value) || (/^'[^a-z]/.test(value) && !/'$/.test(value))) {\n          return 'Illegal starting letter in predicate name.';\n        }\n        return null; // Input is valid\n      },\n    });\n    // Replace occurrences of the old predicate with the new name in each reference location\n    await Promise.all(\n      refLocs.map(async refLoc => {\n        if (newPredName) {\n          const edit = new WorkspaceEdit();\n          edit.replace(refLoc.uri, refLoc.range, newPredName);\n          return await workspace.applyEdit(edit);\n        }\n        return Promise.resolve(true);\n      })\n    );\n    // Save all open documents after refactoring\n    await Promise.all(\n      workspace.textDocuments.map(async doc => {\n        return await doc.save();\n      })\n    );\n\n    return;\n  }\n\n  // Finds all references to the predicate currently under the cursor\n  public findAllRefs(): Promise<Location[]> {\n    // Get the current document and cursor position\n    if (!window.activeTextEditor) {\n      return Promise.resolve([]);\n    }\n    const doc: TextDocument = window.activeTextEditor.document;\n    const pos: Position = window.activeTextEditor.selection.active;\n\n    const pred: IPredicate = Utils.getPredicateUnderCursor(doc, pos); // Get the predicate information under the cursor using utility function\n    return this.findFilesAndRefs(pred, false, doc); // Call the findFilesAndRefs method to find references and return the result\n  }\n\n  // Finds references to the given predicate in multiple files\n  public async findFilesAndRefs(\n    pred: IPredicate,\n    includingDefLoc = false,\n    doc: TextDocument\n  ): Promise<Location[]> {\n    // Call the findFilesAndRefs1 method to perform the actual search\n    return await this.findFilesAndRefs1(pred, includingDefLoc, doc);\n  }\n\n  // Performs the search for references to the given predicate in multiple files\n  public async findFilesAndRefs1(\n    pred: IPredicate,\n    includingDefLoc = false,\n    doc: TextDocument\n  ): Promise<Location[]> {\n    // Save all open documents before searching\n    await Promise.all(\n      workspace.textDocuments.map(async doc => {\n        return await doc.save();\n      })\n    );\n    // Use fast-glob to locate files containing references to the predicate\n    if (!workspace.workspaceFolders || workspace.workspaceFolders.length === 0) {\n      return this._locations;\n    }\n    const root = workspace.workspaceFolders[0].uri.fsPath;\n    const patterns = ['**/*.pl', '**/*.ecl'];\n    const filePaths = await fg(patterns, { cwd: root, absolute: true });\n    for (const file of filePaths) {\n      // Read file and check if it contains the predicate functor\n      const content = await fs.promises.readFile(file, 'utf8');\n      if (content.includes(pred.functor)) {\n        const defLoc = includingDefLoc && !this._defLocFound;\n        await this.loadFileAndFindRefs(pred, file, defLoc, doc);\n      }\n    }\n    return this._locations; // Return the array of reference locations\n  }\n\n  // Loads the Prolog file and finds references based on the Prolog dialect\n  private async loadFileAndFindRefs(\n    pred: IPredicate,\n    file: string,\n    includingDefLoc = false,\n    doc: TextDocument\n  ) {\n    let input: string,\n      args: string[] = [];\n    // Construct the appropriate input and arguments based on the Prolog dialect\n    switch (Utils.DIALECT) {\n      case 'swi': {\n        const pfile = jsesc(path.resolve(`${__dirname}/features/findallrefs_swi`));\n        input = `\n          use_module('${pfile}').\n          load_files('${file}').\n          findrefs:findrefs(${pred.pi}, ${includingDefLoc}).\n          halt.\n        `;\n        args = ['-q'];\n        break;\n      }\n      case 'ecl': {\n        const efile = jsesc(path.resolve(`${__dirname}/features/findallrefs`));\n        args = ['-f', efile];\n        input = `digout_predicate('${file}', ${pred.pi}). `;\n        break;\n      }\n      default:\n        break;\n    }\n\n    try {\n      // Spawn a child process to execute Prolog queries\n      if (!workspace.workspaceFolders || workspace.workspaceFolders.length === 0) {\n        return;\n      }\n      await spawn(this._executable, args, { cwd: workspace.workspaceFolders[0].uri.fsPath })\n        .on('process', (proc: any) => {\n          if (proc.pid) {\n            // Write the input to the stdin of the spawned process\n            proc.stdin.write(input);\n            proc.stdin.end();\n          }\n        })\n        .on('stdout', (output: any) => {\n          // Parse the output based on the Prolog dialect\n          switch (Utils.DIALECT) {\n            case 'swi':\n              this.findRefsFromOutputSwi(pred, output, doc);\n              break;\n            case 'ecl':\n              this.findRefsFromOutputEcl(file, pred.pi, output);\n              break;\n            default:\n              break;\n          }\n        })\n        .on('stderr', (err: any) => {\n          // Handle any errors or display them in the output channel\n          this._outputChannel.append(err + '\\n');\n          this._outputChannel.show(true);\n        });\n    } catch (error: unknown) {\n      // Handle specific error cases (e.g., executable not found) and display error messages\n      let message: string = '';\n      if (\n        error &&\n        typeof error === 'object' &&\n        'code' in error &&\n        (error as any).code === 'ENOENT'\n      ) {\n        message = `Cannot debug the prolog file. The Prolog executable was not found. Correct the 'prolog.executablePath' configure please.`;\n      } else {\n        message =\n          error &&\n          typeof error === 'object' &&\n          'message' in error &&\n          typeof (error as any).message === 'string'\n            ? (error as any).message\n            : `Failed to run swipl using path: ${this._executable}. Reason is unknown.`;\n      }\n    }\n  }\n\n  // Parses the output from SWI-Prolog and extracts reference information\n  private findRefsFromOutputSwi(pred: IPredicate, output: string, doc: TextDocument) {\n    // Check if the predicate is a built-in or foreign predicate\n    const docContent = doc.getText();\n    if (/{\"reference\":\"built_in or foreign\"}/.test(output)) {\n      this._isBuiltin = true;\n    }\n    // Check if a definition location is found in the output\n    if (/{\"reference\":\"definition location found\"}/.test(output)) {\n      this._defLocFound = true;\n    }\n\n    let pred_void = pred.functor + '(?=\\\\(';\n    for (let i = 0; i < pred.arity; i++) {\n      pred_void = pred_void + \"[a-zA-Z0-9_,$&+,:;=?@#|'<>.^*()%!-:[\\\\]\\\\s]*\";\n      if (i < pred.arity - 1) {\n        pred_void = pred_void + ',';\n      }\n    }\n    pred_void = pred_void + '\\\\))|' + pred.functor + '(?=/' + pred.arity + ')';\n    const regexp = new RegExp(pred_void, 'gm');\n    const array = [...docContent.matchAll(regexp)]; // Extract occurrences of the predicate in the document\n    let locations = array.map(\n      elem =>\n        new Location(\n          Uri.file(doc.fileName),\n          new Range(\n            doc.positionAt(elem.index || 0),\n            doc.positionAt((elem.index || 0) + (elem[0]?.length || 0))\n          )\n        )\n    ); // Create an array to store Location objects\n\n    const regexpModule =\n      /^\\s*:-\\s*use_module\\(([a-zA-Z0-9_/]*|(\"|')[a-zA-Z0-9_/.]*(\"|'))\\s*((,\\s*[/a-zA-Z0-9[\\]]*\\s*\\)|\\))\\s*\\.)/gm; // Define a regular expression for finding \"use_module\" declarations in the document\n    const arrayModule = [...docContent.matchAll(regexpModule)]; // Extract \"use_module\" declarations from the document\n    const filenameParts = doc.fileName.split('.');\n    const prolog = filenameParts.length > 1 ? filenameParts[1] : 'pl'; // Extract the Prolog dialect from the file extension\n    // Iterate through \"use_module\" declarations\n    for (let i = 0; i < arrayModule.length; i++) {\n      if (!arrayModule[i]?.[1]) {\n        continue;\n      }\n      var modpath = arrayModule[i][1].replace(new RegExp(\"'\", 'gm'), '');\n      modpath = modpath.replace(new RegExp('\"', 'gm'), '');\n      var text = '';\n      try {\n        if (!workspace.workspaceFolders || workspace.workspaceFolders.length === 0) {\n          continue;\n        }\n        text = fs.readFileSync(\n          workspace.workspaceFolders[0].uri.fsPath + '/' + modpath + '.' + prolog,\n          'utf8'\n        ); // Read the content of the referenced module file\n      } catch (error: unknown) {\n        console.error('Error reading file:', error);\n      }\n      const array = [...text.matchAll(regexp)]; // Extract occurrences of the predicate in the referenced module file\n      if (workspace.workspaceFolders && workspace.workspaceFolders.length > 0) {\n        locations = locations.concat(\n          array.map(\n            elem =>\n              new Location(\n                Uri.file(workspace.workspaceFolders[0].uri.fsPath + '/' + modpath + '.' + prolog),\n                new Range(\n                  Utils.findLineColForByte(text, elem.index),\n                  Utils.findLineColForByte(text, elem.index + elem[0].length)\n                )\n              )\n          )\n        ); // Append the new occurrences to the locations array\n      }\n    }\n\n    this._locations = locations;\n    /*let refReg = /\\{\"reference\":\\s*(\\{.+?\\})\\}/g;// Regular expression to match reference information in the output\n    // Attempt to match and parse each reference in the output\n    let match: RegExpExecArray = refReg.exec(output);\n    while (match) {\n      // Parse the reference information from the matched JSON\n      let ref: { file: string; line: number; char: number } = JSON.parse(\n        match[1]\n      );\n      // Relocate if the reference points to the start of the clause\n      let lines = fs\n        .readFileSync(ref.file)\n        .toString()\n        .split(\"\\n\");\n      let predName = pi.split(\"/\")[0];\n      // Extract the predicate name in case of a module\n      if (predName.indexOf(\":\") > -1) {\n        predName = predName.split(\":\")[1];\n      }\n      // Check if the reference is not at the beginning of the clause\n      if (!new RegExp(\"^\" + predName).test(lines[ref.line].slice(ref.char))) {\n        let clauseStart = ref.line;\n        let start = ref.line;\n        // Adjust the start based on previous clause references\n        if (\n          this._clauseRefs[ref.file] &&\n          this._clauseRefs[ref.file][clauseStart]\n        ) {\n          start = this._clauseRefs[ref.file][clauseStart] + 1;\n        }\n        let str = lines.slice(start).join(\"\\n\");\n        let index = str.indexOf(predName);\n        // If the predicate name is found, adjust the reference location\n        if (index > -1) {\n          str = str.slice(0, index);\n          let strLines = str.split(\"\\n\");\n          ref.line = start + strLines.length - 1;\n          ref.char = strLines[strLines.length - 1].length;\n          // Update the clause references with the adjusted location\n          if (this._clauseRefs[ref.file]) {\n            this._clauseRefs[ref.file][clauseStart] = ref.line;\n          } else {\n            this._clauseRefs[ref.file] = {};\n            this._clauseRefs[ref.file][clauseStart] = ref.line;\n          }\n        }\n      }\n      // Add the adjusted reference location to the _locations array\n      this._locations.push(\n        new Location(\n          Uri.file(jsesc(path.resolve(ref.file))),\n          new Range(ref.line, ref.char, ref.line, ref.char + predName.length)\n        )\n      );\n      match = refReg.exec(output);// Attempt to find the next reference in the output\n    }*/\n  }\n\n  //Parses the output from ECLiPSe Prolog and extracts reference information\n  private findRefsFromOutputEcl(file: string, pi: string, output: string) {\n    const match = output.match(/references:\\[(.*)\\]/); // Extract references information from the output using a regular expression\n    // Return if no matches are found or the references array is empty\n    if (!match || match[1] === '') {\n      return;\n    }\n    const predLen = pi.split(':')[1].split('/')[0].length; // Extract the length of the predicate name\n    const locs = match[1].split(','); // Split the references string into an array of location strings\n    workspace.openTextDocument(Uri.file(file)).then(doc => {\n      // Open the Prolog document to map character positions to positions in the file\n      // Iterate through each location string and create Location objects\n      locs.forEach(fromS => {\n        const from = parseInt(fromS);\n        this._locations.push(\n          new Location(\n            Uri.file(file),\n            new Range(doc.positionAt(from), doc.positionAt(from + predLen))\n          )\n        );\n      });\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\prologTerminal.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OutputChannel' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'os' is defined but never used.","line":19,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":114,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":128,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":128,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":142,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":142,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":170,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":184,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":184,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":215,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":215,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":238,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":238,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nimport { Utils } from '../utils/utils';\nimport {\n  Terminal,\n  window,\n  workspace,\n  TextDocument,\n  Disposable,\n  OutputChannel,\n  TextEditor,\n  commands,\n} from 'vscode';\nimport jsesc from 'jsesc';\nimport { InstallationGuide } from './installationGuide';\nimport { PlatformUtils, PlatformType } from '../utils/platformUtils';\nimport { ExecutableFinder } from '../utils/executableFinder';\nimport { spawn } from 'child_process';\nimport * as os from 'os';\n\n/**\n * Shell information interface\n */\ninterface ShellInfo {\n  name: string;\n  path: string;\n  args: string[];\n  supportsColors: boolean;\n  requiresQuoting: boolean;\n}\n\n/**\n * Terminal configuration interface\n */\ninterface TerminalConfig {\n  executable: string;\n  args: string[];\n  shell?: ShellInfo;\n  env?: Record<string, string>;\n  cwd?: string;\n}\n\nexport default class PrologTerminal {\n  private static _terminal: Terminal;\n  private static _document: TextDocument;\n  private static _platform: PlatformType;\n  private static _shellInfo: ShellInfo | null = null;\n\n  constructor() {\n    // Static terminal class - no instance initialization needed\n  }\n  // Initialize the Prolog terminal\n  public static init(): Disposable {\n    PrologTerminal._platform = PlatformUtils.getPlatform();\n    return (<any>window).onDidCloseTerminal((terminal: any) => {\n      PrologTerminal._terminal = null as any;\n      terminal.dispose();\n    });\n  }\n\n  /**\n   * Detect the default shell for the current platform\n   */\n  private static async detectShell(): Promise<ShellInfo> {\n    if (PrologTerminal._shellInfo) {\n      return PrologTerminal._shellInfo;\n    }\n\n    let shellInfo: ShellInfo;\n\n    switch (PrologTerminal._platform) {\n      case 'windows': {\n        shellInfo = await PrologTerminal.detectWindowsShell();\n        break;\n      }\n      case 'macos': {\n        shellInfo = await PrologTerminal.detectMacOSShell();\n        break;\n      }\n      case 'linux': {\n        shellInfo = await PrologTerminal.detectLinuxShell();\n        break;\n      }\n      default:\n        // Fallback to basic shell\n        shellInfo = {\n          name: 'sh',\n          path: '/bin/sh',\n          args: [],\n          supportsColors: false,\n          requiresQuoting: true,\n        };\n        break;\n    }\n\n    PrologTerminal._shellInfo = shellInfo;\n    return shellInfo;\n  }\n\n  /**\n   * Detect Windows shell (PowerShell, Command Prompt, WSL)\n   */\n  private static async detectWindowsShell(): Promise<ShellInfo> {\n    // Check for PowerShell Core first\n    try {\n      await PrologTerminal.testCommand('pwsh', ['--version']);\n      return {\n        name: 'PowerShell Core',\n        path: 'pwsh',\n        args: ['-NoLogo'],\n        supportsColors: true,\n        requiresQuoting: true,\n      };\n    } catch (_error) {\n      // Ignore shell detection failure\n    }\n\n    // Check for Windows PowerShell\n    try {\n      await PrologTerminal.testCommand('powershell', ['-Version']);\n      return {\n        name: 'Windows PowerShell',\n        path: 'powershell',\n        args: ['-NoLogo'],\n        supportsColors: true,\n        requiresQuoting: true,\n      };\n    } catch (_error) {\n      // Ignore shell detection failure\n    }\n\n    // Check for WSL\n    try {\n      await PrologTerminal.testCommand('wsl', ['--version']);\n      return {\n        name: 'WSL',\n        path: 'wsl',\n        args: [],\n        supportsColors: true,\n        requiresQuoting: true,\n      };\n    } catch (_error) {\n      // Ignore bash detection failure\n    }\n\n    // Fallback to Command Prompt\n    return {\n      name: 'Command Prompt',\n      path: 'cmd',\n      args: ['/K'],\n      supportsColors: false,\n      requiresQuoting: true,\n    };\n  }\n\n  /**\n   * Detect macOS shell (zsh, bash)\n   */\n  private static async detectMacOSShell(): Promise<ShellInfo> {\n    // Check for zsh (default on macOS Catalina+)\n    try {\n      await PrologTerminal.testCommand('zsh', ['--version']);\n      return {\n        name: 'Zsh',\n        path: '/bin/zsh',\n        args: [],\n        supportsColors: true,\n        requiresQuoting: true,\n      };\n    } catch (_error) {\n      // Ignore zsh detection failure\n    }\n\n    // Check for bash\n    try {\n      await PrologTerminal.testCommand('bash', ['--version']);\n      return {\n        name: 'Bash',\n        path: '/bin/bash',\n        args: [],\n        supportsColors: true,\n        requiresQuoting: true,\n      };\n    } catch (_error) {\n      // Ignore WSL detection failure\n    }\n\n    // Fallback to sh\n    return {\n      name: 'Shell',\n      path: '/bin/sh',\n      args: [],\n      supportsColors: false,\n      requiresQuoting: true,\n    };\n  }\n\n  /**\n   * Detect Linux shell (bash, zsh, fish, etc.)\n   */\n  private static async detectLinuxShell(): Promise<ShellInfo> {\n    // Get user's default shell from environment\n    const userShell = process.env.SHELL;\n    if (userShell) {\n      const shellName = PlatformUtils.basename(userShell);\n      try {\n        await PrologTerminal.testCommand(userShell, ['--version']);\n        return {\n          name: shellName,\n          path: userShell,\n          args: [],\n          supportsColors: true,\n          requiresQuoting: true,\n        };\n      } catch (_error) {\n        // Ignore Windows PowerShell detection failure\n      }\n    }\n\n    // Check for common shells\n    const shells = [\n      { name: 'bash', path: '/bin/bash' },\n      { name: 'zsh', path: '/bin/zsh' },\n      { name: 'fish', path: '/usr/bin/fish' },\n      { name: 'dash', path: '/bin/dash' },\n    ];\n\n    for (const shell of shells) {\n      try {\n        await PrologTerminal.testCommand(shell.path, ['--version']);\n        return {\n          name: shell.name,\n          path: shell.path,\n          args: [],\n          supportsColors: shell.name !== 'dash',\n          requiresQuoting: true,\n        };\n      } catch (_error) {\n        // Ignore PowerShell Core detection failure\n      }\n    }\n\n    // Fallback to sh\n    return {\n      name: 'Shell',\n      path: '/bin/sh',\n      args: [],\n      supportsColors: false,\n      requiresQuoting: true,\n    };\n  }\n\n  /**\n   * Test if a command is available\n   */\n  private static async testCommand(command: string, args: string[]): Promise<boolean> {\n    return new Promise(resolve => {\n      const process = spawn(command, args, {\n        stdio: ['ignore', 'ignore', 'ignore'],\n        timeout: 3000,\n      });\n\n      process.on('close', code => {\n        resolve(code === 0);\n      });\n\n      process.on('error', () => {\n        resolve(false);\n      });\n\n      setTimeout(() => {\n        process.kill();\n        resolve(false);\n      }, 3000);\n    });\n  }\n\n  /**\n   * Get platform-specific terminal configuration\n   */\n  private static async getTerminalConfig(): Promise<TerminalConfig> {\n    const section = workspace.getConfiguration('prolog');\n    let executable = section.get<string>(\n      'executablePath',\n      PlatformUtils.getDefaultExecutablePath()\n    );\n\n    // Enhanced executable resolution\n    if (\n      !(await PlatformUtils.pathExists(executable)) ||\n      !(await PlatformUtils.isExecutable(executable))\n    ) {\n      const executableFinder = new ExecutableFinder();\n      const detectionResult = await executableFinder.findSwiplExecutable();\n      if (detectionResult.found && detectionResult.path) {\n        executable = detectionResult.path;\n      }\n    }\n\n    executable = PlatformUtils.normalizePath(executable);\n\n    // Get platform-specific runtime arguments\n    const args =\n      section.get<string[]>('terminal.runtimeArgs') || PlatformUtils.getDefaultRuntimeArgs();\n\n    // Detect shell for better integration\n    const shell = await PrologTerminal.detectShell();\n\n    // Platform-specific environment variables\n    const env: Record<string, string> = {};\n\n    switch (PrologTerminal._platform) {\n      case 'windows': {\n        // Windows-specific environment setup\n        env.TERM = 'xterm-256color';\n        break;\n      }\n      case 'macos': {\n        // macOS-specific environment setup\n        env.TERM = 'xterm-256color';\n        env.LANG = process.env.LANG || 'en_US.UTF-8';\n        break;\n      }\n      case 'linux': {\n        // Linux-specific environment setup\n        env.TERM = 'xterm-256color';\n        env.LANG = process.env.LANG || 'en_US.UTF-8';\n        break;\n      }\n    }\n\n    return {\n      executable,\n      args,\n      shell,\n      env,\n      cwd: workspace.workspaceFolders?.[0]?.uri.fsPath || process.cwd(),\n    };\n  }\n\n  /**\n   * Escape command arguments for the detected shell\n   */\n  private static escapeForShell(text: string, shell: ShellInfo): string {\n    if (!shell.requiresQuoting) {\n      return text;\n    }\n\n    switch (PrologTerminal._platform) {\n      case 'windows': {\n        // Windows shell escaping\n        if (shell.name.includes('PowerShell')) {\n          // PowerShell escaping\n          return `'${text.replace(/'/g, \"''\")}'`;\n        } else {\n          // Command Prompt escaping\n          return `\"${text.replace(/\"/g, '\"\"')}\"`;\n        }\n      }\n      case 'macos':\n      case 'linux': {\n        // Unix shell escaping\n        if (text.includes(' ') || text.includes('\"') || text.includes(\"'\")) {\n          return `'${text.replace(/'/g, \"'\\\"'\\\"'\")}'`;\n        }\n        return text;\n      }\n      default:\n        return text;\n    }\n  }\n\n  // Create a Prolog terminal instance\n  private static async createPrologTerm() {\n    if (PrologTerminal._terminal) {\n      return;\n    }\n\n    try {\n      const config = await PrologTerminal.getTerminalConfig();\n      const title = 'Prolog';\n\n      // Validate executable exists and has proper permissions\n      if (!(await PlatformUtils.pathExists(config.executable))) {\n        throw new Error(`Executable not found: ${config.executable}`);\n      }\n\n      if (!(await PlatformUtils.isExecutable(config.executable))) {\n        const platform = PlatformUtils.getPlatform();\n        let permissionError = `Executable lacks execute permissions: ${config.executable}`;\n        if (platform !== 'windows') {\n          permissionError += `\\n\\nTry fixing permissions with: chmod +x \"${config.executable}\"`;\n        }\n        throw new Error(permissionError);\n      }\n\n      // Create terminal with enhanced configuration\n      const terminalOptions: any = {\n        name: title,\n        shellPath: config.executable,\n        shellArgs: config.args,\n        cwd: config.cwd,\n        env: {\n          ...process.env,\n          ...config.env,\n        },\n      };\n\n      // Add platform-specific terminal options\n      switch (PrologTerminal._platform) {\n        case 'windows': {\n          // Windows-specific terminal options\n          terminalOptions.hideFromUser = false;\n          break;\n        }\n        case 'macos': {\n          // macOS-specific terminal options\n          terminalOptions.strictEnv = false;\n          break;\n        }\n        case 'linux': {\n          // Linux-specific terminal options\n          terminalOptions.strictEnv = false;\n          break;\n        }\n      }\n\n      PrologTerminal._terminal = window.createTerminal(terminalOptions);\n\n      // Send initial setup commands based on platform and shell\n      setTimeout(async () => {\n        await PrologTerminal.sendInitialSetupCommands(config);\n      }, 1000);\n    } catch (error: any) {\n      await PrologTerminal.handleTerminalCreationError(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send initial setup commands to configure the terminal environment\n   */\n  private static async sendInitialSetupCommands(config: TerminalConfig) {\n    if (!PrologTerminal._terminal) return;\n\n    const shell = config.shell;\n    if (!shell) return;\n\n    // Platform-specific setup commands\n    const setupCommands: string[] = [];\n\n    switch (PrologTerminal._platform) {\n      case 'windows': {\n        if (shell.name.includes('PowerShell')) {\n          setupCommands.push('$Host.UI.RawUI.WindowTitle = \"Prolog Terminal\"');\n          if (shell.supportsColors) {\n            setupCommands.push('$PSStyle.OutputRendering = \"Host\"');\n          }\n        } else if (shell.name === 'Command Prompt') {\n          setupCommands.push('title Prolog Terminal');\n        }\n        break;\n      }\n      case 'macos':\n      case 'linux': {\n        if (shell.supportsColors) {\n          setupCommands.push('export TERM=xterm-256color');\n        }\n        // Set terminal title\n        setupCommands.push('echo -ne \"\\\\033]0;Prolog Terminal\\\\007\"');\n        break;\n      }\n    }\n\n    // Send setup commands\n    for (const command of setupCommands) {\n      PrologTerminal._terminal.sendText(command);\n    }\n  }\n\n  /**\n   * Handle terminal creation errors with enhanced error messages and recovery options\n   */\n  private static async handleTerminalCreationError(error: any) {\n    let errorMessage = 'Failed to create Prolog terminal';\n    let isExecutableError = false;\n\n    if (error.code === 'ENOENT' || error.message?.includes('not found')) {\n      errorMessage =\n        'SWI-Prolog executable not found. The terminal requires SWI-Prolog to run interactive Prolog sessions.';\n      isExecutableError = true;\n    } else if (error.message?.includes('permission')) {\n      errorMessage = `Permission error: ${error.message}`;\n      isExecutableError = true;\n    } else {\n      errorMessage = `Failed to create Prolog terminal: ${error.message || error}`;\n    }\n\n    if (isExecutableError) {\n      const action = await window.showErrorMessage(\n        errorMessage,\n        'Install with Package Manager',\n        'Installation Guide',\n        'Setup Wizard',\n        'Configure Path',\n        'Dismiss'\n      );\n\n      const installationGuide = InstallationGuide.getInstance();\n      switch (action) {\n        case 'Install with Package Manager': {\n          const { PackageManagerIntegration } = await import('./packageManagerIntegration');\n          const packageManager = PackageManagerIntegration.getInstance();\n          await packageManager.showInstallationDialog();\n          break;\n        }\n        case 'Installation Guide': {\n          await installationGuide.showInstallationGuideDialog();\n          break;\n        }\n        case 'Setup Wizard': {\n          await commands.executeCommand('prolog.setupWizard');\n          break;\n        }\n        case 'Configure Path': {\n          await commands.executeCommand('workbench.action.openSettings', 'prolog.executablePath');\n          break;\n        }\n      }\n    } else {\n      window.showErrorMessage(errorMessage);\n    }\n  }\n  // Send a string to the Prolog terminal\n  public static async sendString(text: string) {\n    try {\n      await PrologTerminal.createPrologTerm();\n\n      // Get shell info for proper escaping\n      const shell = await PrologTerminal.detectShell();\n\n      // finish goal by .\n      if (!text.endsWith('.')) {\n        text += '.';\n      }\n\n      // Escape text for the detected shell if needed\n      const escapedText = PrologTerminal.escapeForShell(text, shell);\n\n      PrologTerminal._terminal.sendText(escapedText);\n      PrologTerminal._terminal.show(false);\n    } catch (error) {\n      // Error already handled in createPrologTerm\n      console.error('Failed to send string to Prolog terminal:', error);\n    }\n  }\n  // load the prolog file\n  public static async loadDocument() {\n    if (!window.activeTextEditor) {\n      return;\n    }\n    try {\n      PrologTerminal._document = window.activeTextEditor.document; // Get the active Prolog document\n      await PrologTerminal.createPrologTerm(); // Create the Prolog terminal\n      // Get the file name and escape it using jsesc\n      const fname = jsesc(PlatformUtils.normalizePath(PrologTerminal._document.fileName), {\n        quotes: 'single',\n      });\n      const goals = `['${fname}']`; // Define the goals to load the Prolog file\n      // load the file into swipl with a goal\n      if (PrologTerminal._document.isDirty) {\n        PrologTerminal._document.save().then(_ => {\n          PrologTerminal.sendString(goals);\n        });\n      } else {\n        await PrologTerminal.sendString(goals);\n      }\n    } catch (error) {\n      // Error already handled in createPrologTerm\n      console.error('Failed to load document in Prolog terminal:', error);\n    }\n  }\n  // query the goal under the cursor command\n  public static queryGoalUnderCursor() {\n    // Get the active text editor and document\n    if (!window.activeTextEditor) {\n      return;\n    }\n    const editor: TextEditor = window.activeTextEditor;\n    const doc: TextDocument = editor.document;\n    const pred = Utils.getPredicateUnderCursor(doc, editor.selection.active); // Get the predicate under the cursor using utility function\n    // if no predicate under cursor\n    if (!pred) {\n      return;\n    }\n    PrologTerminal.loadDocument(); // Load the current Prolog document into the Prolog terminal\n    let goal = pred?.wholePred || ''; // Extract the goal from the predicate\n    // Separate the module if present\n    if (goal.indexOf(':') > -1) {\n      const parts = goal.split(':');\n      goal = parts.length > 1 ? parts[1] : goal;\n    }\n    PrologTerminal.sendString(goal);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\queryHistoryManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'QueryStatus' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":494,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":494,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { QueryStatus } from './queryNotificationManager';\n\nexport interface QueryHistoryEntry {\n  id: string;\n  cmd: string;\n  params: Record<string, unknown>;\n  status: 'pending' | 'running' | 'completed' | 'error' | 'cancelled' | 'timeout';\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  results?: unknown;\n  error?: unknown;\n  priority?: string;\n  deleted?: boolean;\n  resourceUsage?: {\n    memoryMB?: number;\n    cpuPercent?: number;\n  };\n  metadata?: {\n    userAgent?: string;\n    sessionId?: string;\n    workspaceId?: string;\n    tags?: string[];\n  };\n}\n\nexport interface QueryHistoryFilter {\n  status?: string[];\n  startDate?: Date;\n  endDate?: Date;\n  cmd?: string;\n  priority?: string[];\n  tags?: string[];\n  limit?: number;\n  offset?: number;\n  sortBy?: 'startTime' | 'endTime' | 'duration' | 'cmd';\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface QueryHistoryStats {\n  totalQueries: number;\n  completedQueries: number;\n  errorQueries: number;\n  cancelledQueries: number;\n  timeoutQueries: number;\n  averageDuration: number;\n  totalDuration: number;\n  queriesByStatus: Record<string, number>;\n  queriesByPriority: Record<string, number>;\n  queriesByCmd: Record<string, number>;\n  dailyStats: Array<{\n    date: string;\n    count: number;\n    avgDuration: number;\n  }>;\n}\n\nexport interface QueryHistoryOptions {\n  storageDir: string;\n  maxHistorySize: number;\n  compressionEnabled: boolean;\n  retentionDays: number;\n  autoCleanup: boolean;\n  batchSize: number;\n}\n\n/**\n * Persistent query history storage and management system\n */\nexport class QueryHistoryManager extends EventEmitter {\n  private static instance: QueryHistoryManager;\n  private options: QueryHistoryOptions;\n  private historyFile: string;\n  private indexFile: string;\n  private memoryCache: Map<string, QueryHistoryEntry> = new Map();\n  private writeQueue: QueryHistoryEntry[] = [];\n  private writeInterval?: ReturnType<typeof setInterval>;\n  private cleanupInterval?: ReturnType<typeof setInterval>;\n  private isInitialized: boolean = false;\n\n  /**\n   * Get singleton instance of QueryHistoryManager\n   */\n  public static getInstance(options?: Partial<QueryHistoryOptions>): QueryHistoryManager {\n    if (!QueryHistoryManager.instance) {\n      QueryHistoryManager.instance = new QueryHistoryManager(options);\n    }\n    return QueryHistoryManager.instance;\n  }\n\n  constructor(options: Partial<QueryHistoryOptions> = {}) {\n    super();\n\n    this.options = {\n      storageDir: path.join(process.cwd(), '.prolog-history'),\n      maxHistorySize: 10000,\n      compressionEnabled: true,\n      retentionDays: 30,\n      autoCleanup: true,\n      batchSize: 100,\n      ...options,\n    };\n\n    this.historyFile = path.join(this.options.storageDir, 'query-history.jsonl');\n    this.indexFile = path.join(this.options.storageDir, 'query-index.json');\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize the history manager\n   */\n  private async initialize(): Promise<void> {\n    try {\n      // Ensure storage directory exists\n      if (!fs.existsSync(this.options.storageDir)) {\n        fs.mkdirSync(this.options.storageDir, { recursive: true });\n      }\n\n      // Load existing history into memory cache\n      await this.loadHistoryFromDisk();\n\n      // Start background processes\n      this.startWriteProcessor();\n      if (this.options.autoCleanup) {\n        this.startCleanupProcessor();\n      }\n\n      this.isInitialized = true;\n      this.emit('initialized');\n      console.log(`[QueryHistoryManager] Initialized with ${this.memoryCache.size} entries`);\n    } catch (error: unknown) {\n      console.error('[QueryHistoryManager] Initialization failed:', error);\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Add a query to the history\n   */\n  async addQuery(entry: Omit<QueryHistoryEntry, 'duration'>): Promise<void> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    const historyEntry: QueryHistoryEntry = {\n      ...entry,\n    };\n\n    // Only set duration if endTime is provided\n    if (entry.endTime) {\n      historyEntry.duration = entry.endTime - entry.startTime;\n    }\n\n    // Add to memory cache\n    this.memoryCache.set(entry.id, historyEntry);\n\n    // Add to write queue for persistent storage\n    this.writeQueue.push(historyEntry);\n\n    // Emit event\n    this.emit('queryAdded', historyEntry);\n\n    // Check if we need to enforce size limits\n    if (this.memoryCache.size > this.options.maxHistorySize) {\n      await this.enforceHistoryLimit();\n    }\n\n    console.log(`[QueryHistoryManager] Added query ${entry.id} to history`);\n  }\n\n  /**\n   * Update an existing query in the history\n   */\n  async updateQuery(queryId: string, updates: Partial<QueryHistoryEntry>): Promise<void> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    const existingEntry = this.memoryCache.get(queryId);\n    if (!existingEntry) {\n      console.warn(`[QueryHistoryManager] Query ${queryId} not found for update`);\n      return;\n    }\n\n    const updatedEntry: QueryHistoryEntry = {\n      ...existingEntry,\n      ...updates,\n    };\n\n    // Calculate duration if endTime is provided in updates\n    if (updates.endTime) {\n      updatedEntry.duration = updates.endTime - existingEntry.startTime;\n    }\n\n    // Update memory cache\n    this.memoryCache.set(queryId, updatedEntry);\n\n    // Add to write queue\n    this.writeQueue.push(updatedEntry);\n\n    this.emit('queryUpdated', updatedEntry);\n    console.log(`[QueryHistoryManager] Updated query ${queryId} in history`);\n  }\n\n  /**\n   * Get query history with filtering and pagination\n   */\n  async getHistory(filter: QueryHistoryFilter = {}): Promise<{\n    entries: QueryHistoryEntry[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    let entries = Array.from(this.memoryCache.values());\n\n    // Apply filters\n    if (filter.status && filter.status.length > 0) {\n      entries = entries.filter(entry => filter.status!.includes(entry.status));\n    }\n\n    if (filter.startDate) {\n      entries = entries.filter(entry => entry.startTime >= filter.startDate!.getTime());\n    }\n\n    if (filter.endDate) {\n      entries = entries.filter(entry => entry.startTime <= filter.endDate!.getTime());\n    }\n\n    if (filter.cmd) {\n      entries = entries.filter(entry => entry.cmd.includes(filter.cmd!));\n    }\n\n    if (filter.priority && filter.priority.length > 0) {\n      entries = entries.filter(\n        entry => entry.priority && filter.priority!.includes(entry.priority)\n      );\n    }\n\n    if (filter.tags && filter.tags.length > 0) {\n      entries = entries.filter(\n        entry =>\n          entry.metadata?.tags && filter.tags!.some(tag => entry.metadata!.tags!.includes(tag))\n      );\n    }\n\n    // Sort entries\n    const sortBy = filter.sortBy || 'startTime';\n    const sortOrder = filter.sortOrder || 'desc';\n\n    entries.sort((a, b) => {\n      let aValue: unknown, bValue: unknown;\n\n      switch (sortBy) {\n        case 'startTime': {\n          aValue = a.startTime;\n          bValue = b.startTime;\n          break;\n        }\n        case 'endTime': {\n          aValue = a.endTime || 0;\n          bValue = b.endTime || 0;\n          break;\n        }\n        case 'duration': {\n          aValue = a.duration || 0;\n          bValue = b.duration || 0;\n          break;\n        }\n        case 'cmd': {\n          aValue = a.cmd;\n          bValue = b.cmd;\n          break;\n        }\n        default: {\n          aValue = a.startTime;\n          bValue = b.startTime;\n        }\n      }\n\n      if (sortOrder === 'asc') {\n        return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;\n      } else {\n        return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;\n      }\n    });\n\n    const total = entries.length;\n    const offset = filter.offset || 0;\n    const limit = filter.limit || 100;\n\n    // Apply pagination\n    const paginatedEntries = entries.slice(offset, offset + limit);\n    const hasMore = offset + limit < total;\n\n    return {\n      entries: paginatedEntries,\n      total,\n      hasMore,\n    };\n  }\n\n  /**\n   * Get a specific query by ID\n   */\n  async getQuery(queryId: string): Promise<QueryHistoryEntry | undefined> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    return this.memoryCache.get(queryId);\n  }\n\n  /**\n   * Delete a query from history\n   */\n  async deleteQuery(queryId: string): Promise<boolean> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    const deleted = this.memoryCache.delete(queryId);\n    if (deleted) {\n      // Mark for deletion in persistent storage\n      this.writeQueue.push({ id: queryId, deleted: true } as any);\n      this.emit('queryDeleted', queryId);\n      console.log(`[QueryHistoryManager] Deleted query ${queryId} from history`);\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Get comprehensive statistics about query history\n   */\n  async getStatistics(): Promise<QueryHistoryStats> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    const entries = Array.from(this.memoryCache.values());\n    const completedEntries = entries.filter(e => e.status === 'completed' && e.duration);\n\n    const stats: QueryHistoryStats = {\n      totalQueries: entries.length,\n      completedQueries: entries.filter(e => e.status === 'completed').length,\n      errorQueries: entries.filter(e => e.status === 'error').length,\n      cancelledQueries: entries.filter(e => e.status === 'cancelled').length,\n      timeoutQueries: entries.filter(e => e.status === 'timeout').length,\n      averageDuration:\n        completedEntries.length > 0\n          ? completedEntries.reduce((sum, e) => sum + (e.duration || 0), 0) /\n            completedEntries.length\n          : 0,\n      totalDuration: completedEntries.reduce((sum, e) => sum + (e.duration || 0), 0),\n      queriesByStatus: {},\n      queriesByPriority: {},\n      queriesByCmd: {},\n      dailyStats: [],\n    };\n\n    // Count by status\n    entries.forEach(entry => {\n      stats.queriesByStatus[entry.status] = (stats.queriesByStatus[entry.status] || 0) + 1;\n    });\n\n    // Count by priority\n    entries.forEach(entry => {\n      if (entry.priority) {\n        stats.queriesByPriority[entry.priority] =\n          (stats.queriesByPriority[entry.priority] || 0) + 1;\n      }\n    });\n\n    // Count by command\n    entries.forEach(entry => {\n      stats.queriesByCmd[entry.cmd] = (stats.queriesByCmd[entry.cmd] || 0) + 1;\n    });\n\n    // Generate daily stats for the last 30 days\n    const now = new Date();\n    for (let i = 29; i >= 0; i--) {\n      const date = new Date(now);\n      date.setDate(date.getDate() - i);\n      const dateStr = date.toISOString().split('T')[0] || date.toISOString().substring(0, 10);\n\n      const dayStart = new Date(date);\n      dayStart.setHours(0, 0, 0, 0);\n      const dayEnd = new Date(date);\n      dayEnd.setHours(23, 59, 59, 999);\n\n      const dayEntries = entries.filter(\n        entry => entry.startTime >= dayStart.getTime() && entry.startTime <= dayEnd.getTime()\n      );\n\n      const dayCompletedEntries = dayEntries.filter(e => e.status === 'completed' && e.duration);\n\n      stats.dailyStats.push({\n        date: dateStr,\n        count: dayEntries.length,\n        avgDuration:\n          dayCompletedEntries.length > 0\n            ? dayCompletedEntries.reduce((sum, e) => sum + (e.duration || 0), 0) /\n              dayCompletedEntries.length\n            : 0,\n      });\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get recent queries with limit\n   */\n  async getRecentQueries(limit: number = 10): Promise<\n    Array<{\n      query: string;\n      success: boolean;\n      timestamp: number;\n      result?: unknown;\n    }>\n  > {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    const entries = Array.from(this.memoryCache.values())\n      .filter(entry => entry.status === 'completed' || entry.status === 'error')\n      .sort((a, b) => b.startTime - a.startTime)\n      .slice(0, limit);\n\n    return entries.map(entry => ({\n      query: entry.cmd,\n      success: entry.status === 'completed',\n      timestamp: entry.startTime,\n      result: entry.results,\n    }));\n  }\n\n  /**\n   * Clear all history\n   */\n  async clearHistory(): Promise<void> {\n    if (!this.isInitialized) {\n      throw new Error('QueryHistoryManager not initialized');\n    }\n\n    this.memoryCache.clear();\n    this.writeQueue = [];\n\n    // Clear persistent storage\n    try {\n      if (fs.existsSync(this.historyFile)) {\n        fs.unlinkSync(this.historyFile);\n      }\n      if (fs.existsSync(this.indexFile)) {\n        fs.unlinkSync(this.indexFile);\n      }\n    } catch (error: unknown) {\n      console.error('[QueryHistoryManager] Error clearing persistent storage:', error);\n    }\n\n    this.emit('historyCleared');\n    console.log('[QueryHistoryManager] History cleared');\n  }\n\n  /**\n   * Load history from disk into memory cache\n   */\n  private async loadHistoryFromDisk(): Promise<void> {\n    if (!fs.existsSync(this.historyFile)) {\n      return;\n    }\n\n    try {\n      const data = fs.readFileSync(this.historyFile, 'utf8');\n      const lines = data\n        .trim()\n        .split('\\n')\n        .filter(line => line.trim());\n\n      for (const line of lines) {\n        try {\n          const entry: QueryHistoryEntry = JSON.parse(line);\n          if (!entry.deleted) {\n            this.memoryCache.set(entry.id, entry);\n          }\n        } catch (error: unknown) {\n          console.warn('[QueryHistoryManager] Invalid history entry:', line);\n        }\n      }\n\n      console.log(`[QueryHistoryManager] Loaded ${this.memoryCache.size} entries from disk`);\n    } catch (error: unknown) {\n      console.error('[QueryHistoryManager] Error loading history from disk:', error);\n    }\n  }\n\n  /**\n   * Start the background write processor\n   */\n  private startWriteProcessor(): void {\n    this.writeInterval = setInterval(() => {\n      this.processWriteQueue();\n    }, 5000); // Write every 5 seconds\n  }\n\n  /**\n   * Process the write queue to persist entries to disk\n   */\n  private async processWriteQueue(): Promise<void> {\n    if (this.writeQueue.length === 0) {\n      return;\n    }\n\n    const batch = this.writeQueue.splice(0, this.options.batchSize);\n\n    try {\n      const lines = batch.map(entry => JSON.stringify(entry)).join('\\n') + '\\n';\n      fs.appendFileSync(this.historyFile, lines, 'utf8');\n\n      console.log(`[QueryHistoryManager] Persisted ${batch.length} entries to disk`);\n    } catch (error: unknown) {\n      console.error('[QueryHistoryManager] Error writing to disk:', error);\n      // Put entries back in queue for retry\n      this.writeQueue.unshift(...batch);\n    }\n  }\n\n  /**\n   * Start the cleanup processor for old entries\n   */\n  private startCleanupProcessor(): void {\n    this.cleanupInterval = setInterval(\n      () => {\n        this.cleanupOldEntries();\n      },\n      24 * 60 * 60 * 1000\n    ); // Run daily\n  }\n\n  /**\n   * Clean up old entries based on retention policy\n   */\n  private async cleanupOldEntries(): Promise<void> {\n    const cutoffTime = Date.now() - this.options.retentionDays * 24 * 60 * 60 * 1000;\n    let removedCount = 0;\n\n    for (const [id, entry] of this.memoryCache.entries()) {\n      if (entry.startTime < cutoffTime) {\n        this.memoryCache.delete(id);\n        removedCount++;\n      }\n    }\n\n    if (removedCount > 0) {\n      // Rewrite the history file without old entries\n      await this.rewriteHistoryFile();\n      this.emit('historyCleanedUp', { removedCount });\n      console.log(`[QueryHistoryManager] Cleaned up ${removedCount} old entries`);\n    }\n  }\n\n  /**\n   * Enforce history size limits\n   */\n  private async enforceHistoryLimit(): Promise<void> {\n    if (this.memoryCache.size <= this.options.maxHistorySize) {\n      return;\n    }\n\n    // Remove oldest entries\n    const entries = Array.from(this.memoryCache.entries()).sort(\n      ([, a], [, b]) => a.startTime - b.startTime\n    );\n\n    const toRemove = entries.slice(0, this.memoryCache.size - this.options.maxHistorySize);\n\n    for (const [id] of toRemove) {\n      this.memoryCache.delete(id);\n    }\n\n    await this.rewriteHistoryFile();\n    console.log(`[QueryHistoryManager] Enforced history limit, removed ${toRemove.length} entries`);\n  }\n\n  /**\n   * Rewrite the entire history file (used for cleanup)\n   */\n  private async rewriteHistoryFile(): Promise<void> {\n    try {\n      const entries = Array.from(this.memoryCache.values());\n      const lines = entries.map(entry => JSON.stringify(entry)).join('\\n');\n\n      fs.writeFileSync(this.historyFile, lines + '\\n', 'utf8');\n      console.log(`[QueryHistoryManager] Rewrote history file with ${entries.length} entries`);\n    } catch (error: unknown) {\n      console.error('[QueryHistoryManager] Error rewriting history file:', error);\n    }\n  }\n\n  /**\n   * Dispose of the history manager\n   */\n  dispose(): void {\n    if (this.writeInterval) {\n      clearInterval(this.writeInterval);\n    }\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    // Process any remaining writes\n    this.processWriteQueue();\n\n    this.removeAllListeners();\n    console.log('[QueryHistoryManager] Disposed');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\queryNotificationManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\queryScheduler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":332,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":332,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\nimport { ConcurrencyManager, QueryPriority } from './concurrencyManager';\nimport { QueryHistoryManager } from './queryHistoryManager';\n\nexport interface ScheduledQuery {\n  id: string;\n  cmd: string;\n  params: Record<string, unknown>;\n  scheduleType: 'immediate' | 'delayed' | 'recurring' | 'conditional';\n  scheduleConfig: {\n    executeAt?: number; // timestamp for delayed execution\n    interval?: number; // milliseconds for recurring queries\n    maxExecutions?: number; // limit for recurring queries\n    condition?: string; // condition expression for conditional execution\n    dependencies?: string[]; // query IDs that must complete first\n  };\n  priority: QueryPriority;\n  createdAt: number;\n  lastExecutedAt?: number;\n  executionCount: number;\n  status: 'scheduled' | 'running' | 'completed' | 'failed' | 'cancelled' | 'paused';\n  metadata?: {\n    tags?: string[];\n    description?: string;\n    createdBy?: string;\n  };\n}\n\nexport interface SchedulerOptions {\n  maxScheduledQueries: number;\n  checkInterval: number;\n  enableRecurring: boolean;\n  enableConditional: boolean;\n  enableDependencies: boolean;\n  defaultPriority: QueryPriority;\n}\n\nexport interface SchedulerStats {\n  totalScheduled: number;\n  activeScheduled: number;\n  completedScheduled: number;\n  failedScheduled: number;\n  recurringQueries: number;\n  conditionalQueries: number;\n  dependentQueries: number;\n  nextExecutionTime?: number;\n}\n\n/**\n * Advanced query scheduling and queuing system\n */\nexport class QueryScheduler extends EventEmitter {\n  private options: SchedulerOptions;\n  private concurrencyManager: ConcurrencyManager;\n  private historyManager?: QueryHistoryManager;\n  private scheduledQueries: Map<string, ScheduledQuery> = new Map();\n  private schedulerInterval?: ReturnType<typeof setInterval>;\n  private dependencyGraph: Map<string, Set<string>> = new Map(); // queryId -> dependents\n  private conditionEvaluator: Map<string, () => boolean> = new Map();\n\n  constructor(\n    concurrencyManager: ConcurrencyManager,\n    historyManager?: QueryHistoryManager,\n    options: Partial<SchedulerOptions> = {}\n  ) {\n    super();\n\n    this.concurrencyManager = concurrencyManager;\n    this.historyManager = historyManager;\n\n    this.options = {\n      maxScheduledQueries: 1000,\n      checkInterval: 1000, // Check every second\n      enableRecurring: true,\n      enableConditional: true,\n      enableDependencies: true,\n      defaultPriority: {\n        level: 'normal',\n        weight: 10,\n        timeout: 30000,\n      },\n      ...options,\n    };\n\n    this.startScheduler();\n    this.setupConcurrencyManagerListeners();\n  }\n\n  /**\n   * Schedule a query for execution\n   */\n  async scheduleQuery(\n    id: string,\n    cmd: string,\n    params: Record<string, unknown> = {},\n    scheduleType: ScheduledQuery['scheduleType'] = 'immediate',\n    scheduleConfig: ScheduledQuery['scheduleConfig'] = {},\n    priority: Partial<QueryPriority> = {},\n    metadata?: ScheduledQuery['metadata']\n  ): Promise<void> {\n    if (this.scheduledQueries.size >= this.options.maxScheduledQueries) {\n      throw new Error('Maximum number of scheduled queries reached');\n    }\n\n    if (this.scheduledQueries.has(id)) {\n      throw new Error(`Query with ID ${id} is already scheduled`);\n    }\n\n    const scheduledQuery: ScheduledQuery = {\n      id,\n      cmd,\n      params,\n      scheduleType,\n      scheduleConfig,\n      priority: { ...this.options.defaultPriority, ...priority },\n      createdAt: Date.now(),\n      executionCount: 0,\n      status: 'scheduled',\n      metadata,\n    };\n\n    // Validate schedule configuration\n    this.validateScheduleConfig(scheduledQuery);\n\n    // Set up dependencies if specified\n    if (scheduleConfig.dependencies && this.options.enableDependencies) {\n      this.setupDependencies(id, scheduleConfig.dependencies);\n    }\n\n    // Set up condition evaluator if specified\n    if (scheduleConfig.condition && this.options.enableConditional) {\n      this.setupConditionEvaluator(id, scheduleConfig.condition);\n    }\n\n    this.scheduledQueries.set(id, scheduledQuery);\n\n    this.emit('queryScheduled', scheduledQuery);\n    console.log(`[QueryScheduler] Scheduled query ${id} (type: ${scheduleType})`);\n\n    // If it's an immediate query, try to execute it right away\n    if (scheduleType === 'immediate') {\n      await this.tryExecuteQuery(scheduledQuery);\n    }\n  }\n\n  /**\n   * Cancel a scheduled query\n   */\n  async cancelScheduledQuery(queryId: string): Promise<boolean> {\n    const scheduledQuery = this.scheduledQueries.get(queryId);\n    if (!scheduledQuery) {\n      return false;\n    }\n\n    // If the query is currently running, cancel it in the concurrency manager\n    if (scheduledQuery.status === 'running') {\n      this.concurrencyManager.cancelQuery(queryId);\n    }\n\n    scheduledQuery.status = 'cancelled';\n    this.scheduledQueries.delete(queryId);\n\n    // Clean up dependencies\n    this.cleanupDependencies(queryId);\n\n    this.emit('queryScheduleCancelled', queryId);\n    console.log(`[QueryScheduler] Cancelled scheduled query ${queryId}`);\n    return true;\n  }\n\n  /**\n   * Pause a recurring query\n   */\n  async pauseRecurringQuery(queryId: string): Promise<boolean> {\n    const scheduledQuery = this.scheduledQueries.get(queryId);\n    if (!scheduledQuery || scheduledQuery.scheduleType !== 'recurring') {\n      return false;\n    }\n\n    scheduledQuery.status = 'paused';\n    this.emit('querySchedulePaused', queryId);\n    console.log(`[QueryScheduler] Paused recurring query ${queryId}`);\n    return true;\n  }\n\n  /**\n   * Resume a paused recurring query\n   */\n  async resumeRecurringQuery(queryId: string): Promise<boolean> {\n    const scheduledQuery = this.scheduledQueries.get(queryId);\n    if (!scheduledQuery || scheduledQuery.status !== 'paused') {\n      return false;\n    }\n\n    scheduledQuery.status = 'scheduled';\n    this.emit('queryScheduleResumed', queryId);\n    console.log(`[QueryScheduler] Resumed recurring query ${queryId}`);\n    return true;\n  }\n\n  /**\n   * Get all scheduled queries with optional filtering\n   */\n  getScheduledQueries(filter?: {\n    status?: ScheduledQuery['status'][];\n    scheduleType?: ScheduledQuery['scheduleType'][];\n    tags?: string[];\n  }): ScheduledQuery[] {\n    let queries = Array.from(this.scheduledQueries.values());\n\n    if (filter?.status) {\n      queries = queries.filter(q => filter.status!.includes(q.status));\n    }\n\n    if (filter?.scheduleType) {\n      queries = queries.filter(q => filter.scheduleType!.includes(q.scheduleType));\n    }\n\n    if (filter?.tags) {\n      queries = queries.filter(\n        q => q.metadata?.tags && filter.tags!.some(tag => q.metadata!.tags!.includes(tag))\n      );\n    }\n\n    return queries.sort((a, b) => a.createdAt - b.createdAt);\n  }\n\n  /**\n   * Get scheduler statistics\n   */\n  getStatistics(): SchedulerStats {\n    const queries = Array.from(this.scheduledQueries.values());\n\n    const nextExecution = queries\n      .filter(q => q.scheduleType === 'delayed' && q.scheduleConfig.executeAt)\n      .map(q => q.scheduleConfig.executeAt!)\n      .sort((a, b) => a - b)[0];\n\n    return {\n      totalScheduled: queries.length,\n      activeScheduled: queries.filter(q => ['scheduled', 'running'].includes(q.status)).length,\n      completedScheduled: queries.filter(q => q.status === 'completed').length,\n      failedScheduled: queries.filter(q => q.status === 'failed').length,\n      recurringQueries: queries.filter(q => q.scheduleType === 'recurring').length,\n      conditionalQueries: queries.filter(q => q.scheduleType === 'conditional').length,\n      dependentQueries: queries.filter(q => q.scheduleConfig.dependencies?.length).length,\n      nextExecutionTime: nextExecution,\n    };\n  }\n\n  /**\n   * Register a custom condition evaluator\n   */\n  registerConditionEvaluator(queryId: string, evaluator: () => boolean): void {\n    this.conditionEvaluator.set(queryId, evaluator);\n  }\n\n  /**\n   * Validate schedule configuration\n   */\n  private validateScheduleConfig(query: ScheduledQuery): void {\n    const { scheduleType, scheduleConfig } = query;\n\n    switch (scheduleType) {\n      case 'delayed': {\n        if (!scheduleConfig.executeAt || scheduleConfig.executeAt <= Date.now()) {\n          throw new Error('Delayed queries must have a future executeAt timestamp');\n        }\n        break;\n      }\n      case 'recurring': {\n        if (!this.options.enableRecurring) {\n          throw new Error('Recurring queries are disabled');\n        }\n        if (!scheduleConfig.interval || scheduleConfig.interval < 1000) {\n          throw new Error('Recurring queries must have an interval of at least 1000ms');\n        }\n        break;\n      }\n      case 'conditional': {\n        if (!this.options.enableConditional) {\n          throw new Error('Conditional queries are disabled');\n        }\n        if (!scheduleConfig.condition) {\n          throw new Error('Conditional queries must have a condition');\n        }\n        break;\n      }\n    }\n\n    if (scheduleConfig.dependencies && !this.options.enableDependencies) {\n      throw new Error('Query dependencies are disabled');\n    }\n  }\n\n  /**\n   * Set up query dependencies\n   */\n  private setupDependencies(queryId: string, dependencies: string[]): void {\n    for (const depId of dependencies) {\n      if (!this.dependencyGraph.has(depId)) {\n        this.dependencyGraph.set(depId, new Set());\n      }\n      this.dependencyGraph.get(depId)!.add(queryId);\n    }\n  }\n\n  /**\n   * Clean up dependencies for a query\n   */\n  private cleanupDependencies(queryId: string): void {\n    // Remove this query as a dependent of others\n    for (const [depId, dependents] of this.dependencyGraph.entries()) {\n      dependents.delete(queryId);\n      if (dependents.size === 0) {\n        this.dependencyGraph.delete(depId);\n      }\n    }\n\n    // Remove this query's own dependencies\n    this.dependencyGraph.delete(queryId);\n  }\n\n  /**\n   * Set up condition evaluator\n   */\n  private setupConditionEvaluator(queryId: string, condition: string): void {\n    // Simple condition evaluator - in a real implementation, this would be more sophisticated\n    try {\n      const evaluator = new Function('return ' + condition) as () => boolean;\n      this.conditionEvaluator.set(queryId, evaluator);\n    } catch (_error: unknown) {\n      throw new Error(`Invalid condition expression: ${condition}`);\n    }\n  }\n\n  /**\n   * Start the scheduler loop\n   */\n  private startScheduler(): void {\n    this.schedulerInterval = setInterval(() => {\n      this.processScheduledQueries();\n    }, this.options.checkInterval);\n  }\n\n  /**\n   * Process all scheduled queries\n   */\n  private async processScheduledQueries(): Promise<void> {\n    const now = Date.now();\n    const queries = Array.from(this.scheduledQueries.values());\n\n    for (const query of queries) {\n      if (query.status !== 'scheduled') {\n        continue;\n      }\n\n      try {\n        if (await this.shouldExecuteQuery(query, now)) {\n          await this.tryExecuteQuery(query);\n        }\n      } catch (error: unknown) {\n        console.error(`[QueryScheduler] Error processing query ${query.id}:`, error);\n        query.status = 'failed';\n        this.emit('queryScheduleError', { queryId: query.id, error });\n      }\n    }\n\n    // Clean up completed non-recurring queries\n    this.cleanupCompletedQueries();\n  }\n\n  /**\n   * Check if a query should be executed\n   */\n  private async shouldExecuteQuery(query: ScheduledQuery, now: number): Promise<boolean> {\n    switch (query.scheduleType) {\n      case 'immediate': {\n        return true;\n      }\n      case 'delayed': {\n        return query.scheduleConfig.executeAt! <= now;\n      }\n      case 'recurring': {\n        if (query.status === 'paused') {\n          return false;\n        }\n\n        if (!query.lastExecutedAt) {\n          return true; // First execution\n        }\n\n        const timeSinceLastExecution = now - query.lastExecutedAt;\n        const shouldExecute = timeSinceLastExecution >= query.scheduleConfig.interval!;\n\n        // Check max executions limit\n        if (shouldExecute && query.scheduleConfig.maxExecutions) {\n          return query.executionCount < query.scheduleConfig.maxExecutions;\n        }\n\n        return shouldExecute;\n      }\n      case 'conditional': {\n        const evaluator = this.conditionEvaluator.get(query.id);\n        if (!evaluator) {\n          return false;\n        }\n\n        try {\n          return evaluator();\n        } catch (error: unknown) {\n          console.error(`[QueryScheduler] Condition evaluation error for ${query.id}:`, error);\n          return false;\n        }\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Try to execute a scheduled query\n   */\n  private async tryExecuteQuery(query: ScheduledQuery): Promise<void> {\n    // Check dependencies\n    if (\n      query.scheduleConfig.dependencies &&\n      !this.areDependenciesSatisfied(query.scheduleConfig.dependencies)\n    ) {\n      return; // Dependencies not satisfied yet\n    }\n\n    try {\n      query.status = 'running';\n      query.lastExecutedAt = Date.now();\n      query.executionCount++;\n\n      this.emit('queryScheduleExecutionStarted', query);\n\n      // Queue the query in the concurrency manager\n      await this.concurrencyManager.queueQuery(query.id, query.cmd, query.params, query.priority);\n    } catch (error: unknown) {\n      query.status = 'failed';\n      this.emit('queryScheduleExecutionFailed', { query, error });\n      console.error(`[QueryScheduler] Failed to execute query ${query.id}:`, error);\n    }\n  }\n\n  /**\n   * Check if all dependencies are satisfied\n   */\n  private areDependenciesSatisfied(dependencies: string[]): boolean {\n    return dependencies.every(depId => {\n      const depQuery = this.scheduledQueries.get(depId);\n      return depQuery && depQuery.status === 'completed';\n    });\n  }\n\n  /**\n   * Set up listeners for concurrency manager events\n   */\n  private setupConcurrencyManagerListeners(): void {\n    this.concurrencyManager.on('queryCompleted', event => {\n      this.handleQueryCompletion(event.queryId, event.success, event.error);\n    });\n\n    this.concurrencyManager.on('queryCancelled', event => {\n      this.handleQueryCancellation(event.queryId);\n    });\n  }\n\n  /**\n   * Handle query completion from concurrency manager\n   */\n  private handleQueryCompletion(queryId: string, success: boolean, error?: string): void {\n    const query = this.scheduledQueries.get(queryId);\n    if (!query) {\n      return;\n    }\n\n    if (success) {\n      // Handle recurring queries\n      if (query.scheduleType === 'recurring') {\n        // Check if we've reached max executions\n        if (\n          query.scheduleConfig.maxExecutions &&\n          query.executionCount >= query.scheduleConfig.maxExecutions\n        ) {\n          query.status = 'completed';\n          this.emit('queryScheduleCompleted', query);\n        } else {\n          // Reset to scheduled for next execution\n          query.status = 'scheduled';\n          this.emit('queryScheduleRecurring', query);\n        }\n      } else {\n        query.status = 'completed';\n        this.emit('queryScheduleCompleted', query);\n      }\n\n      // Trigger dependent queries\n      this.triggerDependentQueries(queryId);\n    } else {\n      query.status = 'failed';\n      this.emit('queryScheduleFailed', { query, error });\n    }\n\n    // Add to history if history manager is available\n    if (this.historyManager) {\n      this.historyManager.addQuery({\n        id: queryId,\n        cmd: query.cmd,\n        params: query.params,\n        status: success ? 'completed' : 'error',\n        startTime: query.lastExecutedAt!,\n        endTime: Date.now(),\n        error: error,\n        priority: query.priority.level,\n        metadata: {\n          tags: query.metadata?.tags,\n          sessionId: 'scheduler',\n        },\n      });\n    }\n  }\n\n  /**\n   * Handle query cancellation from concurrency manager\n   */\n  private handleQueryCancellation(queryId: string): void {\n    const query = this.scheduledQueries.get(queryId);\n    if (query) {\n      query.status = 'cancelled';\n      this.emit('queryScheduleCancelled', queryId);\n    }\n  }\n\n  /**\n   * Trigger queries that depend on the completed query\n   */\n  private triggerDependentQueries(completedQueryId: string): void {\n    const dependents = this.dependencyGraph.get(completedQueryId);\n    if (!dependents) {\n      return;\n    }\n\n    for (const dependentId of dependents) {\n      const dependentQuery = this.scheduledQueries.get(dependentId);\n      if (dependentQuery && dependentQuery.status === 'scheduled') {\n        // Check if all dependencies are now satisfied\n        if (this.areDependenciesSatisfied(dependentQuery.scheduleConfig.dependencies || [])) {\n          this.tryExecuteQuery(dependentQuery);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clean up completed non-recurring queries\n   */\n  private cleanupCompletedQueries(): void {\n    const toRemove: string[] = [];\n\n    for (const [id, query] of this.scheduledQueries.entries()) {\n      if (\n        ['completed', 'failed', 'cancelled'].includes(query.status) &&\n        query.scheduleType !== 'recurring'\n      ) {\n        // Keep completed queries for a while before cleanup\n        const timeSinceCompletion = Date.now() - (query.lastExecutedAt || query.createdAt);\n        if (timeSinceCompletion > 5 * 60 * 1000) {\n          // 5 minutes\n          toRemove.push(id);\n        }\n      }\n    }\n\n    for (const id of toRemove) {\n      this.scheduledQueries.delete(id);\n      this.cleanupDependencies(id);\n      this.conditionEvaluator.delete(id);\n    }\n\n    if (toRemove.length > 0) {\n      console.log(`[QueryScheduler] Cleaned up ${toRemove.length} completed queries`);\n    }\n  }\n\n  /**\n   * Dispose of the scheduler\n   */\n  dispose(): void {\n    if (this.schedulerInterval) {\n      clearInterval(this.schedulerInterval);\n    }\n\n    // Cancel all scheduled queries\n    for (const [id] of this.scheduledQueries.entries()) {\n      this.cancelScheduledQuery(id);\n    }\n\n    this.scheduledQueries.clear();\n    this.dependencyGraph.clear();\n    this.conditionEvaluator.clear();\n    this.removeAllListeners();\n\n    console.log('[QueryScheduler] Disposed');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\referenceProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\securityAuditor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\securityManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":3,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used.","line":4,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'queryId' is assigned a value but never used.","line":594,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":594,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\nimport { spawn, ChildProcess } from 'child_process';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nexport interface SecurityConfig {\n  sandboxing: {\n    enabled: boolean;\n    isolatedProcesses: boolean;\n    fileSystemRestrictions: string[];\n    networkAccess: boolean;\n    dangerousPredicates: string[];\n  };\n  resourceLimits: {\n    maxInferenceSteps: number;\n    maxCallDepth: number;\n    maxChoicePoints: number;\n    maxMemoryPerQuery: number; // in MB\n    maxExecutionTime: number; // in milliseconds\n  };\n  queryValidation: {\n    syntaxChecking: boolean;\n    predicateBlacklist: string[];\n    maxQueryLength: number;\n  };\n}\n\nexport interface QuerySecurityContext {\n  userId: string;\n  role: string;\n  permissions: string[];\n  trusted: boolean;\n  resourceQuota: ResourceQuota;\n}\n\nexport interface ResourceQuota {\n  maxConcurrentQueries: number;\n  maxSessionsPerUser: number;\n  maxQueryTime: number;\n  maxMemoryPerQuery: number;\n  maxResultsPerQuery: number;\n  rateLimitPerMinute: number;\n}\n\nexport interface SecurityViolation {\n  type: 'dangerous_predicate' | 'resource_limit' | 'syntax_error' | 'permission_denied';\n  message: string;\n  query?: string;\n  userId?: string;\n  timestamp: Date;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n}\n\n/**\n * Security Manager for Prolog query execution\n * Handles sandboxing, resource quotas, and query validation\n */\nexport class SecurityManager extends EventEmitter {\n  private config: SecurityConfig;\n  private activeProcesses: Map<string, ChildProcess> = new Map();\n  private userResourceUsage: Map<\n    string,\n    {\n      activeQueries: number;\n      activeSessions: number;\n      lastActivity: Date;\n      requestCount: number;\n      requestWindow: Date;\n    }\n  > = new Map();\n\n  constructor(config: SecurityConfig) {\n    super();\n    this.config = config;\n    this.setupCleanupInterval();\n  }\n\n  /**\n   * Validate a query before execution\n   */\n  async validateQuery(\n    query: string,\n    context: QuerySecurityContext\n  ): Promise<{\n    valid: boolean;\n    violations: SecurityViolation[];\n  }> {\n    const violations: SecurityViolation[] = [];\n\n    // Check query length\n    if (query.length > this.config.queryValidation.maxQueryLength) {\n      violations.push({\n        type: 'syntax_error',\n        message: `Query exceeds maximum length of ${this.config.queryValidation.maxQueryLength} characters`,\n        query,\n        userId: context.userId,\n        timestamp: new Date(),\n        severity: 'medium',\n      });\n    }\n\n    // Check for dangerous predicates\n    if (!context.trusted) {\n      const dangerousPredicates = this.config.sandboxing.dangerousPredicates;\n      for (const predicate of dangerousPredicates) {\n        if (query.includes(predicate)) {\n          violations.push({\n            type: 'dangerous_predicate',\n            message: `Query contains dangerous predicate: ${predicate}`,\n            query,\n            userId: context.userId,\n            timestamp: new Date(),\n            severity: 'high',\n          });\n        }\n      }\n    }\n\n    // Check resource quotas\n    const resourceViolations = await this.checkResourceQuotas(context);\n    violations.push(...resourceViolations);\n\n    // Syntax validation (if enabled)\n    if (this.config.queryValidation.syntaxChecking) {\n      const syntaxViolations = await this.validateSyntax(query);\n      violations.push(...syntaxViolations);\n    }\n\n    // Emit security events\n    for (const violation of violations) {\n      this.emit('securityViolation', violation);\n    }\n\n    return {\n      valid: violations.length === 0,\n      violations,\n    };\n  }\n\n  /**\n   * Execute query in sandbox if required\n   */\n  async executeSecureQuery(\n    query: string,\n    context: QuerySecurityContext,\n    originalExecutor: (query: string) => Promise<any>\n  ): Promise<any> {\n    // Validate query first\n    const validation = await this.validateQuery(query, context);\n    if (!validation.valid) {\n      throw new Error(\n        `Security validation failed: ${validation.violations.map(v => v.message).join(', ')}`\n      );\n    }\n\n    // Update resource usage tracking\n    this.updateResourceUsage(context.userId);\n\n    // Execute in sandbox if required for untrusted users\n    if (this.config.sandboxing.enabled && !context.trusted) {\n      return await this.executeSandboxedQuery(query, context);\n    } else {\n      // Execute normally with resource limits\n      return await this.executeWithResourceLimits(query, context, originalExecutor);\n    }\n  }\n\n  /**\n   * Execute query in isolated sandbox process\n   */\n  private async executeSandboxedQuery(query: string, context: QuerySecurityContext): Promise<any> {\n    const queryId = `sandbox_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    return new Promise((resolve, reject) => {\n      // Create sandbox configuration\n      const sandboxConfig = {\n        query,\n        resourceLimits: this.config.resourceLimits,\n        allowedPredicates: this.getAllowedPredicates(context),\n        timeout: context.resourceQuota.maxQueryTime,\n      };\n\n      // Spawn isolated Prolog process\n      const sandboxProcess = spawn(\n        'swipl',\n        ['-g', 'halt', '--quiet', '--no-tty', '-t', 'halt(1)'],\n        {\n          stdio: ['pipe', 'pipe', 'pipe'],\n          timeout: context.resourceQuota.maxQueryTime,\n          env: {\n            ...process.env,\n            PROLOG_STACK_LIMIT: `${context.resourceQuota.maxMemoryPerQuery}M`,\n            PROLOG_TABLE_SPACE: `${Math.floor(context.resourceQuota.maxMemoryPerQuery / 4)}M`,\n          },\n        }\n      );\n\n      this.activeProcesses.set(queryId, sandboxProcess);\n\n      let output = '';\n      let errorOutput = '';\n\n      sandboxProcess.stdout?.on('data', data => {\n        output += data.toString();\n      });\n\n      sandboxProcess.stderr?.on('data', data => {\n        errorOutput += data.toString();\n      });\n\n      sandboxProcess.on('close', code => {\n        this.activeProcesses.delete(queryId);\n\n        if (code === 0) {\n          try {\n            const result = this.parseSandboxOutput(output);\n            resolve(result);\n          } catch (error) {\n            reject(new Error(`Failed to parse sandbox output: ${error}`));\n          }\n        } else {\n          reject(new Error(`Sandbox execution failed: ${errorOutput}`));\n        }\n      });\n\n      sandboxProcess.on('error', error => {\n        this.activeProcesses.delete(queryId);\n        reject(new Error(`Sandbox process error: ${error.message}`));\n      });\n\n      // Send query to sandbox process\n      const sandboxQuery = this.buildSandboxQuery(query, sandboxConfig);\n      sandboxProcess.stdin?.write(sandboxQuery);\n      sandboxProcess.stdin?.end();\n\n      // Set timeout\n      setTimeout(() => {\n        if (this.activeProcesses.has(queryId)) {\n          sandboxProcess.kill('SIGKILL');\n          this.activeProcesses.delete(queryId);\n          reject(new Error('Query execution timeout in sandbox'));\n        }\n      }, context.resourceQuota.maxQueryTime);\n    });\n  }\n\n  /**\n   * Execute query with resource limits but not in sandbox\n   */\n  private async executeWithResourceLimits(\n    query: string,\n    context: QuerySecurityContext,\n    originalExecutor: (query: string) => Promise<any>\n  ): Promise<any> {\n    const startTime = Date.now();\n    const queryId = `limited_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Set up timeout\n    const timeoutPromise = new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Query execution timeout: ${context.resourceQuota.maxQueryTime}ms`));\n      }, context.resourceQuota.maxQueryTime);\n    });\n\n    // Execute with resource monitoring\n    const executionPromise = originalExecutor(query).then(result => {\n      const executionTime = Date.now() - startTime;\n\n      // Log resource usage\n      this.emit('resourceUsage', {\n        queryId,\n        userId: context.userId,\n        executionTime,\n        memoryUsage: process.memoryUsage(),\n        resultCount: Array.isArray(result.results) ? result.results.length : 0,\n      });\n\n      // Check result limits\n      if (\n        Array.isArray(result.results) &&\n        result.results.length > context.resourceQuota.maxResultsPerQuery\n      ) {\n        result.results = result.results.slice(0, context.resourceQuota.maxResultsPerQuery);\n        result.truncated = true;\n        result.truncatedAt = context.resourceQuota.maxResultsPerQuery;\n      }\n\n      return result;\n    });\n\n    return Promise.race([executionPromise, timeoutPromise]);\n  }\n\n  /**\n   * Check resource quotas for user\n   */\n  private async checkResourceQuotas(context: QuerySecurityContext): Promise<SecurityViolation[]> {\n    const violations: SecurityViolation[] = [];\n    const usage = this.getUserResourceUsage(context.userId || 'anonymous');\n    const quota = context.resourceQuota;\n\n    // Check concurrent queries\n    if (usage.activeQueries >= quota.maxConcurrentQueries) {\n      violations.push({\n        type: 'resource_limit',\n        message: `Maximum concurrent queries exceeded: ${usage.activeQueries}/${quota.maxConcurrentQueries}`,\n        userId: context.userId,\n        timestamp: new Date(),\n        severity: 'medium',\n      });\n    }\n\n    // Check session limit\n    if (usage.activeSessions >= quota.maxSessionsPerUser) {\n      violations.push({\n        type: 'resource_limit',\n        message: `Maximum sessions exceeded: ${usage.activeSessions}/${quota.maxSessionsPerUser}`,\n        userId: context.userId,\n        timestamp: new Date(),\n        severity: 'medium',\n      });\n    }\n\n    // Check rate limiting\n    const now = new Date();\n    const windowStart = new Date(now.getTime() - 60000); // 1 minute window\n\n    if (usage.requestWindow < windowStart) {\n      // Reset window\n      usage.requestCount = 0;\n      usage.requestWindow = now;\n    }\n\n    if (usage.requestCount >= quota.rateLimitPerMinute) {\n      violations.push({\n        type: 'resource_limit',\n        message: `Rate limit exceeded: ${usage.requestCount}/${quota.rateLimitPerMinute} requests per minute`,\n        userId: context.userId,\n        timestamp: new Date(),\n        severity: 'high',\n      });\n    }\n\n    return violations;\n  }\n\n  /**\n   * Validate Prolog syntax\n   */\n  private async validateSyntax(query: string): Promise<SecurityViolation[]> {\n    const violations: SecurityViolation[] = [];\n\n    try {\n      // Basic syntax checks\n      const balanced = this.checkBalancedParentheses(query);\n      if (!balanced) {\n        violations.push({\n          type: 'syntax_error',\n          message: 'Unbalanced parentheses in query',\n          query,\n          timestamp: new Date(),\n          severity: 'medium',\n        });\n      }\n\n      // Check for valid Prolog structure\n      if (!this.isValidPrologStructure(query)) {\n        violations.push({\n          type: 'syntax_error',\n          message: 'Invalid Prolog syntax structure',\n          query,\n          timestamp: new Date(),\n          severity: 'medium',\n        });\n      }\n    } catch (error) {\n      violations.push({\n        type: 'syntax_error',\n        message: `Syntax validation error: ${error}`,\n        query,\n        timestamp: new Date(),\n        severity: 'low',\n      });\n    }\n\n    return violations;\n  }\n\n  /**\n   * Get user resource usage, creating if not exists\n   */\n  private getUserResourceUsage(userId: string) {\n    if (!this.userResourceUsage.has(userId)) {\n      this.userResourceUsage.set(userId, {\n        activeQueries: 0,\n        activeSessions: 0,\n        lastActivity: new Date(),\n        requestCount: 0,\n        requestWindow: new Date(),\n      });\n    }\n    return this.userResourceUsage.get(userId)!;\n  }\n\n  /**\n   * Update resource usage for user\n   */\n  private updateResourceUsage(userId: string): void {\n    const usage = this.getUserResourceUsage(userId);\n    usage.activeQueries++;\n    usage.requestCount++;\n    usage.lastActivity = new Date();\n  }\n\n  /**\n   * Get allowed predicates for security context\n   */\n  private getAllowedPredicates(context: QuerySecurityContext): string[] {\n    const basePredicate = [\n      'member/2',\n      'append/3',\n      'length/2',\n      'reverse/2',\n      'sort/2',\n      'findall/3',\n      'bagof/3',\n      'setof/3',\n      'forall/2',\n      'between/3',\n      'succ/2',\n      'plus/3',\n      'is/2',\n      '=/2',\n      '\\\\=/2',\n      '==/2',\n      '\\\\==/2',\n      '@</2',\n      '@>/2',\n      'var/1',\n      'nonvar/1',\n      'atom/1',\n      'number/1',\n      'compound/1',\n      'functor/3',\n      'arg/3',\n      '=../2',\n      'copy_term/2',\n    ];\n\n    if (context.role === 'admin') {\n      return ['*']; // Admin can use any predicate\n    }\n\n    if (context.trusted) {\n      return [...basePredicate, 'assert/1', 'retract/1', 'retractall/1'];\n    }\n\n    return basePredicate;\n  }\n\n  /**\n   * Build sandbox query with security constraints\n   */\n  private buildSandboxQuery(query: string, config: any): string {\n    return `\n      % Set resource limits\n      set_prolog_flag(stack_limit, ${config.resourceLimits.maxMemoryPerQuery * 1024 * 1024}).\n      set_prolog_flag(table_space, ${Math.floor(config.resourceLimits.maxMemoryPerQuery / 4) * 1024 * 1024}).\n      \n      % Disable dangerous predicates\n      :- abolish(shell/1).\n      :- abolish(system/1).\n      :- abolish(halt/0).\n      :- abolish(halt/1).\n      :- abolish(abort/0).\n      \n      % Execute query with error handling\n      sandbox_query :-\n        catch(\n          (${query}),\n          Error,\n          (write('ERROR: '), write(Error), nl)\n        ).\n      \n      % Run query and output results\n      :- sandbox_query.\n    `;\n  }\n\n  /**\n   * Parse output from sandbox execution\n   */\n  private parseSandboxOutput(output: string): any {\n    try {\n      // Simple parsing - in production, this would be more sophisticated\n      const lines = output.trim().split('\\n');\n      const results = [];\n\n      for (const line of lines) {\n        if (line.startsWith('ERROR:')) {\n          throw new Error(line.substring(6).trim());\n        }\n        if (line.trim() && !line.startsWith('%')) {\n          results.push({ solution: line.trim() });\n        }\n      }\n\n      return {\n        status: 'ok',\n        results,\n        sandboxed: true,\n      };\n    } catch (error) {\n      throw new Error(`Failed to parse sandbox output: ${error}`);\n    }\n  }\n\n  /**\n   * Check if parentheses are balanced\n   */\n  private checkBalancedParentheses(query: string): boolean {\n    let count = 0;\n    for (const char of query) {\n      if (char === '(') count++;\n      if (char === ')') count--;\n      if (count < 0) return false;\n    }\n    return count === 0;\n  }\n\n  /**\n   * Basic Prolog structure validation\n   */\n  private isValidPrologStructure(query: string): boolean {\n    // Very basic validation - in production, use proper Prolog parser\n    const trimmed = query.trim();\n    if (!trimmed) return false;\n\n    // Check for basic Prolog patterns\n    const prologPattern =\n      /^[a-zA-Z_][a-zA-Z0-9_]*(\\([^)]*\\))?(,\\s*[a-zA-Z_][a-zA-Z0-9_]*(\\([^)]*\\))?)*\\.?$/;\n    return prologPattern.test(trimmed.replace(/\\s+/g, ' '));\n  }\n\n  /**\n   * Clean up inactive processes and old usage data\n   */\n  private setupCleanupInterval(): void {\n    setInterval(() => {\n      const now = new Date();\n      const maxAge = 5 * 60 * 1000; // 5 minutes\n\n      // Clean up old resource usage data\n      for (const [userId, usage] of this.userResourceUsage.entries()) {\n        if (now.getTime() - usage.lastActivity.getTime() > maxAge) {\n          this.userResourceUsage.delete(userId);\n        }\n      }\n\n      // Clean up zombie processes\n      for (const [queryId, process] of this.activeProcesses.entries()) {\n        if (!process.killed && process.exitCode === null) {\n          const age = now.getTime() - parseInt(queryId.split('_')[1]);\n          if (age > maxAge) {\n            process.kill('SIGTERM');\n            this.activeProcesses.delete(queryId);\n          }\n        }\n      }\n    }, 60000); // Run every minute\n  }\n\n  /**\n   * Get security statistics\n   */\n  getSecurityStatistics(): {\n    activeProcesses: number;\n    trackedUsers: number;\n    totalViolations: number;\n    resourceUsage: Map<string, any>;\n  } {\n    return {\n      activeProcesses: this.activeProcesses.size,\n      trackedUsers: this.userResourceUsage.size,\n      totalViolations: this.listenerCount('securityViolation'),\n      resourceUsage: this.userResourceUsage,\n    };\n  }\n\n  /**\n   * Kill all active sandbox processes\n   */\n  async shutdown(): Promise<void> {\n    for (const [queryId, process] of this.activeProcesses.entries()) {\n      if (!process.killed) {\n        process.kill('SIGTERM');\n      }\n    }\n    this.activeProcesses.clear();\n    this.userResourceUsage.clear();\n  }\n}\n\n/**\n * Default security configuration\n */\nexport const defaultSecurityConfig: SecurityConfig = {\n  sandboxing: {\n    enabled: true,\n    isolatedProcesses: true,\n    fileSystemRestrictions: ['/tmp', '/var/tmp'],\n    networkAccess: false,\n    dangerousPredicates: [\n      'shell/1',\n      'system/1',\n      'exec/1',\n      'open/3',\n      'close/1',\n      'read/2',\n      'write/2',\n      'see/1',\n      'tell/1',\n      'seen/0',\n      'told/0',\n      'halt/0',\n      'halt/1',\n      'abort/0',\n      'load_files/1',\n      'consult/1',\n      'include/1',\n      'use_module/1',\n      'use_module/2',\n    ],\n  },\n  resourceLimits: {\n    maxInferenceSteps: 100000,\n    maxCallDepth: 1000,\n    maxChoicePoints: 10000,\n    maxMemoryPerQuery: 100, // MB\n    maxExecutionTime: 30000, // 30 seconds\n  },\n  queryValidation: {\n    syntaxChecking: true,\n    predicateBlacklist: [\n      'shell',\n      'system',\n      'exec',\n      'halt',\n      'abort',\n      'open',\n      'close',\n      'read',\n      'write',\n      'see',\n      'tell',\n    ],\n    maxQueryLength: 10000,\n  },\n};\n\n/**\n * Get default resource quota for role\n */\nexport function getDefaultResourceQuota(role: string): ResourceQuota {\n  const quotas: { [role: string]: ResourceQuota } = {\n    admin: {\n      maxConcurrentQueries: 100,\n      maxSessionsPerUser: 50,\n      maxQueryTime: 300000, // 5 minutes\n      maxMemoryPerQuery: 500, // MB\n      maxResultsPerQuery: 10000,\n      rateLimitPerMinute: 1000,\n    },\n    agent: {\n      maxConcurrentQueries: 10,\n      maxSessionsPerUser: 10,\n      maxQueryTime: 60000, // 1 minute\n      maxMemoryPerQuery: 100, // MB\n      maxResultsPerQuery: 1000,\n      rateLimitPerMinute: 60,\n    },\n    readonly: {\n      maxConcurrentQueries: 5,\n      maxSessionsPerUser: 5,\n      maxQueryTime: 30000, // 30 seconds\n      maxMemoryPerQuery: 50, // MB\n      maxResultsPerQuery: 500,\n      rateLimitPerMinute: 30,\n    },\n    limited: {\n      maxConcurrentQueries: 2,\n      maxSessionsPerUser: 2,\n      maxQueryTime: 10000, // 10 seconds\n      maxMemoryPerQuery: 25, // MB\n      maxResultsPerQuery: 100,\n      rateLimitPerMinute: 10,\n    },\n  };\n\n  return quotas[role] || quotas['limited'];\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\sessionManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\settingsWebviewProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":2,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'InstallationStatus' is defined but never used.","line":4,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":21,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { InstallationChecker, InstallationStatus } from './installationChecker';\nimport { InstallationGuide } from './installationGuide';\nimport { PlatformUtils } from '../utils/platformUtils';\n\nexport class SettingsWebviewProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'prologSettings';\n  private _view?: vscode.WebviewView;\n  private installationChecker: InstallationChecker;\n  private installationGuide: InstallationGuide;\n\n  constructor(private readonly _extensionUri: vscode.Uri) {\n    this.installationChecker = InstallationChecker.getInstance();\n    this.installationGuide = InstallationGuide.getInstance();\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    this._view = webviewView;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._extensionUri],\n    };\n\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    // Handle messages from the webview\n    webviewView.webview.onDidReceiveMessage(\n      async message => {\n        switch (message.type) {\n          case 'updateSetting': {\n            this._updateSetting(message.key, message.value);\n            break;\n          }\n          case 'resetSettings': {\n            this._resetSettings();\n            break;\n          }\n          case 'exportSettings': {\n            this._exportSettings();\n            break;\n          }\n          case 'importSettings': {\n            this._importSettings();\n            break;\n          }\n          case 'validateSetting': {\n            this._validateSetting(message.key, message.value);\n            break;\n          }\n          case 'getSettings': {\n            this._sendCurrentSettings();\n            break;\n          }\n          case 'checkInstallation': {\n            this._checkInstallation();\n            break;\n          }\n          case 'autoDetectPath': {\n            this._autoDetectPath();\n            break;\n          }\n          case 'testInstallation': {\n            this._testInstallation();\n            break;\n          }\n          case 'runSetupWizard': {\n            await this.installationGuide.runSetupWizard();\n            break;\n          }\n          case 'showInstallationGuide': {\n            await this.installationGuide.showInstallationGuideDialog();\n            break;\n          }\n        }\n      },\n      undefined,\n      []\n    );\n\n    // Send initial settings\n    this._sendCurrentSettings();\n  }\n\n  private _updateSetting(key: string, value: any) {\n    const config = vscode.workspace.getConfiguration('prolog');\n    config.update(key, value, vscode.ConfigurationTarget.Global).then(\n      () => {\n        vscode.window.showInformationMessage(`Setting '${key}' updated successfully`);\n        this._sendCurrentSettings(); // Refresh the UI\n      },\n      error => {\n        vscode.window.showErrorMessage(`Failed to update setting '${key}': ${error}`);\n      }\n    );\n  }\n\n  private _resetSettings() {\n    vscode.window\n      .showWarningMessage(\n        'Are you sure you want to reset all Prolog settings to their default values?',\n        'Yes',\n        'No'\n      )\n      .then(selection => {\n        if (selection === 'Yes') {\n          const config = vscode.workspace.getConfiguration('prolog');\n          const settingsToReset = [\n            'executablePath',\n            'dialect',\n            'linter.run',\n            'format.addSpace',\n            'linter.delay',\n            'linter.enableMsgInOutput',\n            'terminal.runtimeArgs',\n            'telemetry.enabled',\n            'apiServer.enabled',\n            'apiServer.port',\n            'apiServer.host',\n            'apiServer.corsOrigins',\n            'apiServer.maxConnections',\n            'apiServer.requestTimeout',\n            'apiServer.rateLimiting.enabled',\n            'apiServer.rateLimiting.requestsPerMinute',\n            'apiServer.rateLimiting.burstLimit',\n            'apiServer.auth.method',\n            'apiServer.auth.apiKeys',\n            'apiServer.auth.jwtSecret',\n            'apiServer.auth.jwtExpiration',\n            'webSocketServer.enabled',\n            'webSocketServer.port',\n            'webSocketServer.maxConnections',\n            'webSocketServer.heartbeatInterval',\n          ];\n\n          Promise.all(\n            settingsToReset.map(key =>\n              config.update(key, undefined, vscode.ConfigurationTarget.Global)\n            )\n          ).then(() => {\n            vscode.window.showInformationMessage('All Prolog settings have been reset to defaults');\n            this._sendCurrentSettings();\n          });\n        }\n      });\n  }\n\n  private async _exportSettings() {\n    const config = vscode.workspace.getConfiguration('prolog');\n    const settings = {\n      executablePath: config.get('executablePath'),\n      dialect: config.get('dialect'),\n      linter: {\n        run: config.get('linter.run'),\n        delay: config.get('linter.delay'),\n        enableMsgInOutput: config.get('linter.enableMsgInOutput'),\n      },\n      format: {\n        addSpace: config.get('format.addSpace'),\n      },\n      terminal: {\n        runtimeArgs: config.get('terminal.runtimeArgs'),\n      },\n      telemetry: {\n        enabled: config.get('telemetry.enabled'),\n      },\n      apiServer: {\n        enabled: config.get('apiServer.enabled'),\n        port: config.get('apiServer.port'),\n        host: config.get('apiServer.host'),\n        corsOrigins: config.get('apiServer.corsOrigins'),\n        maxConnections: config.get('apiServer.maxConnections'),\n        requestTimeout: config.get('apiServer.requestTimeout'),\n        rateLimiting: {\n          enabled: config.get('apiServer.rateLimiting.enabled'),\n          requestsPerMinute: config.get('apiServer.rateLimiting.requestsPerMinute'),\n          burstLimit: config.get('apiServer.rateLimiting.burstLimit'),\n        },\n        auth: {\n          method: config.get('apiServer.auth.method'),\n          jwtExpiration: config.get('apiServer.auth.jwtExpiration'),\n        },\n      },\n      webSocketServer: {\n        enabled: config.get('webSocketServer.enabled'),\n        port: config.get('webSocketServer.port'),\n        maxConnections: config.get('webSocketServer.maxConnections'),\n        heartbeatInterval: config.get('webSocketServer.heartbeatInterval'),\n      },\n    };\n\n    const uri = await vscode.window.showSaveDialog({\n      defaultUri: vscode.Uri.file('prolog-settings.json'),\n      filters: {\n        'JSON files': ['json'],\n      },\n    });\n\n    if (uri) {\n      const normalizedPath = PlatformUtils.normalizePath(uri.fsPath);\n      fs.writeFileSync(normalizedPath, JSON.stringify(settings, null, 2));\n      vscode.window.showInformationMessage(`Settings exported to ${normalizedPath}`);\n    }\n  }\n\n  private async _importSettings() {\n    const uri = await vscode.window.showOpenDialog({\n      canSelectFiles: true,\n      canSelectFolders: false,\n      canSelectMany: false,\n      filters: {\n        'JSON files': ['json'],\n      },\n    });\n\n    if (uri?.[0]) {\n      try {\n        const normalizedPath = PlatformUtils.normalizePath(uri[0].fsPath);\n        const settingsJson = fs.readFileSync(normalizedPath, 'utf8');\n        const settings = JSON.parse(settingsJson);\n\n        const config = vscode.workspace.getConfiguration('prolog');\n\n        // Apply imported settings\n        const promises = [];\n        if (settings.executablePath)\n          promises.push(\n            config.update(\n              'executablePath',\n              settings.executablePath,\n              vscode.ConfigurationTarget.Global\n            )\n          );\n        if (settings.dialect)\n          promises.push(\n            config.update('dialect', settings.dialect, vscode.ConfigurationTarget.Global)\n          );\n        if (settings.linter?.run)\n          promises.push(\n            config.update('linter.run', settings.linter.run, vscode.ConfigurationTarget.Global)\n          );\n        if (settings.linter?.delay)\n          promises.push(\n            config.update('linter.delay', settings.linter.delay, vscode.ConfigurationTarget.Global)\n          );\n        if (settings.linter?.enableMsgInOutput !== undefined)\n          promises.push(\n            config.update(\n              'linter.enableMsgInOutput',\n              settings.linter.enableMsgInOutput,\n              vscode.ConfigurationTarget.Global\n            )\n          );\n        if (settings.format?.addSpace !== undefined)\n          promises.push(\n            config.update(\n              'format.addSpace',\n              settings.format.addSpace,\n              vscode.ConfigurationTarget.Global\n            )\n          );\n        if (settings.terminal?.runtimeArgs)\n          promises.push(\n            config.update(\n              'terminal.runtimeArgs',\n              settings.terminal.runtimeArgs,\n              vscode.ConfigurationTarget.Global\n            )\n          );\n        if (settings.telemetry?.enabled !== undefined)\n          promises.push(\n            config.update(\n              'telemetry.enabled',\n              settings.telemetry.enabled,\n              vscode.ConfigurationTarget.Global\n            )\n          );\n\n        // API Server settings\n        if (settings.apiServer) {\n          if (settings.apiServer.enabled !== undefined)\n            promises.push(\n              config.update(\n                'apiServer.enabled',\n                settings.apiServer.enabled,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.apiServer.port)\n            promises.push(\n              config.update(\n                'apiServer.port',\n                settings.apiServer.port,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.apiServer.host)\n            promises.push(\n              config.update(\n                'apiServer.host',\n                settings.apiServer.host,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.apiServer.corsOrigins)\n            promises.push(\n              config.update(\n                'apiServer.corsOrigins',\n                settings.apiServer.corsOrigins,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.apiServer.maxConnections)\n            promises.push(\n              config.update(\n                'apiServer.maxConnections',\n                settings.apiServer.maxConnections,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.apiServer.requestTimeout)\n            promises.push(\n              config.update(\n                'apiServer.requestTimeout',\n                settings.apiServer.requestTimeout,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n\n          if (settings.apiServer.rateLimiting) {\n            if (settings.apiServer.rateLimiting.enabled !== undefined)\n              promises.push(\n                config.update(\n                  'apiServer.rateLimiting.enabled',\n                  settings.apiServer.rateLimiting.enabled,\n                  vscode.ConfigurationTarget.Global\n                )\n              );\n            if (settings.apiServer.rateLimiting.requestsPerMinute)\n              promises.push(\n                config.update(\n                  'apiServer.rateLimiting.requestsPerMinute',\n                  settings.apiServer.rateLimiting.requestsPerMinute,\n                  vscode.ConfigurationTarget.Global\n                )\n              );\n            if (settings.apiServer.rateLimiting.burstLimit)\n              promises.push(\n                config.update(\n                  'apiServer.rateLimiting.burstLimit',\n                  settings.apiServer.rateLimiting.burstLimit,\n                  vscode.ConfigurationTarget.Global\n                )\n              );\n          }\n\n          if (settings.apiServer.auth) {\n            if (settings.apiServer.auth.method)\n              promises.push(\n                config.update(\n                  'apiServer.auth.method',\n                  settings.apiServer.auth.method,\n                  vscode.ConfigurationTarget.Global\n                )\n              );\n            if (settings.apiServer.auth.jwtExpiration)\n              promises.push(\n                config.update(\n                  'apiServer.auth.jwtExpiration',\n                  settings.apiServer.auth.jwtExpiration,\n                  vscode.ConfigurationTarget.Global\n                )\n              );\n          }\n        }\n\n        // WebSocket Server settings\n        if (settings.webSocketServer) {\n          if (settings.webSocketServer.enabled !== undefined)\n            promises.push(\n              config.update(\n                'webSocketServer.enabled',\n                settings.webSocketServer.enabled,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.webSocketServer.port)\n            promises.push(\n              config.update(\n                'webSocketServer.port',\n                settings.webSocketServer.port,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.webSocketServer.maxConnections)\n            promises.push(\n              config.update(\n                'webSocketServer.maxConnections',\n                settings.webSocketServer.maxConnections,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n          if (settings.webSocketServer.heartbeatInterval)\n            promises.push(\n              config.update(\n                'webSocketServer.heartbeatInterval',\n                settings.webSocketServer.heartbeatInterval,\n                vscode.ConfigurationTarget.Global\n              )\n            );\n        }\n\n        await Promise.all(promises);\n        vscode.window.showInformationMessage('Settings imported successfully');\n        this._sendCurrentSettings();\n      } catch (error) {\n        vscode.window.showErrorMessage(`Failed to import settings: ${error}`);\n      }\n    }\n  }\n\n  private _validateSetting(key: string, value: any): boolean {\n    let isValid = true;\n    let errorMessage = '';\n\n    switch (key) {\n      case 'apiServer.port':\n      case 'webSocketServer.port': {\n        if (typeof value !== 'number' || value < 1024 || value > 65535) {\n          isValid = false;\n          errorMessage = 'Port must be a number between 1024 and 65535';\n        }\n        break;\n      }\n      case 'linter.delay': {\n        if (typeof value !== 'number' || value < 0) {\n          isValid = false;\n          errorMessage = 'Delay must be a positive number';\n        }\n        break;\n      }\n      case 'apiServer.maxConnections':\n      case 'webSocketServer.maxConnections': {\n        if (typeof value !== 'number' || value < 1 || value > 1000) {\n          isValid = false;\n          errorMessage = 'Max connections must be between 1 and 1000';\n        }\n        break;\n      }\n      case 'apiServer.requestTimeout': {\n        if (typeof value !== 'number' || value < 1000 || value > 300000) {\n          isValid = false;\n          errorMessage = 'Request timeout must be between 1000 and 300000 milliseconds';\n        }\n        break;\n      }\n      case 'apiServer.rateLimiting.requestsPerMinute': {\n        if (typeof value !== 'number' || value < 1 || value > 1000) {\n          isValid = false;\n          errorMessage = 'Requests per minute must be between 1 and 1000';\n        }\n        break;\n      }\n      case 'apiServer.rateLimiting.burstLimit': {\n        if (typeof value !== 'number' || value < 1 || value > 100) {\n          isValid = false;\n          errorMessage = 'Burst limit must be between 1 and 100';\n        }\n        break;\n      }\n      case 'webSocketServer.heartbeatInterval': {\n        if (typeof value !== 'number' || value < 10 || value > 300) {\n          isValid = false;\n          errorMessage = 'Heartbeat interval must be between 10 and 300 seconds';\n        }\n        break;\n      }\n    }\n\n    if (this._view) {\n      this._view.webview.postMessage({\n        type: 'validationResult',\n        key: key,\n        isValid: isValid,\n        errorMessage: errorMessage,\n      });\n    }\n\n    return isValid;\n  }\n\n  private async _sendCurrentSettings() {\n    if (!this._view) {\n      return;\n    }\n\n    const config = vscode.workspace.getConfiguration('prolog');\n\n    // Check installation status\n    const installationStatus = await this.installationChecker.checkSwiplInstallation();\n\n    const settings = {\n      executablePath: config.get('executablePath', '/usr/bin/swipl'),\n      dialect: config.get('dialect', 'swi'),\n      linter: {\n        run: config.get('linter.run', 'onType'),\n        delay: config.get('linter.delay', 500),\n        enableMsgInOutput: config.get('linter.enableMsgInOutput', false),\n      },\n      format: {\n        addSpace: config.get('format.addSpace', true),\n      },\n      terminal: {\n        runtimeArgs: config.get('terminal.runtimeArgs', []),\n      },\n      telemetry: {\n        enabled: config.get('telemetry.enabled', false),\n      },\n      apiServer: {\n        enabled: config.get('apiServer.enabled', false),\n        port: config.get('apiServer.port', 8080),\n        host: config.get('apiServer.host', 'localhost'),\n        corsOrigins: config.get('apiServer.corsOrigins', ['http://localhost:*']),\n        maxConnections: config.get('apiServer.maxConnections', 100),\n        requestTimeout: config.get('apiServer.requestTimeout', 60000),\n        rateLimiting: {\n          enabled: config.get('apiServer.rateLimiting.enabled', true),\n          requestsPerMinute: config.get('apiServer.rateLimiting.requestsPerMinute', 60),\n          burstLimit: config.get('apiServer.rateLimiting.burstLimit', 10),\n        },\n        auth: {\n          method: config.get('apiServer.auth.method', 'local_only'),\n          apiKeys: config.get('apiServer.auth.apiKeys', {}),\n          jwtSecret: config.get('apiServer.auth.jwtSecret', ''),\n          jwtExpiration: config.get('apiServer.auth.jwtExpiration', '1h'),\n        },\n      },\n      webSocketServer: {\n        enabled: config.get('webSocketServer.enabled', true),\n        port: config.get('webSocketServer.port', 8081),\n        maxConnections: config.get('webSocketServer.maxConnections', 50),\n        heartbeatInterval: config.get('webSocketServer.heartbeatInterval', 30),\n      },\n      installation: installationStatus,\n    };\n\n    this._view.webview.postMessage({\n      type: 'settingsData',\n      settings: settings,\n    });\n  }\n\n  private async _checkInstallation() {\n    if (!this._view) {\n      return;\n    }\n\n    try {\n      const installationStatus = await this.installationChecker.checkSwiplInstallation();\n      this._view.webview.postMessage({\n        type: 'installationStatus',\n        status: installationStatus,\n      });\n    } catch (error) {\n      this._view.webview.postMessage({\n        type: 'installationStatus',\n        status: {\n          isInstalled: false,\n          issues: [`Error checking installation: ${error}`],\n        },\n      });\n    }\n  }\n\n  private async _autoDetectPath() {\n    if (!this._view) {\n      return;\n    }\n\n    try {\n      const foundPath = await this.installationChecker.findSwiplExecutable();\n      if (foundPath) {\n        const version = await this.installationChecker.getSwiplVersion(foundPath);\n\n        // Update configuration\n        const config = vscode.workspace.getConfiguration('prolog');\n        await config.update('executablePath', foundPath, vscode.ConfigurationTarget.Global);\n\n        this._view.webview.postMessage({\n          type: 'autoDetectResult',\n          success: true,\n          path: foundPath,\n          version: version,\n        });\n\n        // Refresh settings\n        await this._sendCurrentSettings();\n      } else {\n        this._view.webview.postMessage({\n          type: 'autoDetectResult',\n          success: false,\n          message: 'SWI-Prolog not found in common locations',\n        });\n      }\n    } catch (error) {\n      this._view.webview.postMessage({\n        type: 'autoDetectResult',\n        success: false,\n        message: `Auto-detection failed: ${error}`,\n      });\n    }\n  }\n\n  private async _testInstallation() {\n    if (!this._view) {\n      return;\n    }\n\n    try {\n      const config = vscode.workspace.getConfiguration('prolog');\n      const executablePath = config.get<string>('executablePath', 'swipl');\n\n      const isValid = await this.installationChecker.validateSwiplPath(executablePath);\n      if (isValid) {\n        const version = await this.installationChecker.getSwiplVersion(executablePath);\n        this._view.webview.postMessage({\n          type: 'testResult',\n          success: true,\n          message: `SWI-Prolog is working correctly (version ${version})`,\n        });\n      } else {\n        this._view.webview.postMessage({\n          type: 'testResult',\n          success: false,\n          message: 'SWI-Prolog executable is not valid or not accessible',\n        });\n      }\n    } catch (error) {\n      this._view.webview.postMessage({\n        type: 'testResult',\n        success: false,\n        message: `Test failed: ${error}`,\n      });\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview): string {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'settings.js')\n    );\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'settings.css')\n    );\n\n    return `<!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <link href=\"${styleUri}\" rel=\"stylesheet\">\n            <title>Prolog Settings</title>\n        </head>\n        <body>\n            <div class=\"settings-container\">\n                <div class=\"settings-header\">\n                    <h1>🔧 Prolog Extension Settings</h1>\n                    <div class=\"settings-actions\">\n                        <button id=\"searchBtn\" class=\"action-btn\" title=\"Search Settings\">🔍</button>\n                        <button id=\"exportBtn\" class=\"action-btn\" title=\"Export Settings\">📤</button>\n                        <button id=\"importBtn\" class=\"action-btn\" title=\"Import Settings\">📥</button>\n                        <button id=\"resetBtn\" class=\"action-btn danger\" title=\"Reset All Settings\">🔄</button>\n                    </div>\n                </div>\n\n                <div class=\"search-container\" id=\"searchContainer\" style=\"display: none;\">\n                    <input type=\"text\" id=\"searchInput\" placeholder=\"Search settings...\" />\n                    <button id=\"clearSearch\">✕</button>\n                </div>\n\n                <div class=\"settings-content\">\n                    <!-- Installation Status -->\n                    <div class=\"settings-section\" data-category=\"installation\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">🔧</span>\n                            SWI-Prolog Installation\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"installation-status\" id=\"installationStatus\">\n                                <div class=\"status-indicator\" id=\"statusIndicator\">\n                                    <span class=\"status-icon\">🔄</span>\n                                    <span class=\"status-text\">Checking installation...</span>\n                                </div>\n                                <div class=\"installation-details\" id=\"installationDetails\" style=\"display: none;\">\n                                    <div class=\"detail-item\">\n                                        <strong>Path:</strong> <span id=\"installationPath\">-</span>\n                                    </div>\n                                    <div class=\"detail-item\">\n                                        <strong>Version:</strong> <span id=\"installationVersion\">-</span>\n                                    </div>\n                                    <div class=\"detail-item\" id=\"installationIssues\" style=\"display: none;\">\n                                        <strong>Issues:</strong>\n                                        <ul id=\"issuesList\"></ul>\n                                    </div>\n                                </div>\n                                <div class=\"installation-actions\">\n                                    <button class=\"action-btn\" id=\"autoDetectBtn\" title=\"Auto-detect SWI-Prolog\">🔍 Auto-Detect</button>\n                                    <button class=\"action-btn\" id=\"testInstallationBtn\" title=\"Test Installation\">🧪 Test</button>\n                                    <button class=\"action-btn\" id=\"setupWizardBtn\" title=\"Setup Wizard\">🧙‍♂️ Setup Wizard</button>\n                                    <button class=\"action-btn\" id=\"installationGuideBtn\" title=\"Installation Guide\">📖 Install Guide</button>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <!-- Core Settings -->\n                    <div class=\"settings-section\" data-category=\"core\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">⚙️</span>\n                            Core Settings\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"setting-group\">\n                                <label for=\"executablePath\">Prolog Executable Path</label>\n                                <input type=\"text\" id=\"executablePath\" data-key=\"executablePath\" placeholder=\"/usr/bin/swipl\" />\n                                <div class=\"setting-description\">Path to the Prolog executable (SWI-Prolog)</div>\n                                <div class=\"validation-message\" id=\"executablePath-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group\">\n                                <label for=\"dialect\">Prolog Dialect</label>\n                                <select id=\"dialect\" data-key=\"dialect\">\n                                    <option value=\"swi\">SWI-Prolog</option>\n                                    <option value=\"ecl\">ECLiPSe</option>\n                                </select>\n                                <div class=\"setting-description\">Choose your Prolog dialect</div>\n                            </div>\n\n                            <div class=\"setting-group\">\n                                <label for=\"terminalRuntimeArgs\">Terminal Runtime Arguments</label>\n                                <textarea id=\"terminalRuntimeArgs\" data-key=\"terminal.runtimeArgs\" placeholder='[\"--quiet\", \"--nosignals\"]' rows=\"3\"></textarea>\n                                <div class=\"setting-description\">JSON array of arguments passed to Prolog executable in terminal</div>\n                                <div class=\"validation-message\" id=\"terminalRuntimeArgs-validation\"></div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <!-- Linter Settings -->\n                    <div class=\"settings-section\" data-category=\"linter\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">🔍</span>\n                            Linter Settings\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"setting-group\">\n                                <label for=\"linterRun\">Linter Trigger</label>\n                                <select id=\"linterRun\" data-key=\"linter.run\">\n                                    <option value=\"onSave\">On Save</option>\n                                    <option value=\"onType\">On Type</option>\n                                    <option value=\"never\">Never</option>\n                                </select>\n                                <div class=\"setting-description\">When to trigger the linter</div>\n                            </div>\n\n                            <div class=\"setting-group\">\n                                <label for=\"linterDelay\">Linter Delay (ms)</label>\n                                <input type=\"number\" id=\"linterDelay\" data-key=\"linter.delay\" min=\"0\" max=\"5000\" step=\"100\" />\n                                <div class=\"setting-description\">Delay in milliseconds when using onType trigger</div>\n                                <div class=\"validation-message\" id=\"linterDelay-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group\">\n                                <label class=\"checkbox-label\">\n                                    <input type=\"checkbox\" id=\"linterEnableMsgInOutput\" data-key=\"linter.enableMsgInOutput\" />\n                                    <span class=\"checkmark\"></span>\n                                    Enable Messages in Output Channel\n                                </label>\n                                <div class=\"setting-description\">Show linter errors and warnings in OUTPUT channel</div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <!-- Formatter Settings -->\n                    <div class=\"settings-section\" data-category=\"formatter\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">📝</span>\n                            Formatter Settings\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"setting-group\">\n                                <label class=\"checkbox-label\">\n                                    <input type=\"checkbox\" id=\"formatAddSpace\" data-key=\"format.addSpace\" />\n                                    <span class=\"checkmark\"></span>\n                                    Add Space After Commas\n                                </label>\n                                <div class=\"setting-description\">Automatically add spaces after commas during formatting</div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <!-- API Server Settings -->\n                    <div class=\"settings-section\" data-category=\"api\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">🌐</span>\n                            API Server Settings\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"setting-group\">\n                                <label class=\"checkbox-label\">\n                                    <input type=\"checkbox\" id=\"apiServerEnabled\" data-key=\"apiServer.enabled\" />\n                                    <span class=\"checkmark\"></span>\n                                    Enable API Server\n                                </label>\n                                <div class=\"setting-description\">Enable HTTP API server for external AI agent access</div>\n                            </div>\n\n                            <div class=\"setting-group api-dependent\">\n                                <label for=\"apiServerPort\">API Server Port</label>\n                                <input type=\"number\" id=\"apiServerPort\" data-key=\"apiServer.port\" min=\"1024\" max=\"65535\" />\n                                <div class=\"setting-description\">Port number for the HTTP API server</div>\n                                <div class=\"validation-message\" id=\"apiServerPort-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group api-dependent\">\n                                <label for=\"apiServerHost\">API Server Host</label>\n                                <input type=\"text\" id=\"apiServerHost\" data-key=\"apiServer.host\" placeholder=\"localhost\" />\n                                <div class=\"setting-description\">Host address for the HTTP API server</div>\n                            </div>\n\n                            <div class=\"setting-group api-dependent\">\n                                <label for=\"apiServerCorsOrigins\">CORS Origins</label>\n                                <textarea id=\"apiServerCorsOrigins\" data-key=\"apiServer.corsOrigins\" placeholder='[\"http://localhost:*\"]' rows=\"3\"></textarea>\n                                <div class=\"setting-description\">JSON array of allowed CORS origins for API requests</div>\n                                <div class=\"validation-message\" id=\"apiServerCorsOrigins-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group api-dependent\">\n                                <label for=\"apiServerMaxConnections\">Max Connections</label>\n                                <input type=\"number\" id=\"apiServerMaxConnections\" data-key=\"apiServer.maxConnections\" min=\"1\" max=\"1000\" />\n                                <div class=\"setting-description\">Maximum number of concurrent connections</div>\n                                <div class=\"validation-message\" id=\"apiServerMaxConnections-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group api-dependent\">\n                                <label for=\"apiServerRequestTimeout\">Request Timeout (ms)</label>\n                                <input type=\"number\" id=\"apiServerRequestTimeout\" data-key=\"apiServer.requestTimeout\" min=\"1000\" max=\"300000\" step=\"1000\" />\n                                <div class=\"setting-description\">Request timeout in milliseconds</div>\n                                <div class=\"validation-message\" id=\"apiServerRequestTimeout-validation\"></div>\n                            </div>\n\n                            <!-- Rate Limiting -->\n                            <div class=\"setting-subgroup api-dependent\">\n                                <h3>Rate Limiting</h3>\n                                <div class=\"setting-group\">\n                                    <label class=\"checkbox-label\">\n                                        <input type=\"checkbox\" id=\"apiServerRateLimitingEnabled\" data-key=\"apiServer.rateLimiting.enabled\" />\n                                        <span class=\"checkmark\"></span>\n                                        Enable Rate Limiting\n                                    </label>\n                                    <div class=\"setting-description\">Enable rate limiting for API requests</div>\n                                </div>\n\n                                <div class=\"setting-group rate-limiting-dependent\">\n                                    <label for=\"apiServerRateLimitingRequestsPerMinute\">Requests Per Minute</label>\n                                    <input type=\"number\" id=\"apiServerRateLimitingRequestsPerMinute\" data-key=\"apiServer.rateLimiting.requestsPerMinute\" min=\"1\" max=\"1000\" />\n                                    <div class=\"setting-description\">Maximum requests per minute per client</div>\n                                    <div class=\"validation-message\" id=\"apiServerRateLimitingRequestsPerMinute-validation\"></div>\n                                </div>\n\n                                <div class=\"setting-group rate-limiting-dependent\">\n                                    <label for=\"apiServerRateLimitingBurstLimit\">Burst Limit</label>\n                                    <input type=\"number\" id=\"apiServerRateLimitingBurstLimit\" data-key=\"apiServer.rateLimiting.burstLimit\" min=\"1\" max=\"100\" />\n                                    <div class=\"setting-description\">Maximum burst requests allowed</div>\n                                    <div class=\"validation-message\" id=\"apiServerRateLimitingBurstLimit-validation\"></div>\n                                </div>\n                            </div>\n\n                            <!-- Authentication -->\n                            <div class=\"setting-subgroup api-dependent\">\n                                <h3>Authentication</h3>\n                                <div class=\"setting-group\">\n                                    <label for=\"apiServerAuthMethod\">Authentication Method</label>\n                                    <select id=\"apiServerAuthMethod\" data-key=\"apiServer.auth.method\">\n                                        <option value=\"local_only\">Local Only</option>\n                                        <option value=\"api_key\">API Key</option>\n                                        <option value=\"jwt_token\">JWT Token</option>\n                                        <option value=\"oauth2\">OAuth2</option>\n                                    </select>\n                                    <div class=\"setting-description\">Authentication method for API access</div>\n                                </div>\n\n                                <div class=\"setting-group jwt-dependent\">\n                                    <label for=\"apiServerAuthJwtExpiration\">JWT Token Expiration</label>\n                                    <input type=\"text\" id=\"apiServerAuthJwtExpiration\" data-key=\"apiServer.auth.jwtExpiration\" placeholder=\"1h\" />\n                                    <div class=\"setting-description\">JWT token expiration time (e.g., '1h', '30m', '7d')</div>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <!-- WebSocket Server Settings -->\n                    <div class=\"settings-section\" data-category=\"websocket\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">🔌</span>\n                            WebSocket Server Settings\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"setting-group\">\n                                <label class=\"checkbox-label\">\n                                    <input type=\"checkbox\" id=\"webSocketServerEnabled\" data-key=\"webSocketServer.enabled\" />\n                                    <span class=\"checkmark\"></span>\n                                    Enable WebSocket Server\n                                </label>\n                                <div class=\"setting-description\">Enable WebSocket server for real-time notifications</div>\n                            </div>\n\n                            <div class=\"setting-group websocket-dependent\">\n                                <label for=\"webSocketServerPort\">WebSocket Server Port</label>\n                                <input type=\"number\" id=\"webSocketServerPort\" data-key=\"webSocketServer.port\" min=\"1024\" max=\"65535\" />\n                                <div class=\"setting-description\">Port number for the WebSocket server</div>\n                                <div class=\"validation-message\" id=\"webSocketServerPort-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group websocket-dependent\">\n                                <label for=\"webSocketServerMaxConnections\">Max WebSocket Connections</label>\n                                <input type=\"number\" id=\"webSocketServerMaxConnections\" data-key=\"webSocketServer.maxConnections\" min=\"1\" max=\"500\" />\n                                <div class=\"setting-description\">Maximum number of concurrent WebSocket connections</div>\n                                <div class=\"validation-message\" id=\"webSocketServerMaxConnections-validation\"></div>\n                            </div>\n\n                            <div class=\"setting-group websocket-dependent\">\n                                <label for=\"webSocketServerHeartbeatInterval\">Heartbeat Interval (seconds)</label>\n                                <input type=\"number\" id=\"webSocketServerHeartbeatInterval\" data-key=\"webSocketServer.heartbeatInterval\" min=\"10\" max=\"300\" />\n                                <div class=\"setting-description\">WebSocket heartbeat interval in seconds</div>\n                                <div class=\"validation-message\" id=\"webSocketServerHeartbeatInterval-validation\"></div>\n                            </div>\n                        </div>\n                    </div>\n\n                    <!-- Privacy & Telemetry Settings -->\n                    <div class=\"settings-section\" data-category=\"privacy\">\n                        <h2 class=\"section-title\">\n                            <span class=\"section-icon\">🔒</span>\n                            Privacy & Telemetry Settings\n                            <button class=\"section-toggle\">−</button>\n                        </h2>\n                        <div class=\"section-content\">\n                            <div class=\"setting-group\">\n                                <label class=\"checkbox-label\">\n                                    <input type=\"checkbox\" id=\"telemetryEnabled\" data-key=\"telemetry.enabled\" />\n                                    <span class=\"checkmark\"></span>\n                                    Enable Privacy-Respecting Telemetry\n                                </label>\n                                <div class=\"setting-description\">Enable local usage analytics (data stays on your machine)</div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n\n                <div class=\"settings-footer\">\n                    <div class=\"footer-info\">\n                        <p>💡 <strong>Tip:</strong> Changes are applied immediately. Restart VS Code if you experience issues.</p>\n                        <p>📚 For more information, visit the <a href=\"https://github.com/mediaprophet/VSCode-Prolog-Toolkit\" target=\"_blank\">documentation</a>.</p>\n                    </div>\n                </div>\n            </div>\n\n            <script src=\"${scriptUri}\"></script>\n        </body>\n        </html>`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\streamingHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\uiHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'items' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rest' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface UIHandler {\n  showErrorMessage(message: string, ...items: string[]): Promise<string | undefined>;\n  executeCommand(command: string, ...rest: any[]): Promise<any>;\n}\n\nexport const defaultUIHandler: UIHandler = {\n  showErrorMessage: async (message: string, ...items: string[]): Promise<string | undefined> => {\n    console.error(message);\n    return undefined;\n  },\n  executeCommand: async (command: string, ...rest: any[]): Promise<any> => {\n    console.log(`Command execution requested: ${command}`);\n    return undefined;\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\features\\updateSnippets.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Variable' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Uri' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'verify' is defined but never used.","line":18,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'document' is defined but never used. Allowed unused args must match /^_/u.","line":221,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'position' is defined but never used. Allowed unused args must match /^_/u.","line":222,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":222,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'token' is defined but never used. Allowed unused args must match /^_/u.","line":223,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":224,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":224,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Variable } from '@vscode/debugadapter';\nimport {\n  TextDocument,\n  window,\n  Disposable,\n  Position,\n  CancellationToken,\n  CompletionContext,\n  CompletionItem,\n  SnippetString,\n  MarkdownString,\n  Uri,\n  workspace,\n  CompletionItemKind,\n} from 'vscode';\nimport * as fs from 'fs';\nimport { Utils } from '../utils/utils';\nimport { verify } from 'crypto';\n\n// Class responsible for updating snippets based on prolog files\nexport class SnippetUpdater {\n  // Update snippets based on new predicates create by the user in the document\n  public updateSnippet() {\n    // Get the currently active text editor\n    const editor = window.activeTextEditor;\n    if (!editor) {\n      return;\n    }\n\n    const doc = editor.document;\n    // Update only if the document is a prolog file\n    if (doc.languageId === 'prolog') {\n      // Retrieve predicates from the document and check against existing snippets\n      const predicats = this._getPredicat(doc);\n      const already: string[] = [];\n      const description: boolean[] = [];\n      // Extract existing snippets' names for comparison\n      Object.keys(Utils.snippets).forEach(elem => {\n        if (elem.includes(':')) {\n          if (elem.includes(':-')) {\n            already.push(elem.replace(':- ', ''));\n          } else {\n            already.push(elem.split(':')[1]);\n          }\n        } else {\n          already.push(elem);\n        }\n        if (Utils.snippets[elem].description.includes('\\ncustom predicate\\n')) {\n          description.push(false);\n        } else {\n          description.push(true);\n        }\n      });\n      // Update snippets based on new predicates in the document\n      predicats.forEach(elem => {\n        const num = elem[1].split(',').length;\n        if (!already.includes(elem[0] + '/' + num.toString())) {\n          if (elem[2] == null) {\n            Utils.snippets[elem[0] + '/' + num.toString()] = {\n              prefix: elem[0],\n              body: [''],\n              description:\n                elem[0].toString() + '(' + elem[1].toString() + ')\\ncustom predicate\\n\\n',\n            };\n          } else {\n            Utils.snippets[elem[0] + '/' + num.toString()] = {\n              prefix: elem[0],\n              body: [''],\n              description: elem[0].toString() + '(' + elem[1].toString() + ')\\n' + elem[2] + '\\n',\n            };\n          }\n          Utils.newsnippets.push(elem);\n        } else if (elem[2] != null) {\n          delete Utils.snippets[\n            Object.keys(Utils.snippets)[already.indexOf(elem[0] + '/' + num.toString())]\n          ];\n          Utils.snippets[elem[0] + '/' + num.toString()] = {\n            prefix: elem[0],\n            body: [''],\n            description: elem[0].toString() + '(' + elem[1].toString() + ')\\n' + elem[2] + '\\n',\n          };\n          for (let i = 0; i < Utils.newsnippets.length; i++) {\n            if (Utils.newsnippets[i][0] == elem[0] && Utils.newsnippets[i][1] == elem[1]) {\n              Utils.newsnippets.splice(i, 1);\n              Utils.newsnippets.push(elem);\n              break;\n            }\n          }\n        }\n      });\n      // Generate predicate modules based on the updated context\n      Utils.genPredicateModules(Utils.CONTEXT);\n    }\n  }\n\n  // Extracts predicates from the given TextDocument\n  public _getPredicat(doc: TextDocument) {\n    const docContent = doc.getText(); // Get the content of the document\n    const regexp = /(^\\s*)([a-z][a-zA-Z0-9_]*)\\(([a-zA-Z0-9_\\-, ]*)\\)(?=.*(:-|=>|-->).*)/gm; // Regular expression for matching Prolog predicates\n    const regexpModule = /^\\s*:-\\s*use_module\\(([a-z][a-zA-Z0-9_/]*)\\s*(,|\\)\\s*\\.)/gm; // Regular expression for matching Prolog use_module directives\n    const regexpComment = /^\\s*(%(?!!)|%!|\\*(?!\\/)|\\/\\*\\*)(\\s*)(.*)/gm; // Regular expression for matching Prolog comments\n    const arrayModule = [...docContent.matchAll(regexpModule)]; // Extract all use_module directives from the document\n    const prolog = doc.fileName.split('.')[1]; // Get the Prolog extension from the document's file name\n    let predicats = [];\n\n    // Loop through each use_module directive\n    for (let i = 0; i < arrayModule.length; i++) {\n      // Read the content of the referenced module\n      let text = '';\n      try {\n        text = fs.readFileSync(\n          workspace.workspaceFolders[0].uri.fsPath + '/' + arrayModule[i][1] + '.' + prolog,\n          'utf8'\n        );\n      } catch (error) {\n        console.error('Error reading file:', error);\n      }\n\n      // Extract predicates from the referenced module's content\n      const array2 = [...text.matchAll(regexp)];\n      array2.forEach(elem => {\n        let nbline = Utils.findLineColForByte(text, elem.index + elem[1].length).line - 1;\n        const lines = text.split(/\\n|\\r/);\n        let verif = true;\n        let comment = '';\n        while (verif && nbline > -1) {\n          const res = lines[nbline].matchAll(regexpComment).next();\n          if (res.value) {\n            if (res.value[1] != '*/' || res.value[1] != '/**') {\n              if (comment == '') {\n                comment = res.value[3];\n              } else if (res.value[3] != '') {\n                comment = res.value[3] + '\\n' + comment;\n              }\n            }\n            if (res.value[1] == '%!' || res.value[1] == '/**') {\n              verif = false;\n            }\n            nbline = nbline - 1;\n          } else {\n            comment = null;\n            verif = false;\n          }\n        }\n        predicats.push([elem[2], elem[3], comment]);\n      });\n    }\n    // Extract predicates from the current document\n    const array = [...docContent.matchAll(regexp)];\n    // Search for definition comments\n    array.forEach(elem => {\n      let nbline = Utils.findLineColForByte(docContent, elem.index + elem[1].length).line - 1;\n      const lines = docContent.split('\\n');\n      let verif = true;\n      let comment = '';\n      while (verif && nbline > -1) {\n        const res = lines[nbline].matchAll(regexpComment).next();\n        if (res.value) {\n          if (res.value[1] != '*/' || res.value[1] != '/**') {\n            if (comment == '') {\n              comment = res.value[3];\n            } else if (res.value[3] != '') {\n              comment = res.value[3] + '\\n' + comment;\n            }\n          }\n          if (res.value[1] == '%!' || res.value[1] == '/**') {\n            verif = false;\n          }\n          nbline = nbline - 1;\n        } else {\n          comment = null;\n          verif = false;\n        }\n      }\n      predicats.push([elem[2], elem[3], comment]);\n    });\n    // Filter out a specific predicate named \"test\"\n    predicats = predicats.filter(function (predicat) {\n      return predicat[0] != 'test';\n    });\n    return predicats;\n  }\n  dispose() {\n    // No resources to dispose\n  }\n}\n\n// Class responsible for managing the SnippetUpdater and subscribing to relevant events\nexport class SnippetUpdaterController {\n  private snippetUpdater: SnippetUpdater;\n  private _disposable: Disposable;\n\n  constructor(snippetUpdater: SnippetUpdater) {\n    this.snippetUpdater = snippetUpdater;\n    this.snippetUpdater.updateSnippet(); // Update snippets initially\n\n    // subscribe to selection change and editor activation events\n    const subscriptions: Disposable[] = [];\n    workspace.onDidSaveTextDocument(this._onEvent, this, subscriptions);\n    window.onDidChangeActiveTextEditor(this._onEvent, this, subscriptions);\n\n    // update the counter for the current file\n    this.snippetUpdater.updateSnippet();\n\n    // create a combined disposable from both event subscriptions\n    this._disposable = Disposable.from(...subscriptions);\n  }\n\n  dispose() {\n    this._disposable.dispose();\n  }\n\n  private _onEvent() {\n    this.snippetUpdater.updateSnippet();\n  }\n}\n\nexport class PrologCompletionProvider {\n  // Provides completion items for Prolog code (auto completion)\n  public provideCompletionItems(\n    document: TextDocument,\n    position: Position,\n    token: CancellationToken,\n    context: CompletionContext\n  ) {\n    // Array to store completion items\n    const snippetCompletion = [];\n    // Iterate through new snippets and create completion items\n    Utils.newsnippets.forEach(elem => {\n      const params = elem[1].split(','); // Split parameters of the snippet\n      const completionItem = new CompletionItem(\n        elem[0] + '/' + params.length,\n        CompletionItemKind.Function\n      ); // Create a new CompletionItem for each snippet\n      // Construct the snippet text with placeholders for parameters\n      let str = elem[0].toString() + '(';\n      let str2 = '';\n      for (let i = 0; i < params.length; i++) {\n        str = str + '${' + (i + 2).toString() + ':' + params[i] + '}';\n        str2 = str2 + '<span style=\"color:#ff7878;\">' + params[i] + '</span>';\n        if (i != params.length - 1) {\n          str = str + ',';\n          str2 = str2 + ',';\n        }\n      }\n      str = str + ')$0';\n      // Set the insert text for the completion item as a SnippetString\n      completionItem.insertText = new SnippetString(str);\n      // Set documentation for the completion item\n      const docs: any = new MarkdownString();\n      docs.supportHtml = true;\n      if (elem[2] == null) {\n        docs.appendMarkdown(\n          '<span style=\"color:#8da9fc;\">' +\n            elem[0].toString() +\n            '</span>(' +\n            str2 +\n            ')</br>Custom predicate'\n        );\n      } else {\n        docs.appendMarkdown(\n          '<span style=\"color:#8da9fc;\">' +\n            elem[0].toString() +\n            '</span>(' +\n            str2 +\n            ')</br>' +\n            elem[2].replace('\\n', '</br>')\n        );\n      }\n      completionItem.documentation = docs;\n      completionItem.detail = elem[0] + '/' + params.length; // Set additional details for the completion item\n      snippetCompletion.push(completionItem); // Add the completion item to the array\n    });\n    return snippetCompletion; // Return the array of completion items\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\formatHelpResponse.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\modules\\chatHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TelemetryData' is defined but never used.","line":11,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nimport {\n  ChatRequest,\n  ChatResponseStream,\n  CancellationToken,\n  ChatResult,\n  workspace,\n} from 'vscode';\nimport { PrologBackend } from '../prologBackend';\nimport { TelemetryCollector, TelemetryData } from './telemetryCollector';\n\nexport class ChatHandler {\n  private prologBackend: PrologBackend | null = null;\n  private telemetry: TelemetryCollector;\n\n  constructor(prologBackend: PrologBackend | null, telemetry: TelemetryCollector) {\n    this.prologBackend = prologBackend;\n    this.telemetry = telemetry;\n  }\n\n  // Update backend reference\n  updateBackend(backend: PrologBackend | null) {\n    this.prologBackend = backend;\n  }\n\n  // Chat participant handler\n  async handleChatRequest(\n    request: ChatRequest,\n    context: any, // ChatContext type not available in current vscode API\n    stream: ChatResponseStream,\n    _token: CancellationToken\n  ): Promise<ChatResult> {\n    const startTime = Date.now();\n    let command = 'unknown';\n\n    try {\n      // Ensure backend is running\n      if (!this.prologBackend) {\n        stream.markdown(\n          '⚠️ **Backend Error**: Prolog backend not initialized. Please restart VS Code.'\n        );\n        this.telemetry.collect({\n          command: 'init_error',\n          success: false,\n          error: 'backend_not_initialized',\n          timestamp: startTime,\n        });\n        return { metadata: { command: 'error' } };\n      }\n\n      if (!this.prologBackend.isRunning()) {\n        stream.markdown('🔄 **Starting Prolog backend...**\\n\\n');\n        await this.startBackendWithProgress(stream);\n      }\n\n      // Parse command from request\n      const message = request.prompt.trim();\n      const parts = message.split(/\\s+/);\n      command = parts[0]?.toLowerCase() || 'unknown';\n\n      // Handle cancellation\n      if (_token.isCancellationRequested) {\n        stream.markdown('❌ **Request cancelled**');\n        this.telemetry.collect({ command, success: false, error: 'cancelled', timestamp: startTime });\n        return { metadata: { command: 'cancelled' } };\n      }\n\n      // Route to appropriate handler\n      switch (command) {\n        case '/query':\n        case 'query':\n          await this.handleQueryCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        case '/consult':\n        case 'consult':\n          await this.handleConsultCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        case '/help':\n        case 'help':\n          await this.handleHelpCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        case '/status':\n        case 'status':\n          await this.handleStatusCommand(stream);\n          break;\n        case '/n3_load':\n        case 'n3_load':\n          await this.handleN3LoadCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        case '/n3_list':\n        case 'n3_list':\n          await this.handleN3ListCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        case '/n3_reason':\n        case 'n3_reason':\n          await this.handleN3ReasonCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        case '/n3_explain':\n        case 'n3_explain':\n          await this.handleN3ExplainCommand(parts.slice(1).join(' '), stream, _token);\n          break;\n        default:\n          // Treat as a general query if no command prefix\n          if (message.trim()) {\n            await this.handleQueryCommand(message, stream, _token);\n          } else {\n            stream.markdown(this.getHelpMessage());\n          }\n          break;\n      }\n\n      this.telemetry.collect({ command, success: true, timestamp: startTime });\n      return { metadata: { command } };\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **Error**: ${errorMsg}`);\n      this.telemetry.collect({ command, success: false, error: errorMsg, timestamp: startTime });\n      return { metadata: { command: 'error' } };\n    }\n  }\n\n  // Start backend with progress indication\n  private async startBackendWithProgress(stream: ChatResponseStream): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.prologBackend) {\n        reject(new Error('Backend not initialized'));\n        return;\n      }\n\n      const timeout = setTimeout(() => {\n        reject(new Error('Backend startup timeout (30s)'));\n      }, 30000);\n\n      const onReady = () => {\n        clearTimeout(timeout);\n        this.prologBackend?.off('ready', onReady);\n        this.prologBackend?.off('error', onError);\n        stream.markdown('✅ **Prolog backend ready**\\n\\n');\n        resolve();\n      };\n\n      const onError = (error: any) => {\n        clearTimeout(timeout);\n        this.prologBackend?.off('ready', onReady);\n        this.prologBackend?.off('error', onError);\n        reject(new Error(`Backend startup failed: ${error}`));\n      };\n\n      this.prologBackend.on('ready', onReady);\n      this.prologBackend.on('error', onError);\n      this.prologBackend.start();\n    });\n  }\n\n  // Handle query commands with retry logic and progress indicators\n  private async handleQueryCommand(\n    query: string,\n    stream: ChatResponseStream,\n    _token: CancellationToken\n  ) {\n    if (!query.trim()) {\n      stream.markdown('❌ **Error**: Please provide a query. Example: `/query member(X, [1,2,3])`');\n      return;\n    }\n\n    stream.markdown(`🔍 **Querying**: \\`${query}\\`\\n\\n`);\n\n    const maxRetries = 3;\n    let lastError: any = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      if (_token.isCancellationRequested) {\n        stream.markdown('❌ **Query cancelled**');\n        return;\n      }\n\n      try {\n        if (!this.prologBackend?.isRunning()) {\n          throw new Error('Backend not running');\n        }\n\n        // Show progress for potentially long-running queries\n        stream.progress('🔄 Executing query...');\n\n        // Use streaming request for better performance with large result sets\n        const response = await this.prologBackend.sendStreamingRequest(\n          'query',\n          {\n            goal: query,\n            timeoutMs: 30000, // Increased timeout for large queries\n            streaming: true,\n            max_results_per_chunk: 50,\n          },\n          (chunk, isFirst, isLast) => {\n            // Handle streaming chunks\n            if (isFirst) {\n              stream.progress('📊 Processing results...');\n            }\n            if (!isLast) {\n              stream.progress(`📊 Processing chunk ${chunk.chunk_info?.chunk_index + 1}...`);\n            }\n          }\n        );\n\n        if (response.status === 'ok') {\n          if (response.results) {\n            // Check if this is a large result set\n            const isLargeResult =\n              response.streaming_info?.is_large_result || response.total_chunks > 1;\n\n            if (isLargeResult) {\n              const totalResults = response.streaming_info?.total_count || response.results.length;\n              const chunkSize = response.streaming_info?.chunk_size || response.results.length;\n\n              stream.markdown(\n                `✅ **Large Result Set** (${totalResults} total results, showing first ${chunkSize}):\\n\\n`\n              );\n              stream.markdown(\n                '*💡 Tip: Results are automatically chunked for better performance. Use pagination commands for more results.*\\n\\n'\n              );\n            } else {\n              stream.markdown('✅ **Results**:\\n\\n');\n            }\n\n            this.formatQueryResults(response.results, stream, response.streaming_info);\n\n            // Show pagination info if available\n            if (response.streaming_info?.has_more) {\n              stream.markdown(\n                `\\n📄 **Pagination**: Showing ${response.streaming_info.chunk_size} of ${response.streaming_info.total_count} results`\n              );\n              stream.markdown(\n                '\\n*Use `/query_next` to see more results or increase chunk size with `/query --chunk-size 100 your_query`*'\n              );\n            }\n          } else if (response.output) {\n            stream.markdown('✅ **Output**:\\n\\n');\n            stream.markdown(`\\`\\`\\`\\n${response.output}\\n\\`\\`\\``);\n          } else {\n            stream.markdown('✅ **Query succeeded** (no output)');\n          }\n          return;\n        } else {\n          throw new Error(response.error || 'Query failed');\n        }\n      } catch (error) {\n        lastError = error;\n        const errorMsg = error instanceof Error ? error.message : String(error);\n\n        if (attempt < maxRetries && !_token.isCancellationRequested) {\n          stream.markdown(`⚠️ **Attempt ${attempt} failed**: ${errorMsg}. Retrying...\\n\\n`);\n          stream.progress(`🔄 Retrying (${attempt + 1}/${maxRetries})...`);\n          await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff\n        }\n      }\n    }\n\n    // All retries failed\n    const errorMsg = lastError instanceof Error ? lastError.message : String(lastError);\n    stream.markdown(`❌ **Query failed after ${maxRetries} attempts**: ${errorMsg}`);\n\n    // Offer fallback\n    stream.markdown(\n      '\\n💡 **Fallback**: You can try running the query directly in a Prolog terminal.'\n    );\n  }\n\n  // Handle consult commands\n  private async handleConsultCommand(\n    filePath: string,\n    stream: ChatResponseStream,\n    __token: CancellationToken\n  ) {\n    if (!filePath.trim()) {\n      stream.markdown('❌ **Error**: Please provide a file path. Example: `/consult myfile.pl`');\n      return;\n    }\n\n    stream.markdown(`📁 **Consulting**: \\`${filePath}\\`\\n\\n`);\n\n    try {\n      if (!this.prologBackend?.isRunning()) {\n        throw new Error('Backend not running');\n      }\n\n      const response = await this.prologBackend.sendRequest('consult', {\n        file: filePath,\n        timeoutMs: 15000,\n      });\n\n      if (response.status === 'ok') {\n        stream.markdown(`✅ **File consulted successfully**: \\`${filePath}\\``);\n      } else {\n        throw new Error(response.error || 'Consult failed');\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **Consult failed**: ${errorMsg}`);\n\n      // Offer fallback\n      stream.markdown(\n        '\\n💡 **Fallback**: You can try loading the file using the \"Prolog: load document\" command.'\n      );\n    }\n  }\n\n  // Handle help commands\n  private async handleHelpCommand(\n    predicate: string,\n    stream: ChatResponseStream,\n    __token: CancellationToken\n  ) {\n    if (!predicate.trim()) {\n      stream.markdown(this.getHelpMessage());\n      return;\n    }\n\n    stream.markdown(`📖 **Getting help for**: \\`${predicate}\\`\\n\\n`);\n\n    try {\n      if (!this.prologBackend?.isRunning()) {\n        throw new Error('Backend not running');\n      }\n\n      const response = await this.prologBackend.sendRequest('help', {\n        predicate: predicate,\n        timeoutMs: 5000,\n      });\n\n      if (response.status === 'ok' && response.doc) {\n        this.formatHelpResponse(response.doc, stream);\n      } else {\n        throw new Error(response.error || 'Help not found');\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **Help lookup failed**: ${errorMsg}`);\n      stream.markdown(\n        `\\n💡 **Fallback**: Try searching the SWI-Prolog documentation online for \\`${predicate}\\`.`\n      );\n    }\n  }\n\n  // Handle status command\n  private async handleStatusCommand(stream: ChatResponseStream) {\n    stream.markdown('📊 **Prolog Extension Status**\\n\\n');\n\n    if (this.prologBackend) {\n      const isRunning = this.prologBackend.isRunning();\n      stream.markdown(`- **Backend**: ${isRunning ? '✅ Running' : '❌ Stopped'}\\n`);\n\n      if (isRunning) {\n        try {\n          const response = await this.prologBackend.sendRequest('version', { timeoutMs: 2000 });\n          if (response.status === 'ok') {\n            stream.markdown(`- **SWI-Prolog Version**: ${response.version}\\n`);\n          }\n        } catch (error) {\n          const errorMsg = error instanceof Error ? error.message : String(error);\n          console.warn('[Extension] Version check failed:', errorMsg);\n          stream.markdown(`- **Version Check**: ❌ Failed (${errorMsg})\\n`);\n        }\n      }\n    } else {\n      stream.markdown('- **Backend**: ❌ Not initialized\\n');\n    }\n\n    const config = workspace.getConfiguration('prolog');\n    stream.markdown(`- **Executable Path**: \\`${config.get('executablePath', 'swipl')}\\`\\n`);\n    stream.markdown(`- **Dialect**: ${config.get('dialect', 'swi')}\\n`);\n\n    const stats = this.telemetry.getStats();\n    if (stats) {\n      stream.markdown(`- **Commands Used**: ${stats.totalCommands}\\n`);\n    }\n  }\n\n  // Handle N3 load commands\n  private async handleN3LoadCommand(\n    args: string,\n    stream: ChatResponseStream,\n    __token: CancellationToken\n  ) {\n    const parts = args.trim().split(/\\s+/);\n\n    if (parts.length === 0 || !parts[0]) {\n      stream.markdown(\n        '❌ **Error**: Please provide a file path or N3 content. Examples:\\n- `/n3_load sample.n3`\\n- `/n3_load --content \"@prefix : <http://example.org/> . :socrates a :Person .\"`'\n      );\n      return;\n    }\n\n    try {\n      if (!this.prologBackend?.isRunning()) {\n        throw new Error('Backend not running');\n      }\n\n      let requestParams: any;\n\n      if (parts[0] === '--content') {\n        const content = parts.slice(1).join(' ');\n        stream.markdown(`📝 **Loading N3 content**...\\n\\n`);\n        requestParams = { content, timeoutMs: 15000 };\n      } else {\n        const filePath = parts[0];\n        stream.markdown(`📁 **Loading N3 file**: \\`${filePath}\\`\\n\\n`);\n        requestParams = { file: filePath, timeoutMs: 15000 };\n      }\n\n      const response = await this.prologBackend.sendRequest('n3_load', requestParams);\n\n      if (response.status === 'ok') {\n        stream.markdown(\n          `✅ **N3 data loaded successfully**\\n- **Triples loaded**: ${response.triples_count}\\n`\n        );\n      } else {\n        throw new Error(response.error || 'N3 load failed');\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **N3 load failed**: ${errorMsg}`);\n    }\n  }\n\n  // Handle N3 list commands with pagination\n  private async handleN3ListCommand(\n    args: string,\n    stream: ChatResponseStream,\n    __token: CancellationToken\n  ) {\n    try {\n      if (!this.prologBackend?.isRunning()) {\n        throw new Error('Backend not running');\n      }\n\n      const parts = args.trim().split(/\\s+/);\n      let limit = 50;\n      let offset = 0;\n      let format = 'readable';\n\n      // Parse arguments\n      for (let i = 0; i < parts.length; i++) {\n        if (parts[i] === '--limit' && i + 1 < parts.length) {\n          const nextPart = parts[i + 1];\n          limit = nextPart ? parseInt(nextPart) || 50 : 50;\n        } else if (parts[i] === '--offset' && i + 1 < parts.length) {\n          const nextPart = parts[i + 1];\n          offset = nextPart ? parseInt(nextPart) || 0 : 0;\n        } else if (parts[i] === '--format' && i + 1 < parts.length) {\n          const nextPart = parts[i + 1];\n          format = nextPart || 'readable';\n        }\n      }\n\n      stream.markdown(\n        `📋 **Listing N3 triples** (limit: ${limit}, offset: ${offset}, format: ${format})...\\n\\n`\n      );\n      stream.progress('🔄 Fetching triples...');\n\n      const response = await this.prologBackend.sendRequest('n3_list', {\n        limit,\n        offset,\n        format,\n        streaming: true,\n        timeoutMs: 15000,\n      });\n\n      if (response.status === 'ok') {\n        // Handle paginated response\n        if (response.pagination) {\n          const { total_count, returned_count, has_more, next_offset } = response.pagination;\n          stream.markdown(\n            `✅ **Found ${total_count} triples** (showing ${returned_count}, offset: ${offset}):\\n\\n`\n          );\n\n          if (response.triples && response.triples.length > 0) {\n            // Use compact format for large result sets\n            if (returned_count > 20) {\n              stream.markdown('```\\n');\n              response.triples.forEach((triple: any, index: number) => {\n                stream.markdown(\n                  `${offset + index + 1}. ${triple.subject} ${triple.predicate} ${triple.object}\\n`\n                );\n              });\n              stream.markdown('```\\n');\n            } else {\n              stream.markdown(\n                '| # | Subject | Predicate | Object |\\n|---|---------|-----------|--------|\\n'\n              );\n              response.triples.forEach((triple: any, index: number) => {\n                stream.markdown(\n                  `| ${offset + index + 1} | \\`${triple.subject}\\` | \\`${triple.predicate}\\` | \\`${triple.object}\\` |\\n`\n                );\n              });\n            }\n\n            // Show pagination controls\n            if (has_more) {\n              stream.markdown(\n                `\\n📄 **Pagination**: Showing ${offset + 1}-${offset + returned_count} of ${total_count} triples`\n              );\n              stream.markdown(\n                `\\n*Use \\`/n3_list --offset ${next_offset} --limit ${limit}\\` for next page*`\n              );\n            }\n          } else {\n            stream.markdown('*No triples found.*');\n          }\n        } else {\n          // Legacy response format\n          const total_count = response.total_count || 0;\n          const returned_count = response.returned_count || 0;\n          stream.markdown(`✅ **Found ${total_count} triples** (showing ${returned_count}):\\n\\n`);\n\n          if (response.triples && response.triples.length > 0) {\n            stream.markdown('| Subject | Predicate | Object |\\n|---------|-----------|--------|\\n');\n            response.triples.forEach((triple: any) => {\n              stream.markdown(\n                `| \\`${triple.subject}\\` | \\`${triple.predicate}\\` | \\`${triple.object}\\` |\\n`\n              );\n            });\n          } else {\n            stream.markdown('*No triples found.*');\n          }\n        }\n      } else {\n        throw new Error(response.error || 'N3 list failed');\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **N3 list failed**: ${errorMsg}`);\n    }\n  }\n\n  // Handle N3 reason commands\n  private async handleN3ReasonCommand(\n    args: string,\n    stream: ChatResponseStream,\n    __token: CancellationToken\n  ) {\n    try {\n      if (!this.prologBackend?.isRunning()) {\n        throw new Error('Backend not running');\n      }\n\n      const goal = args.trim();\n\n      if (goal) {\n        stream.markdown(`🧠 **N3 reasoning with goal**: \\`${goal}\\`\\n\\n`);\n      } else {\n        stream.markdown(`🧠 **N3 reasoning** (finding all inferred triples)...\\n\\n`);\n      }\n\n      const response = await this.prologBackend.sendRequest('n3_reason', {\n        goal: goal || '',\n        timeoutMs: 15000,\n      });\n\n      if (response.status === 'ok') {\n        if (response.results) {\n          stream.markdown(`✅ **Reasoning results** (${response.count} found):\\n\\n`);\n          response.results.forEach((result: any, index: number) => {\n            stream.markdown(`**Result ${index + 1}**: \\`${JSON.stringify(result)}\\`\\n`);\n          });\n        } else if (response.inferred_triples) {\n          stream.markdown(`✅ **Inferred triples** (${response.count} found):\\n\\n`);\n          if (response.inferred_triples.length > 0) {\n            stream.markdown('| Subject | Predicate | Object |\\n|---------|-----------|--------|\\n');\n            response.inferred_triples.forEach((triple: any) => {\n              stream.markdown(\n                `| \\`${triple.subject}\\` | \\`${triple.predicate}\\` | \\`${triple.object}\\` |\\n`\n              );\n            });\n          } else {\n            stream.markdown('*No new triples inferred.*');\n          }\n        }\n      } else {\n        throw new Error(response.error || 'N3 reasoning failed');\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **N3 reasoning failed**: ${errorMsg}`);\n    }\n  }\n\n  // Handle N3 explain commands\n  private async handleN3ExplainCommand(\n    args: string,\n    stream: ChatResponseStream,\n    __token: CancellationToken\n  ) {\n    const goal = args.trim();\n\n    if (!goal) {\n      stream.markdown(\n        '❌ **Error**: Please provide a goal to explain. Example: `/n3_explain rdf(socrates, type, Mortal)`'\n      );\n      return;\n    }\n\n    try {\n      if (!this.prologBackend?.isRunning()) {\n        throw new Error('Backend not running');\n      }\n\n      stream.markdown(`🔍 **Explaining goal**: \\`${goal}\\`\\n\\n`);\n\n      const response = await this.prologBackend.sendRequest('n3_explain', {\n        goal,\n        timeoutMs: 15000,\n      });\n\n      if (response.status === 'ok') {\n        stream.markdown(`✅ **Proof explanation for**: \\`${response.goal}\\`\\n\\n`);\n        this.formatProofTree(response.proof, stream, 0);\n      } else {\n        throw new Error(response.error || 'N3 explanation failed');\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stream.markdown(`❌ **N3 explanation failed**: ${errorMsg}`);\n    }\n  }\n\n  // Format query results with streaming info\n  private formatQueryResults(results: any[], stream: ChatResponseStream, streamingInfo?: any) {\n    if (results.length === 0) {\n      stream.markdown('🔍 *No results found.*');\n      return;\n    }\n\n    if (results.length === 1 && Array.isArray(results[0]) && results[0].length === 0) {\n      stream.markdown('✅ **true** (goal succeeded with no variable bindings)');\n      return;\n    }\n\n    // Count total bindings for better presentation\n    let totalBindings = 0;\n    results.forEach(result => {\n      if (Array.isArray(result)) {\n        totalBindings += result.length;\n      } else if (typeof result === 'object' && result !== null) {\n        totalBindings += Object.keys(result).length;\n      }\n    });\n\n    const displayCount = results.length;\n    const totalCount = streamingInfo?.total_count || displayCount;\n\n    if (streamingInfo?.is_large_result) {\n      stream.markdown(\n        `📊 **Showing ${displayCount} of ${totalCount} solution${totalCount > 1 ? 's' : ''}** with ${totalBindings} variable binding${totalBindings > 1 ? 's' : ''}:\\n\\n`\n      );\n    } else {\n      stream.markdown(\n        `📊 **Found ${displayCount} solution${displayCount > 1 ? 's' : ''}** with ${totalBindings} variable binding${totalBindings > 1 ? 's' : ''}:\\n\\n`\n      );\n    }\n\n    // Use more compact format for large result sets\n    const useCompactFormat = displayCount > 20 || streamingInfo?.is_large_result;\n\n    if (useCompactFormat) {\n      // Compact format for large results\n      stream.markdown('```\\n');\n      results.forEach((result, solutionIndex) => {\n        stream.markdown(`Solution ${solutionIndex + 1}:\\n`);\n        if (Array.isArray(result) && result.length > 0) {\n          result.forEach((binding: any) => {\n            if (typeof binding === 'object' && binding !== null) {\n              Object.entries(binding).forEach(([variable, value]) => {\n                stream.markdown(`  ${variable} = ${value}\\n`);\n              });\n            }\n          });\n        } else if (typeof result === 'object' && result !== null) {\n          Object.entries(result).forEach(([variable, value]) => {\n            stream.markdown(`  ${variable} = ${value}\\n`);\n          });\n        }\n        stream.markdown('\\n');\n      });\n      stream.markdown('```\\n');\n    } else {\n      // Table format for smaller results\n      stream.markdown('| Variable | Value | Solution |\\n|----------|-------|----------|\\n');\n\n      results.forEach((result, solutionIndex) => {\n        if (Array.isArray(result) && result.length > 0) {\n          result.forEach((binding: any) => {\n            if (typeof binding === 'object' && binding !== null) {\n              Object.entries(binding).forEach(([variable, value]) => {\n                stream.markdown(`| **${variable}** | \\`${value}\\` | ${solutionIndex + 1} |\\n`);\n              });\n            }\n          });\n        } else if (typeof result === 'object' && result !== null) {\n          Object.entries(result).forEach(([variable, value]) => {\n            stream.markdown(`| **${variable}** | \\`${value}\\` | ${solutionIndex + 1} |\\n`);\n          });\n        }\n      });\n    }\n  }\n\n  // Format help response (simplified version without problematic Unicode)\n  private formatHelpResponse(doc: any, stream: ChatResponseStream) {\n    stream.markdown(`# ${doc.name}/${doc.arity}\\n\\n`);\n\n    // Status badges\n    const badges = [];\n    if (doc.is_builtin) badges.push('**Built-in**');\n    if (doc.module && doc.module !== 'user') badges.push(`**Module**: \\`${doc.module}\\``);\n    if (doc.deterministic) badges.push('**Deterministic**');\n\n    if (badges.length > 0) {\n      stream.markdown(`${badges.join(' | ')}\\n\\n`);\n    }\n\n    if (doc.summary) {\n      stream.markdown(`## Description\\n\\n${doc.summary}\\n\\n`);\n    }\n\n    if (doc.args && doc.args.length > 0) {\n      stream.markdown('## Arguments\\n\\n');\n      doc.args.forEach((arg: any, index: number) => {\n        stream.markdown(`**${index + 1}. ${arg.name}** - ${arg.description}\\n\\n`);\n      });\n    }\n\n    if (doc.examples && doc.examples.length > 0) {\n      stream.markdown('## Examples\\n\\n');\n      doc.examples.forEach((example: string, index: number) => {\n        stream.markdown(`**Example ${index + 1}:**\\n\\`\\`\\`prolog\\n${example}\\n\\`\\`\\`\\n\\n`);\n      });\n    }\n\n    if (doc.see_also && doc.see_also.length > 0) {\n      stream.markdown('## See Also\\n\\n');\n      doc.see_also.forEach((related: string) => {\n        stream.markdown(`- \\`${related}\\`\\n`);\n      });\n      stream.markdown('\\n');\n    }\n  }\n\n  // Format proof tree for display\n  private formatProofTree(proof: any, stream: ChatResponseStream, depth: number) {\n    const indent = '  '.repeat(depth);\n\n    if (proof.type === 'proof') {\n      stream.markdown(`${indent}🎯 **Goal**: \\`${proof.goal}\\`\\n`);\n      if (proof.subproofs && proof.subproofs.length > 0) {\n        proof.subproofs.forEach((subproof: any) => {\n          this.formatProofTree(subproof, stream, depth + 1);\n        });\n      }\n    } else if (proof.type === 'fact') {\n      stream.markdown(`${indent}📋 **Fact**: \\`${proof.fact}\\`\\n`);\n    } else if (proof.type === 'inference') {\n      stream.markdown(`${indent}🔗 **Inference**: \\`${proof.inference}\\`\\n`);\n    } else if (proof.type === 'builtin') {\n      stream.markdown(`${indent}⚙️ **Builtin**: \\`${proof.builtin}\\`\\n`);\n    }\n  }\n\n  // Get help message\n  private getHelpMessage(): string {\n    return `# 🤖 Prolog Assistant\n\nWelcome! I'm your intelligent Prolog companion, ready to help with queries, file consultation, documentation lookup, and advanced N3 semantic reasoning.\n\n---\n\n## 🔍 **Core Commands**\n\n### **\\`/query <goal>\\`**\nExecute Prolog queries with intelligent result formatting\n- **Example**: \\`/query member(X, [1,2,3])\\`\n- **Example**: \\`/query append([1,2], [3,4], Result)\\`\n- **Tip**: You can omit \\`/query\\` for simple queries\n\n### **\\`/consult <file>\\`**\nLoad and consult Prolog files into the knowledge base\n- **Example**: \\`/consult family.pl\\`\n- **Example**: \\`/consult ./src/rules.pl\\`\n\n### **\\`/help <predicate>\\`**\nGet comprehensive documentation for predicates\n- **Example**: \\`/help member/2\\`\n- **Example**: \\`/help findall/3\\`\n- **Example**: \\`/help append\\`\n\n### **\\`/status\\`**\nCheck backend health and configuration\n- Shows SWI-Prolog version, backend status, and usage statistics\n\n---\n\n## 🧠 **N3 Semantic Web Commands**\n\n### **\\`/n3_load <file|--content>\\`**\nLoad N3/Turtle semantic data for reasoning\n- **File**: \\`/n3_load sample.n3\\`\n- **Inline**: \\`/n3_load --content \"@prefix : <http://example.org/> . :socrates a :Person .\"\\`\n\n### **\\`/n3_list [--limit N] [--format readable]\\`**\nBrowse loaded triples with smart formatting\n- **Example**: \\`/n3_list --limit 20\\`\n- **Example**: \\`/n3_list --format readable\\`\n\n### **\\`/n3_reason [goal]\\`**\nPerform intelligent N3 reasoning and inference\n- **All inferences**: \\`/n3_reason\\`\n- **Specific goal**: \\`/n3_reason rdf(X, type, Mortal)\\`\n\n### **\\`/n3_explain <goal>\\`**\nGenerate detailed proof trees with step-by-step explanations\n- **Example**: \\`/n3_explain rdf(socrates, type, Mortal)\\`\n\n---\n\n## 💡 **Pro Tips**\n\n- 🚀 **Quick queries**: Just type your goal directly (no \\`/query\\` needed)\n- ⏹️ **Cancel operations**: Use Ctrl+C for long-running tasks\n- 🔧 **Troubleshooting**: Run \\`/status\\` if commands aren't working\n- 🏷️ **Readable URIs**: N3 commands show prefixed names (e.g., \\`:socrates\\`)\n- 📊 **Rich results**: Variable bindings displayed in formatted tables\n- 🔄 **Auto-retry**: Failed queries automatically retry with exponential backoff\n\n---\n\n## 🎯 **Quick Start Examples**\n\n\\`\\`\\`prolog\n# Basic Prolog\nmember(X, [a,b,c])\nappend([1,2], [3,4], X)\n\n# File operations\n/consult family.pl\n/help findall/3\n\n# Semantic reasoning\n/n3_load sample.n3\n/n3_reason\n/n3_explain rdf(socrates, type, Mortal)\n\\`\\`\\`\n\n---\n\n*Ready to explore the power of logic programming and semantic reasoning? Just ask me anything!* ✨`;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\modules\\configurationManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":5,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nimport { ExtensionContext, workspace } from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport jsesc from 'jsesc';\nimport { Utils } from '../utils/utils';\nimport { PlatformUtils, getPlatform, getPlatformDefaults } from '../utils/platformUtils';\nimport { AuthConfig } from '../features/apiMiddleware';\n\nexport class ConfigurationManager {\n  private static instance: ConfigurationManager;\n\n  private constructor() {}\n\n  static getInstance(): ConfigurationManager {\n    if (!ConfigurationManager.instance) {\n      ConfigurationManager.instance = new ConfigurationManager();\n    }\n    return ConfigurationManager.instance;\n  }\n\n  // Initialization of workspace for dialect\n  async initForDialect(context: ExtensionContext): Promise<void> {\n    // get the user preferences for the extension\n    const section = workspace.getConfiguration('prolog');\n    const dialect = section.get<string>('dialect');\n\n    // Use platform-aware executable path resolution\n    let exec = section.get<string>('executablePath', '');\n    if (!exec) {\n      exec = getPlatformDefaults().defaultExecutablePath;\n    }\n    exec = PlatformUtils.normalizePath(exec);\n\n    Utils.LINTERTRIGGER = section.get<string>('linter.run') || 'never';\n    Utils.FORMATENABLED = section.get<boolean>('format.enabled') || false;\n    Utils.DIALECT = dialect || 'swi';\n    Utils.RUNTIMEPATH = jsesc(exec);\n\n    // Use platform-aware path construction\n    const exPath = PlatformUtils.normalizePath(context.extensionPath);\n    Utils.EXPATH = exPath;\n\n    // check if the dialect links have already been done\n    const diaFile = PlatformUtils.joinPath(exPath, '.vscode', 'dialect.json');\n\n    let lastDialect = '';\n    try {\n      if (await PlatformUtils.pathExists(diaFile)) {\n        const dialectContent = fs.readFileSync(diaFile, 'utf8');\n        lastDialect = JSON.parse(dialectContent).dialect;\n      }\n    } catch (error) {\n      // File doesn't exist or is invalid, continue with setup\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      console.log('[Platform] Dialect file not found or invalid, proceeding with setup:', errorMsg);\n    }\n\n    if (lastDialect === dialect) {\n      return;\n    }\n\n    // creating links for the right dialect using platform-aware paths\n    const symLinks = [\n      {\n        path: PlatformUtils.joinPath(exPath, 'syntaxes'),\n        srcFile: `prolog.${dialect}.tmLanguage.json`,\n        targetFile: 'prolog.tmLanguage.json',\n      },\n      {\n        path: PlatformUtils.joinPath(exPath, 'snippets'),\n        srcFile: `prolog.${dialect}.json`,\n        targetFile: 'prolog.json',\n      },\n    ];\n\n    await Promise.all(\n      symLinks.map(async link => {\n        const srcPath = PlatformUtils.joinPath(link.path, link.srcFile);\n        const targetPath = PlatformUtils.joinPath(link.path, link.targetFile);\n\n        // remove old link\n        try {\n          if (await PlatformUtils.pathExists(targetPath)) {\n            fs.unlinkSync(targetPath);\n          }\n        } catch (error) {\n          // Ignore errors when removing non-existent files, but log for debugging\n          const errorMsg = error instanceof Error ? error.message : String(error);\n          console.debug('[Platform] Failed to remove old symlink:', targetPath, errorMsg);\n        }\n\n        // make link\n        try {\n          // Try to create symlink, fallback to copy if symlink fails\n          try {\n            fs.symlinkSync(srcPath, targetPath);\n          } catch (error) {\n            // If symlink fails (e.g., on Windows without admin), copy the file\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            console.debug('[Platform] Symlink failed, falling back to copy:', errorMsg);\n            fs.copyFileSync(srcPath, targetPath);\n          }\n        } catch (err) {\n          const platform = getPlatform();\n          const errorMsg =\n            platform === 'windows'\n              ? 'VSC-Prolog failed in initialization. Try running VS Code as administrator or enable Developer Mode in Windows Settings.'\n              : 'VSC-Prolog failed in initialization. Check file permissions.';\n          console.error('[Extension] Initialization failed:', err);\n          throw new Error(errorMsg);\n        }\n      })\n    );\n\n    // Ensure .vscode directory exists\n    const vscodeDirPath = PlatformUtils.joinPath(exPath, '.vscode');\n    if (!(await PlatformUtils.pathExists(vscodeDirPath))) {\n      fs.mkdirSync(vscodeDirPath, { recursive: true });\n    }\n\n    // write the dialect to the json for later initialization\n    fs.writeFileSync(diaFile, JSON.stringify({ dialect: dialect }));\n  }\n\n  // Helper function to create auth configuration from VSCode settings\n  createAuthConfig(config: any): AuthConfig {\n    const method = config.get('apiServer.auth.method', 'api_key') as string;\n    // Ensure method is one of the valid values\n    const validMethods = ['api_key', 'jwt_token', 'local_only', 'oauth2'] as const;\n    const authMethod = validMethods.includes(method as any)\n      ? (method as (typeof validMethods)[number])\n      : 'api_key';\n\n    return {\n      method: authMethod,\n      apiKeys: config.get('apiServer.auth.apiKeys', []) as string[],\n      jwtSecret: config.get('apiServer.auth.jwtSecret', '') as string,\n      localOnly: config.get('apiServer.auth.localOnly', true) as boolean,\n      oauth2: {\n        providers: config.get('apiServer.auth.oauth2.providers', ['google', 'github']) as string[],\n        clientId: config.get('apiServer.auth.oauth2.clientId', '') as string,\n        clientSecret: config.get('apiServer.auth.oauth2.clientSecret', '') as string,\n        redirectUri: config.get('apiServer.auth.oauth2.redirectUri', '') as string,\n        scope: config.get('apiServer.auth.oauth2.scope', 'read') as string,\n      },\n      roles: {\n        admin: config.get('apiServer.auth.roles.admin', []) as string[],\n        agent: config.get('apiServer.auth.roles.agent', []) as string[],\n        readonly: config.get('apiServer.auth.roles.readonly', []) as string[],\n        limited: config.get('apiServer.auth.roles.limited', []) as string[],\n      },\n      quotas: {\n        admin: {\n          requestsPerMinute: config.get(\n            'apiServer.auth.quotas.admin.requestsPerMinute',\n            1000\n          ) as number,\n          maxConcurrentSessions: config.get(\n            'apiServer.auth.quotas.admin.maxConcurrentSessions',\n            50\n          ) as number,\n        },\n        agent: {\n          requestsPerMinute: config.get(\n            'apiServer.auth.quotas.agent.requestsPerMinute',\n            300\n          ) as number,\n          maxConcurrentSessions: config.get(\n            'apiServer.auth.quotas.agent.maxConcurrentSessions',\n            20\n          ) as number,\n        },\n        readonly: {\n          requestsPerMinute: config.get(\n            'apiServer.auth.quotas.readonly.requestsPerMinute',\n            100\n          ) as number,\n          maxConcurrentSessions: config.get(\n            'apiServer.auth.quotas.readonly.maxConcurrentSessions',\n            10\n          ) as number,\n        },\n        limited: {\n          requestsPerMinute: config.get(\n            'apiServer.auth.quotas.limited.requestsPerMinute',\n            30\n          ) as number,\n          maxConcurrentSessions: config.get(\n            'apiServer.auth.quotas.limited.maxConcurrentSessions',\n            5\n          ) as number,\n        },\n      },\n    };\n  }\n\n  // Get current configuration values\n  getConfiguration() {\n    const config = workspace.getConfiguration('prolog');\n    return {\n      dialect: config.get('dialect', 'swi') as string,\n      executablePath: config.get('executablePath', 'swipl') as string,\n      linterTrigger: config.get('linter.run', 'never') as string,\n      formatEnabled: config.get('format.enabled', false) as boolean,\n      apiServerEnabled: config.get('apiServer.enabled', false) as boolean,\n      webSocketEnabled: config.get('webSocketServer.enabled', true) as boolean,\n      telemetryEnabled: config.get('telemetry.enabled', false) as boolean,\n    };\n  }\n}","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\modules\\extensionManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PROLOG_MODE' is defined but never used. Allowed unused args must match /^_/u.","line":265,"column":68,"nodeType":null,"messageId":"unusedVar","endLine":265,"endColumn":79}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use strict';\n\nimport {\n  commands,\n  DocumentFilter,\n  ExtensionContext,\n  window,\n  languages,\n  workspace,\n  chat,\n  ChatRequest,\n  ChatResponseStream,\n  CancellationToken,\n  ThemeIcon,\n  ChatResult,\n  WorkspaceEdit,\n} from 'vscode';\nimport * as path from 'path';\nimport PrologTerminal from '../features/prologTerminal';\nimport { loadEditHelpers } from '../features/editHelpers';\nimport { Utils } from '../utils/utils';\nimport PrologHoverProvider from '../features/hoverProvider';\nimport PrologDocumentHighlightProvider from '../features/documentHighlightProvider';\nimport {\n  SnippetUpdater,\n  SnippetUpdaterController,\n  PrologCompletionProvider,\n} from '../features/updateSnippets';\nimport { PrologFormatter } from '../features/prologFormatter';\nimport { PrologDefinitionProvider } from '../features/definitionProvider';\nimport { PrologReferenceProvider } from '../features/referenceProvider';\nimport PrologLinter from '../features/prologLinter';\nimport { PrologRefactor } from '../features/prologRefactor';\nimport { PrologBackend } from '../prologBackend';\nimport { PrologLSPExtension } from '../features/prologLSPExtension';\nimport { PrologLSPClient } from '../features/prologLSPClient';\nimport { MultiIDESupport } from '../features/multiIDESupport';\nimport { ApiServer, ApiServerConfig } from '../features/apiServer';\nimport {\n  ExternalWebSocketManager,\n  ExternalWebSocketConfig,\n} from '../features/externalWebSocketManager';\nimport { SettingsWebviewProvider } from '../features/settingsWebviewProvider';\nimport { PrologActivityProvider } from '../features/prologActivityProvider';\nimport { PrologDashboardProvider } from '../features/prologDashboardProvider';\nimport { TelemetryCollector } from './telemetryCollector';\nimport { ChatHandler } from './chatHandler';\nimport { InstallationManager } from './installationManager';\nimport { ConfigurationManager } from './configurationManager';\n\nexport class ExtensionManager {\n  private static instance: ExtensionManager;\n  \n  // Global instances\n  private prologBackend: PrologBackend | null = null;\n  private prologLSPClient: PrologLSPClient | null = null;\n  private apiServer: ApiServer | null = null;\n  private externalWebSocketManager: ExternalWebSocketManager | null = null;\n  \n  // Module instances\n  private telemetry: TelemetryCollector;\n  private chatHandler: ChatHandler;\n  private installationManager: InstallationManager;\n  private configurationManager: ConfigurationManager;\n\n  private constructor() {\n    this.telemetry = new TelemetryCollector();\n    this.chatHandler = new ChatHandler(null, this.telemetry);\n    this.installationManager = InstallationManager.getInstance();\n    this.configurationManager = ConfigurationManager.getInstance();\n  }\n\n  static getInstance(): ExtensionManager {\n    if (!ExtensionManager.instance) {\n      ExtensionManager.instance = new ExtensionManager();\n    }\n    return ExtensionManager.instance;\n  }\n\n  // Main activation method\n  async activate(context: ExtensionContext): Promise<void> {\n    console.log('Congratulations, your extension \"vsc-prolog\" is now active! :)');\n\n    // Check SWI-Prolog installation before proceeding\n    await this.installationManager.checkAndHandleInstallation(context);\n\n    // Initialize workspace for dialect\n    await this.configurationManager.initForDialect(context);\n\n    // Initialize core extension features\n    await this.initializeCoreFeatures(context);\n\n    // Initialize backend and services\n    await this.initializeBackendServices(context);\n\n    // Register providers and UI components\n    this.registerProvidersAndUI(context);\n\n    // Start backend automatically (with error handling)\n    this.startBackend();\n  }\n\n  // Initialize core extension features\n  private async initializeCoreFeatures(context: ExtensionContext): Promise<void> {\n    // Filter the files to process\n    const PROLOG_MODE: DocumentFilter = { language: 'prolog', scheme: 'file' };\n\n    // Initialize utils class and load snippets file with its predicates\n    Utils.init(context);\n    \n    // Automatic indent on change\n    loadEditHelpers(context.subscriptions);\n\n    // Register extension commands\n    this.registerExtensionCommands(context);\n\n    // Register installation commands\n    this.installationManager.registerInstallationCommands(context);\n\n    // Initialize linter if enabled\n    this.initializeLinter(context, PROLOG_MODE);\n\n    // Register language providers\n    this.registerLanguageProviders(context, PROLOG_MODE);\n\n    // Initialize terminal and snippets\n    this.initializeTerminalAndSnippets(context, PROLOG_MODE);\n  }\n\n  // Register extension-specific commands\n  private registerExtensionCommands(context: ExtensionContext): void {\n    const myCommands = [\n      {\n        command: 'prolog.load.document',\n        callback: () => {\n          PrologTerminal.loadDocument();\n        },\n      },\n      {\n        command: 'prolog.query.goal',\n        callback: () => {\n          PrologTerminal.queryGoalUnderCursor();\n        },\n      },\n      {\n        command: 'prolog.refactorPredicate',\n        callback: () => {\n          new PrologRefactor().refactorPredUnderCursor();\n        },\n      },\n      {\n        command: 'prolog.openSettings',\n        callback: () => {\n          // This will be handled by the webview view registration\n        },\n      },\n      {\n        command: 'prolog.newFile',\n        callback: async () => {\n          await this.createNewPrologFile();\n        },\n      },\n      {\n        command: 'prolog.rerunQuery',\n        callback: async (query: string) => {\n          await this.rerunQuery(query);\n        },\n      },\n      {\n        command: 'prolog.clearQueryHistory',\n        callback: async () => {\n          window.showInformationMessage('Query history cleared');\n        },\n      },\n      {\n        command: 'prolog.viewLogs',\n        callback: () => {\n          commands.executeCommand('workbench.action.showLogs');\n        },\n      },\n      {\n        command: 'prolog.reportIssue',\n        callback: () => {\n          const issueUrl = 'https://github.com/mediaprophet/VSCode-Prolog-Toolkit/issues/new';\n          commands.executeCommand('vscode.open', issueUrl);\n        },\n      },\n    ];\n\n    // Register commands\n    myCommands.forEach(command => {\n      context.subscriptions.push(commands.registerCommand(command.command, command.callback));\n    });\n  }\n\n  // Initialize linter if enabled\n  private initializeLinter(context: ExtensionContext, PROLOG_MODE: DocumentFilter): void {\n    let linter: PrologLinter | undefined;\n    if (Utils.LINTERTRIGGER !== 'never') {\n      linter = new PrologLinter(context);\n      linter.activate();\n      \n      // Register linter commands\n      const linterCommands = [\n        {\n          command: 'prolog.linter.nextErrLine',\n          callback: () => {\n            linter?.nextErrLine();\n          },\n        },\n        {\n          command: 'prolog.linter.prevErrLine',\n          callback: () => {\n            linter?.prevErrLine();\n          },\n        },\n      ];\n\n      linterCommands.forEach(command => {\n        context.subscriptions.push(commands.registerCommand(command.command, command.callback));\n      });\n\n      // Register code actions provider\n      context.subscriptions.push(languages.registerCodeActionsProvider(PROLOG_MODE, linter));\n    }\n  }\n\n  // Register language providers\n  private registerLanguageProviders(context: ExtensionContext, PROLOG_MODE: DocumentFilter): void {\n    // Hover provider\n    context.subscriptions.push(\n      languages.registerHoverProvider(PROLOG_MODE, new PrologHoverProvider())\n    );\n\n    // Highlight provider\n    context.subscriptions.push(\n      languages.registerDocumentHighlightProvider(PROLOG_MODE, new PrologDocumentHighlightProvider())\n    );\n\n    // Definition provider (go to definition command)\n    context.subscriptions.push(\n      languages.registerDefinitionProvider(PROLOG_MODE, new PrologDefinitionProvider())\n    );\n\n    // Reference provider (find all references command)\n    context.subscriptions.push(\n      languages.registerReferenceProvider(PROLOG_MODE, new PrologReferenceProvider())\n    );\n\n    // Auto completion provider\n    context.subscriptions.push(\n      languages.registerCompletionItemProvider(PROLOG_MODE, new PrologCompletionProvider())\n    );\n\n    // File formatting provider\n    context.subscriptions.push(\n      languages.registerDocumentRangeFormattingEditProvider(PROLOG_MODE, new PrologFormatter())\n    );\n    context.subscriptions.push(\n      languages.registerDocumentFormattingEditProvider(PROLOG_MODE, new PrologFormatter())\n    );\n  }\n\n  // Initialize terminal and snippets\n  private initializeTerminalAndSnippets(context: ExtensionContext, PROLOG_MODE: DocumentFilter): void {\n    // Create prolog terminal (load file command)\n    context.subscriptions.push(PrologTerminal.init());\n\n    // Add created predicate to the snippet\n    const snippetUpdater = new SnippetUpdater();\n    context.subscriptions.push(new SnippetUpdaterController(snippetUpdater));\n    context.subscriptions.push(snippetUpdater);\n  }\n\n  // Initialize backend and services\n  private async initializeBackendServices(context: ExtensionContext): Promise<void> {\n    const config = workspace.getConfiguration('prolog');\n    const swiplPath = config.get('executablePath', 'swipl') as string;\n\n    // Initialize Prolog backend\n    this.prologBackend = new PrologBackend({\n      swiplPath,\n      port: 3060,\n      streamingEnabled: true,\n      maxResultsPerChunk: 50,\n    });\n\n    // Update chat handler with backend reference\n    this.chatHandler.updateBackend(this.prologBackend);\n\n    // Initialize API server if enabled\n    await this.initializeApiServer(config);\n\n    // Initialize LSP services\n    await this.initializeLSPServices(context);\n\n    // Generate multi-IDE configurations\n    await this.initializeMultiIDESupport();\n\n    // Set up backend event handlers\n    this.setupBackendEventHandlers();\n  }\n\n  // Initialize API server if enabled\n  private async initializeApiServer(config: any): Promise<void> {\n    const apiServerEnabled = config.get('apiServer.enabled', false) as boolean;\n    if (apiServerEnabled && this.prologBackend) {\n      try {\n        const apiServerConfig: ApiServerConfig = {\n          enabled: true,\n          port: config.get('apiServer.port', 8080) as number,\n          host: config.get('apiServer.host', 'localhost') as string,\n          corsOrigins: config.get('apiServer.corsOrigins', ['http://localhost:*']) as string[],\n          maxConnections: config.get('apiServer.maxConnections', 100) as number,\n          requestTimeout: config.get('apiServer.requestTimeout', 60000) as number,\n          rateLimiting: {\n            enabled: config.get('apiServer.rateLimiting.enabled', true) as boolean,\n            requestsPerMinute: config.get('apiServer.rateLimiting.requestsPerMinute', 60) as number,\n            burstLimit: config.get('apiServer.rateLimiting.burstLimit', 10) as number,\n          },\n          auth: this.configurationManager.createAuthConfig(config),\n        };\n\n        this.apiServer = new ApiServer({\n          config: apiServerConfig,\n          prologBackend: this.prologBackend,\n        });\n\n        // Initialize external WebSocket manager if enabled\n        const wsEnabled = config.get('webSocketServer.enabled', true) as boolean;\n        if (wsEnabled) {\n          const wsConfig: ExternalWebSocketConfig = {\n            enabled: true,\n            port: config.get('webSocketServer.port', 8081) as number,\n            maxConnections: config.get('webSocketServer.maxConnections', 50) as number,\n            heartbeatInterval: config.get('webSocketServer.heartbeatInterval', 30) as number,\n            auth: apiServerConfig.auth,\n          };\n\n          this.externalWebSocketManager = new ExternalWebSocketManager(\n            wsConfig,\n            this.prologBackend.getNotificationManager()\n          );\n        }\n\n        console.log('[Extension] API server and WebSocket manager initialized');\n      } catch (error) {\n        console.error('[Extension] Failed to initialize API server:', error);\n        window.showErrorMessage(`Failed to initialize API server: ${error}`);\n      }\n    }\n  }\n\n  // Initialize LSP services\n  private async initializeLSPServices(context: ExtensionContext): Promise<void> {\n    if (!this.prologBackend) return;\n\n    // Initialize LSP Extension (legacy support)\n    const lspExtension = new PrologLSPExtension(context, this.prologBackend);\n    lspExtension.registerFeatures();\n    context.subscriptions.push(lspExtension);\n\n    // Initialize full LSP Client\n    this.prologLSPClient = new PrologLSPClient(context);\n\n    // Start LSP client\n    try {\n      await this.prologLSPClient.start();\n      console.log('[Extension] Prolog LSP Client started successfully');\n    } catch (error) {\n      console.error('[Extension] Failed to start Prolog LSP Client:', error);\n      window.showWarningMessage(\n        'Prolog LSP Client failed to start. Some features may not be available.'\n      );\n    }\n  }\n\n  // Initialize multi-IDE support\n  private async initializeMultiIDESupport(): Promise<void> {\n    const workspaceFolder = workspace.workspaceFolders?.[0];\n    if (workspaceFolder) {\n      try {\n        await MultiIDESupport.generateIDEConfigurations(workspaceFolder.uri.fsPath);\n        MultiIDESupport.generateLaunchConfigurations(workspaceFolder.uri.fsPath);\n\n        // Detect available IDEs\n        const availableIDEs = await MultiIDESupport.detectAvailableIDEs();\n        if (availableIDEs.length > 1) {\n          console.log('[Extension] Detected IDEs:', availableIDEs.join(', '));\n        }\n      } catch (error) {\n        console.error('[Extension] Failed to generate multi-IDE configurations:', error);\n      }\n    }\n  }\n\n  // Set up backend event handlers\n  private setupBackendEventHandlers(): void {\n    if (!this.prologBackend) return;\n\n    this.prologBackend.on('ready', () => {\n      console.log('[Extension] Prolog backend ready');\n      window.showInformationMessage('Prolog backend started successfully');\n    });\n\n    this.prologBackend.on('stopped', () => {\n      console.log('[Extension] Prolog backend stopped');\n      window.showWarningMessage('Prolog backend stopped');\n    });\n\n    this.prologBackend.on('restarted', () => {\n      console.log('[Extension] Prolog backend restarted');\n      window.showInformationMessage('Prolog backend restarted successfully');\n    });\n\n    this.prologBackend.on('error', error => {\n      console.error('[Extension] Prolog backend error:', error);\n      window.showErrorMessage(`Prolog backend error: ${error}`);\n    });\n  }\n\n  // Register providers and UI components\n  private registerProvidersAndUI(context: ExtensionContext): void {\n    // Register chat participant with enhanced followup provider\n    const chatParticipant = chat.createChatParticipant('prolog', \n      (request: ChatRequest, context: any, stream: ChatResponseStream, token: CancellationToken) =>\n        this.chatHandler.handleChatRequest(request, context, stream, token)\n    );\n    chatParticipant.iconPath = new ThemeIcon('symbol-class');\n    chatParticipant.followupProvider = {\n      provideFollowups(result: ChatResult, _context: any, __token: CancellationToken) {\n        return ExtensionManager.getInstance().getChatFollowups(result);\n      },\n    };\n    context.subscriptions.push(chatParticipant);\n\n    // Register settings webview provider\n    const settingsProvider = new SettingsWebviewProvider(context.extensionUri);\n    context.subscriptions.push(\n      window.registerWebviewViewProvider(SettingsWebviewProvider.viewType, settingsProvider)\n    );\n\n    // Register activity bar providers\n    const prologActivityProvider = new PrologActivityProvider(context);\n    const prologDashboardProvider = new PrologDashboardProvider(context.extensionUri);\n\n    context.subscriptions.push(\n      window.registerTreeDataProvider('prologActivity', prologActivityProvider),\n      window.registerTreeDataProvider('prologQueries', prologActivityProvider),\n      window.registerTreeDataProvider('prologFiles', prologActivityProvider),\n      window.registerWebviewViewProvider(PrologDashboardProvider.viewType, prologDashboardProvider)\n    );\n\n    // Refresh activity bar when installation status changes\n    const refreshActivityBar = () => {\n      prologActivityProvider.refresh();\n    };\n\n    // Listen for configuration changes to refresh activity bar\n    context.subscriptions.push(\n      workspace.onDidChangeConfiguration(event => {\n        if (event.affectsConfiguration('prolog')) {\n          refreshActivityBar();\n        }\n      })\n    );\n  }\n\n  // Get chat followups based on result\n  private getChatFollowups(result: ChatResult): any[] {\n    const followups = [];\n\n    // Context-aware followups based on command type\n    if (result.metadata?.command === 'query') {\n      followups.push({\n        prompt: '/status',\n        label: '🔧 Check backend status',\n      });\n      followups.push({\n        prompt: '/help findall/3',\n        label: '📖 Learn about findall/3',\n      });\n    }\n\n    if (result.metadata?.command === 'consult') {\n      followups.push({\n        prompt: '/query',\n        label: '🔍 Run a query',\n      });\n    }\n\n    if (result.metadata?.command === 'error') {\n      followups.push({\n        prompt: '/status',\n        label: '🚨 Check what went wrong',\n      });\n      followups.push({\n        prompt: '/help',\n        label: '❓ Show help',\n      });\n    }\n\n    if (result.metadata?.command === 'n3_load') {\n      followups.push({\n        prompt: '/n3_list --limit 10',\n        label: '📋 List loaded triples',\n      });\n      followups.push({\n        prompt: '/n3_reason',\n        label: '🧠 Start reasoning',\n      });\n    }\n\n    // Always include help as fallback\n    followups.push({\n      prompt: '/help',\n      label: '💡 Show all commands',\n    });\n\n    return followups;\n  }\n\n  // Start backend\n  private startBackend(): void {\n    try {\n      this.prologBackend?.start();\n    } catch (error) {\n      console.error('[Extension] Failed to start Prolog backend:', error);\n      // Don't show error immediately - let user trigger it via chat if needed\n    }\n  }\n\n  // Helper method to create new Prolog file\n  private async createNewPrologFile(): Promise<void> {\n    const fileName = await window.showInputBox({\n      prompt: 'Enter the name for the new Prolog file',\n      value: 'untitled.pl',\n      validateInput: value => {\n        if (!value) return 'File name cannot be empty';\n        if (!value.match(/\\.(pl|pro|prolog|plt|ecl)$/)) {\n          return 'File must have a Prolog extension (.pl, .pro, .prolog, .plt, .ecl)';\n        }\n        return null;\n      },\n    });\n\n    if (fileName) {\n      const workspaceFolder = workspace.workspaceFolders?.[0];\n      if (workspaceFolder) {\n        const uri = window.activeTextEditor?.document.uri || workspaceFolder.uri;\n        const newFileUri = uri.with({ path: path.join(path.dirname(uri.fsPath), fileName) });\n        const edit = new WorkspaceEdit();\n        edit.createFile(newFileUri, { ignoreIfExists: false });\n        await workspace.applyEdit(edit);\n        await window.showTextDocument(newFileUri);\n      } else {\n        const doc = await workspace.openTextDocument({\n          language: 'prolog',\n          content: `% ${fileName}\\n% New Prolog file\\n\\n`,\n        });\n        await window.showTextDocument(doc);\n      }\n    }\n  }\n\n  // Helper method to rerun query\n  private async rerunQuery(query: string): Promise<void> {\n    if (query && this.prologBackend?.isRunning()) {\n      try {\n        const response = await this.prologBackend.sendRequest('query', { goal: query });\n        if (response.status === 'ok') {\n          window.showInformationMessage(`Query executed: ${query}`);\n        } else {\n          window.showErrorMessage(`Query failed: ${response.error}`);\n        }\n      } catch (error) {\n        window.showErrorMessage(`Query error: ${error}`);\n      }\n    }\n  }\n\n  // Deactivation method\n  async deactivate(): Promise<void> {\n    // Stop API server\n    if (this.apiServer) {\n      try {\n        await this.apiServer.stop();\n        console.log('[Extension] API server stopped');\n      } catch (error) {\n        console.error('[Extension] Error stopping API server:', error);\n      }\n      this.apiServer = null;\n    }\n\n    // Stop external WebSocket manager\n    if (this.externalWebSocketManager) {\n      try {\n        await this.externalWebSocketManager.stop();\n        console.log('[Extension] External WebSocket manager stopped');\n      } catch (error) {\n        console.error('[Extension] Error stopping WebSocket manager:', error);\n      }\n      this.externalWebSocketManager = null;\n    }\n\n    // Stop LSP client\n    if (this.prologLSPClient) {\n      try {\n        await this.prologLSPClient.stop();\n        console.log('[Extension] Prolog LSP Client stopped');\n      } catch (error) {\n        console.error('[Extension] Error stopping LSP Client:', error);\n      }\n      this.prologLSPClient = null;\n    }\n\n    // Stop backend\n    if (this.prologBackend) {\n      this.prologBackend.stop(true);\n      this.prologBackend = null;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\modules\\installationManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\modules\\telemetryCollector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\prologBackend.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":3,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScheduledQuery' is defined but never used.","line":16,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_omit' is assigned a value but never used.","line":285,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'batchToSend' is assigned a value but never used.","line":327,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":327,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_omit' is assigned a value but never used.","line":380,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":380,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_omit' is assigned a value but never used.","line":508,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":508,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_omit' is assigned a value but never used.","line":689,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":689,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'installationGuide' is assigned a value but never used.","line":1223,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1223,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChildProcessWithoutNullStreams, spawn, Signals } from 'child_process';\nimport { EventEmitter } from 'events';\nimport * as path from 'path';\nimport { v4 as uuidv4 } from 'uuid';\nimport axios from 'axios';\nimport { Timeout } from 'node:timers';\nimport { PlatformUtils } from './utils/platformUtils';\nimport { ExecutableFinder } from './utils/executableFinder';\nimport {\n  QueryNotificationManager,\n  QueryCallback,\n  QueryNotificationOptions,\n} from './features/queryNotificationManager';\nimport { ConcurrencyManager, ResourceQuota, QueryPriority } from './features/concurrencyManager';\nimport { QueryHistoryManager, QueryHistoryOptions } from './features/queryHistoryManager';\nimport { QueryScheduler, ScheduledQuery } from './features/queryScheduler';\nimport { SessionManager, SessionManagerOptions } from './features/sessionManager';\nimport { InstallationGuide } from './features/installationGuide';\nimport { UIHandler, defaultUIHandler } from './features/uiHandler';\n\nexport interface PrologBackendOptions {\n  swiplPath?: string;\n  args?: string[];\n  cwd?: string;\n  port?: number;\n  maxResultsPerChunk?: number;\n  streamingEnabled?: boolean;\n  notificationOptions?: QueryNotificationOptions;\n  concurrencyOptions?: {\n    resourceQuota?: Partial<ResourceQuota>;\n    enabled?: boolean;\n  };\n  historyOptions?: Partial<QueryHistoryOptions>;\n  schedulerOptions?: {\n    enabled?: boolean;\n    maxScheduledQueries?: number;\n    checkInterval?: number;\n    enableRecurring?: boolean;\n    enableConditional?: boolean;\n    enableDependencies?: boolean;\n  };\n  sessionOptions?: Partial<SessionManagerOptions>;\n  uiHandler?: UIHandler;\n}\n\nexport class PrologBackend extends EventEmitter {\n  private process: ChildProcessWithoutNullStreams | null = null;\n  private options: PrologBackendOptions;\n  private isReady: boolean = false;\n  private pendingRequests: Map<\n    string,\n    { resolve: (v: any) => void; reject: (e: any) => void; timeout: Timeout }\n  > = new Map();\n  private intentionalStop: boolean = false;\n  private _suppressStoppedEvent: boolean = false;\n  private port: number;\n  private maxResultsPerChunk: number;\n  private streamingEnabled: boolean;\n  private notificationManager: QueryNotificationManager;\n  private concurrencyManager: ConcurrencyManager;\n  private historyManager: QueryHistoryManager;\n  private queryScheduler: QueryScheduler;\n  private sessionManager: SessionManager;\n  private runningQueries: Map<string, { cancel: () => void }> = new Map();\n  private uiHandler: UIHandler;\n\n  // Logging and diagnostics\n  private log(msg: string) {\n    // In production, use a proper logger or VS Code output channel\n    console.log('[PrologBackend]', msg);\n  }\n\n  constructor(options: PrologBackendOptions = {}) {\n    super();\n    this.options = options;\n    this.port = options.port || 3060;\n    this.maxResultsPerChunk = options.maxResultsPerChunk || 50;\n    this.streamingEnabled = options.streamingEnabled ?? true;\n    this.uiHandler = options.uiHandler || defaultUIHandler;\n\n    // Initialize notification manager\n    this.notificationManager = new QueryNotificationManager({\n      enableWebSocket: true,\n      webSocketPort: (options.port || 3060) + 2, // Use port + 2 for WebSocket\n      ...options.notificationOptions,\n    });\n\n    // Initialize concurrency manager\n    this.concurrencyManager = new ConcurrencyManager(\n      options.concurrencyOptions?.resourceQuota || {}\n    );\n\n    // Initialize history manager\n    this.historyManager = new QueryHistoryManager({\n      storageDir: PlatformUtils.joinPath(process.cwd(), '.prolog-history'),\n      ...options.historyOptions,\n    });\n\n    // Initialize query scheduler\n    this.queryScheduler = new QueryScheduler(\n      this.concurrencyManager,\n      this.historyManager,\n      options.schedulerOptions\n    );\n\n    // Initialize session manager\n    this.sessionManager = new SessionManager({\n      storageDir: PlatformUtils.joinPath(process.cwd(), '.prolog-sessions'),\n      ...options.sessionOptions,\n    });\n\n    // Set up integration between managers\n    this.sessionManager.setIntegrationManagers(this.concurrencyManager, this.historyManager);\n\n    // Set up event handlers\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Set up event handlers for all managers\n   */\n  private setupEventHandlers(): void {\n    // Notification manager events\n    this.notificationManager.on('queryCancelled', (queryId: string) => {\n      this.handleQueryCancellation(queryId);\n    });\n\n    // Concurrency manager events\n    this.concurrencyManager.on('executeQuery', async event => {\n      await this.handleConcurrencyManagerExecution(event);\n    });\n\n    this.concurrencyManager.on('queryCompleted', event => {\n      this.emit('queryCompleted', event);\n    });\n\n    this.concurrencyManager.on('resourceUsageUpdated', usage => {\n      this.emit('resourceUsageUpdated', usage);\n    });\n\n    // History manager events\n    this.historyManager.on('queryAdded', entry => {\n      this.emit('queryHistoryAdded', entry);\n    });\n\n    // Scheduler events\n    this.queryScheduler.on('queryScheduleCompleted', query => {\n      this.emit('queryScheduleCompleted', query);\n    });\n\n    this.queryScheduler.on('queryScheduleExecutionStarted', query => {\n      this.emit('queryScheduleExecutionStarted', query);\n    });\n\n    // Session manager events\n    this.sessionManager.on('sessionCreated', event => {\n      this.emit('sessionCreated', event);\n    });\n\n    this.sessionManager.on('sessionSwitched', event => {\n      this.emit('sessionSwitched', event);\n    });\n\n    this.sessionManager.on('sessionDeleted', event => {\n      this.emit('sessionDeleted', event);\n    });\n\n    this.sessionManager.on('sessionStateSaved', event => {\n      this.emit('sessionStateSaved', event);\n    });\n\n    this.sessionManager.on('sessionStateRestored', event => {\n      this.emit('sessionStateRestored', event);\n    });\n  }\n\n  /**\n   * Handle query execution from concurrency manager\n   */\n  private async handleConcurrencyManagerExecution(event: any): Promise<void> {\n    const { query, resolve, reject } = event;\n\n    try {\n      // Execute the actual query\n      const result = await this.executeQueryDirect(query.cmd, query.params);\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  isRunning(): boolean {\n    return !!this.process;\n  }\n\n  stop(intentional = true) {\n    this.log(\n      '[DEBUG] stop() called. this.process=' +\n        !!this.process +\n        ', intentionalStop=' +\n        this.intentionalStop +\n        ', param=' +\n        intentional\n    );\n    if (this.process) {\n      this.intentionalStop = intentional;\n      if (intentional) {\n        this.log('[DEBUG] Setting intentionalStop=true and killing process');\n      } else {\n        this.log('[DEBUG] Killing process for restart (intentionalStop=false)');\n      }\n      this.process.kill();\n      this.process = null;\n      this.isReady = false;\n\n      // Cancel all running queries\n      this.runningQueries.forEach((query, queryId) => {\n        this.notificationManager.cancelQuery(queryId);\n      });\n      this.runningQueries.clear();\n\n      // Close all managers if intentional stop\n      if (intentional) {\n        this.notificationManager.close();\n        this.concurrencyManager.dispose();\n        this.historyManager.dispose();\n        this.queryScheduler.dispose();\n        this.sessionManager.dispose();\n      }\n\n      // Only emit 'stopped' if not in the middle of an automatic restart\n      if (!this._suppressStoppedEvent) {\n        this.log('[DEBUG] Emitting stopped event');\n        this.emit('stopped');\n      } else {\n        this.log('[DEBUG] Suppressed stopped event');\n      }\n      this.log('Prolog backend stopped.');\n    }\n  }\n\n  restart() {\n    this.log('Restarting Prolog backend...');\n    // Do not set intentionalStop=true for restarts\n    this.stop(false);\n    this.start();\n  }\n\n  /**\n   * Handle query cancellation\n   */\n  private handleQueryCancellation(queryId: string): void {\n    const query = this.runningQueries.get(queryId);\n    if (query) {\n      query.cancel();\n      this.runningQueries.delete(queryId);\n      this.log(`[DEBUG] Cancelled query ${queryId}`);\n    }\n  }\n\n  async sendRequest(\n    cmdOrBatch: string | Array<{ cmd: string; params?: Record<string, any>; timeoutMs?: number }>,\n    params: Record<string, any> = {}\n  ): Promise<any> {\n    if (!this.isReady) {\n      throw new Error('Prolog backend not ready');\n    }\n    // Single request\n    if (typeof cmdOrBatch === 'string') {\n      const cmd = cmdOrBatch;\n      const id = uuidv4();\n      const timeoutMs = typeof params.timeoutMs === 'number' ? params.timeoutMs : 10000;\n      const paramsWithLimit = { ...params };\n      if (typeof paramsWithLimit.time_limit === 'undefined') {\n        paramsWithLimit.time_limit = Math.ceil(timeoutMs / 1000);\n      }\n\n      // Add streaming parameters if enabled\n      if (this.streamingEnabled && !paramsWithLimit.disable_streaming) {\n        paramsWithLimit.max_results_per_chunk =\n          paramsWithLimit.max_results_per_chunk || this.maxResultsPerChunk;\n        paramsWithLimit.streaming = true;\n      }\n\n      const { timeoutMs: _omit, ...paramsNoTimeout } = paramsWithLimit;\n      const request = {\n        id,\n        cmd,\n        ...paramsNoTimeout,\n        protocol: 1,\n      };\n      const timeout = setTimeout(() => {\n        throw new Error('Prolog request timeout');\n      }, timeoutMs);\n      try {\n        const response = await axios.post(`http://localhost:${this.port}`, request);\n        clearTimeout(timeout);\n        return response.data;\n      } catch (err) {\n        clearTimeout(timeout);\n        throw err;\n      }\n    }\n    // Batch request\n    const batch = cmdOrBatch.map(req => {\n      const id = uuidv4();\n      const paramsWithLimit = { ...(req.params || {}) };\n      if (typeof req.timeoutMs === 'number' && typeof paramsWithLimit.time_limit === 'undefined') {\n        paramsWithLimit.time_limit = Math.ceil(req.timeoutMs / 1000);\n      }\n\n      // Add streaming parameters if enabled\n      if (this.streamingEnabled && !paramsWithLimit.disable_streaming) {\n        paramsWithLimit.max_results_per_chunk =\n          paramsWithLimit.max_results_per_chunk || this.maxResultsPerChunk;\n        paramsWithLimit.streaming = true;\n      }\n\n      return {\n        id,\n        cmd: req.cmd,\n        ...paramsWithLimit,\n        protocol: 1,\n        timeoutMs: req.timeoutMs,\n      };\n    });\n    const batchToSend = batch.map(({ timeoutMs: _omit, ...toSend }) => toSend);\n    const responses = await Promise.all(\n      batch.map(async req => {\n        const timeout = setTimeout(() => {\n          throw new Error('Prolog request timeout in batch');\n        }, req.timeoutMs || 10000);\n        try {\n          const response = await axios.post(`http://localhost:${this.port}`, req);\n          clearTimeout(timeout);\n          return response.data;\n        } catch (err) {\n          clearTimeout(timeout);\n          throw err;\n        }\n      })\n    );\n    return responses;\n  }\n\n  /**\n   * Send request with notification support\n   */\n  async sendRequestWithNotifications(\n    cmdOrBatch: string | Array<{ cmd: string; params?: Record<string, any>; timeoutMs?: number }>,\n    params: Record<string, any> = {},\n    callback?: QueryCallback\n  ): Promise<any> {\n    if (!this.isReady) {\n      throw new Error('Prolog backend not ready');\n    }\n\n    // Single request with notifications\n    if (typeof cmdOrBatch === 'string') {\n      const cmd = cmdOrBatch;\n      const queryId = uuidv4();\n      const timeoutMs = typeof params.timeoutMs === 'number' ? params.timeoutMs : 10000;\n\n      // Register query for tracking\n      this.notificationManager.registerQuery(queryId, callback);\n      this.notificationManager.updateQueryStatus(queryId, { status: 'running' });\n\n      const paramsWithLimit = { ...params };\n      if (typeof paramsWithLimit.time_limit === 'undefined') {\n        paramsWithLimit.time_limit = Math.ceil(timeoutMs / 1000);\n      }\n\n      // Add streaming parameters if enabled\n      if (this.streamingEnabled && !paramsWithLimit.disable_streaming) {\n        paramsWithLimit.max_results_per_chunk =\n          paramsWithLimit.max_results_per_chunk || this.maxResultsPerChunk;\n        paramsWithLimit.streaming = true;\n      }\n\n      const { timeoutMs: _omit, ...paramsNoTimeout } = paramsWithLimit;\n      const request = {\n        id: queryId,\n        cmd,\n        ...paramsNoTimeout,\n        protocol: 1,\n      };\n\n      // Set up cancellation support\n      let cancelled = false;\n      const cancelToken = {\n        cancel: () => {\n          cancelled = true;\n        },\n      };\n      this.runningQueries.set(queryId, cancelToken);\n\n      const timeout = setTimeout(() => {\n        if (!cancelled) {\n          this.notificationManager.updateQueryStatus(queryId, { status: 'timeout' });\n          this.runningQueries.delete(queryId);\n        }\n      }, timeoutMs);\n\n      try {\n        // Simulate progress updates for long-running queries\n        const progressInterval = setInterval(() => {\n          if (!cancelled && this.runningQueries.has(queryId)) {\n            const elapsed =\n              Date.now() -\n              (this.notificationManager.getQueryStatus(queryId)?.startTime || Date.now());\n            const progress = Math.min(90, (elapsed / timeoutMs) * 100);\n            this.notificationManager.updateQueryProgress(queryId, progress, 'Processing query...');\n          } else {\n            clearInterval(progressInterval);\n          }\n        }, 1000);\n\n        const response = await axios.post(`http://localhost:${this.port}`, request);\n\n        clearTimeout(timeout);\n        clearInterval(progressInterval);\n        this.runningQueries.delete(queryId);\n\n        if (!cancelled) {\n          this.notificationManager.completeQuery(queryId, response.data);\n        }\n\n        return response.data;\n      } catch (err) {\n        clearTimeout(timeout);\n        this.runningQueries.delete(queryId);\n\n        if (!cancelled) {\n          this.notificationManager.failQuery(queryId, err);\n        }\n        throw err;\n      }\n    }\n\n    // Batch requests with notifications\n    const batch = cmdOrBatch.map((req, index) => {\n      const queryId = uuidv4();\n\n      // Register each batch item for tracking\n      this.notificationManager.registerQuery(queryId, callback, true, index, cmdOrBatch.length);\n\n      const paramsWithLimit = { ...(req.params || {}) };\n      if (typeof req.timeoutMs === 'number' && typeof paramsWithLimit.time_limit === 'undefined') {\n        paramsWithLimit.time_limit = Math.ceil(req.timeoutMs / 1000);\n      }\n\n      // Add streaming parameters if enabled\n      if (this.streamingEnabled && !paramsWithLimit.disable_streaming) {\n        paramsWithLimit.max_results_per_chunk =\n          paramsWithLimit.max_results_per_chunk || this.maxResultsPerChunk;\n        paramsWithLimit.streaming = true;\n      }\n\n      return {\n        id: queryId,\n        cmd: req.cmd,\n        ...paramsWithLimit,\n        protocol: 1,\n        timeoutMs: req.timeoutMs,\n      };\n    });\n\n    // Execute batch with individual tracking\n    const responses = await Promise.all(\n      batch.map(async (req, index) => {\n        const queryId = req.id;\n        this.notificationManager.updateQueryStatus(queryId, { status: 'running' });\n\n        // Set up cancellation support\n        let cancelled = false;\n        const cancelToken = {\n          cancel: () => {\n            cancelled = true;\n          },\n        };\n        this.runningQueries.set(queryId, cancelToken);\n\n        const timeout = setTimeout(() => {\n          if (!cancelled) {\n            this.notificationManager.updateQueryStatus(queryId, { status: 'timeout' });\n            this.runningQueries.delete(queryId);\n          }\n        }, req.timeoutMs || 10000);\n\n        try {\n          // Progress simulation for batch items\n          const progressInterval = setInterval(() => {\n            if (!cancelled && this.runningQueries.has(queryId)) {\n              const elapsed =\n                Date.now() -\n                (this.notificationManager.getQueryStatus(queryId)?.startTime || Date.now());\n              const progress = Math.min(90, (elapsed / (req.timeoutMs || 10000)) * 100);\n              this.notificationManager.updateQueryProgress(\n                queryId,\n                progress,\n                `Processing batch item ${index + 1}/${batch.length}...`\n              );\n            } else {\n              clearInterval(progressInterval);\n            }\n          }, 1000);\n\n          const { timeoutMs: _omit, ...reqToSend } = req;\n          const response = await axios.post(`http://localhost:${this.port}`, reqToSend);\n\n          clearTimeout(timeout);\n          clearInterval(progressInterval);\n          this.runningQueries.delete(queryId);\n\n          if (!cancelled) {\n            this.notificationManager.completeQuery(queryId, response.data);\n          }\n\n          return response.data;\n        } catch (err) {\n          clearTimeout(timeout);\n          this.runningQueries.delete(queryId);\n\n          if (!cancelled) {\n            this.notificationManager.failQuery(queryId, err);\n          }\n          throw err;\n        }\n      })\n    );\n\n    return responses;\n  }\n\n  /**\n   * Send a streaming request that can handle large result sets\n   */\n  async sendStreamingRequest(\n    cmd: string,\n    params: Record<string, any> = {},\n    onChunk?: (chunk: any, isFirst: boolean, isLast: boolean) => void\n  ): Promise<any> {\n    if (!this.isReady) {\n      throw new Error('Prolog backend not ready');\n    }\n\n    const streamingParams = {\n      ...params,\n      streaming: true,\n      max_results_per_chunk: params.max_results_per_chunk || this.maxResultsPerChunk,\n    };\n\n    // For now, we'll simulate streaming by chunking the response\n    // In a full implementation, this would use WebSockets or Server-Sent Events\n    const response = await this.sendRequest(cmd, streamingParams);\n\n    if (response.status === 'ok' && response.results && Array.isArray(response.results)) {\n      const results = response.results;\n      const chunkSize = this.maxResultsPerChunk;\n\n      if (results.length <= chunkSize) {\n        // Small result set, return as single chunk\n        if (onChunk) {\n          onChunk(response, true, true);\n        }\n        return response;\n      }\n\n      // Large result set, chunk it\n      const chunks = [];\n      for (let i = 0; i < results.length; i += chunkSize) {\n        const chunk = results.slice(i, i + chunkSize);\n        const isFirst = i === 0;\n        const isLast = i + chunkSize >= results.length;\n\n        const chunkResponse = {\n          ...response,\n          results: chunk,\n          chunk_info: {\n            chunk_index: Math.floor(i / chunkSize),\n            chunk_size: chunk.length,\n            total_results: results.length,\n            is_first: isFirst,\n            is_last: isLast,\n          },\n        };\n\n        chunks.push(chunkResponse);\n\n        if (onChunk) {\n          onChunk(chunkResponse, isFirst, isLast);\n        }\n      }\n\n      // Return summary response\n      return {\n        ...response,\n        results: results.slice(0, chunkSize), // First chunk\n        total_chunks: chunks.length,\n        streaming: true,\n        chunk_info: {\n          chunk_index: 0,\n          chunk_size: Math.min(chunkSize, results.length),\n          total_results: results.length,\n          is_first: true,\n          is_last: chunks.length === 1,\n        },\n      };\n    }\n\n    return response;\n  }\n\n  /**\n   * Get streaming configuration\n   */\n  getStreamingConfig() {\n    return {\n      enabled: this.streamingEnabled,\n      maxResultsPerChunk: this.maxResultsPerChunk,\n    };\n  }\n\n  /**\n   * Update streaming configuration\n   */\n  updateStreamingConfig(config: { enabled?: boolean; maxResultsPerChunk?: number }) {\n    if (config.enabled !== undefined) {\n      this.streamingEnabled = config.enabled;\n    }\n    if (config.maxResultsPerChunk !== undefined) {\n      this.maxResultsPerChunk = config.maxResultsPerChunk;\n    }\n  }\n\n  /**\n   * Get notification manager for direct access\n   */\n  getNotificationManager(): QueryNotificationManager {\n    return this.notificationManager;\n  }\n\n  /**\n   * Cancel a running query\n   */\n  cancelQuery(queryId: string): boolean {\n    return this.notificationManager.cancelQuery(queryId);\n  }\n\n  /**\n   * Get query status\n   */\n  getQueryStatus(queryId: string) {\n    return this.notificationManager.getQueryStatus(queryId);\n  }\n\n  /**\n   * Get all active queries\n   */\n  getActiveQueries() {\n    return this.notificationManager.getActiveQueries();\n  }\n\n  /**\n   * Get query statistics\n   */\n  getQueryStatistics() {\n    return this.notificationManager.getStatistics();\n  }\n\n  /**\n   * Execute a query directly (used internally by concurrency manager)\n   */\n  private async executeQueryDirect(cmd: string, params: Record<string, any> = {}): Promise<any> {\n    const id = uuidv4();\n    const timeoutMs = typeof params.timeoutMs === 'number' ? params.timeoutMs : 10000;\n    const paramsWithLimit = { ...params };\n    if (typeof paramsWithLimit.time_limit === 'undefined') {\n      paramsWithLimit.time_limit = Math.ceil(timeoutMs / 1000);\n    }\n\n    // Add streaming parameters if enabled\n    if (this.streamingEnabled && !paramsWithLimit.disable_streaming) {\n      paramsWithLimit.max_results_per_chunk =\n        paramsWithLimit.max_results_per_chunk || this.maxResultsPerChunk;\n      paramsWithLimit.streaming = true;\n    }\n\n    const { timeoutMs: _omit, ...paramsNoTimeout } = paramsWithLimit;\n    const request = {\n      id,\n      cmd,\n      ...paramsNoTimeout,\n      protocol: 1,\n    };\n\n    const timeout = setTimeout(() => {\n      throw new Error('Prolog request timeout');\n    }, timeoutMs);\n\n    try {\n      const response = await axios.post(`http://localhost:${this.port}`, request);\n      clearTimeout(timeout);\n      return response.data;\n    } catch (err) {\n      clearTimeout(timeout);\n      throw err;\n    }\n  }\n\n  /**\n   * Send request with advanced concurrency control\n   */\n  async sendRequestWithConcurrency(\n    cmd: string,\n    params: Record<string, any> = {},\n    priority: Partial<QueryPriority> = {},\n    resourceRequirements?: { memoryMB?: number; cpuPercent?: number }\n  ): Promise<any> {\n    if (!this.isReady) {\n      throw new Error('Prolog backend not ready');\n    }\n\n    const queryId = uuidv4();\n\n    // Queue the query with concurrency control\n    return await this.concurrencyManager.queueQuery(\n      queryId,\n      cmd,\n      params,\n      priority,\n      resourceRequirements\n    );\n  }\n\n  /**\n   * Schedule a query for future execution\n   */\n  async scheduleQuery(\n    cmd: string,\n    params: Record<string, any> = {},\n    scheduleType: 'immediate' | 'delayed' | 'recurring' | 'conditional' = 'immediate',\n    scheduleConfig: any = {},\n    priority: Partial<QueryPriority> = {},\n    metadata?: any\n  ): Promise<string> {\n    if (!this.isReady) {\n      throw new Error('Prolog backend not ready');\n    }\n\n    const queryId = uuidv4();\n\n    await this.queryScheduler.scheduleQuery(\n      queryId,\n      cmd,\n      params,\n      scheduleType,\n      scheduleConfig,\n      priority,\n      metadata\n    );\n\n    return queryId;\n  }\n\n  /**\n   * Cancel a scheduled query\n   */\n  async cancelScheduledQuery(queryId: string): Promise<boolean> {\n    return await this.queryScheduler.cancelScheduledQuery(queryId);\n  }\n\n  /**\n   * Get scheduled queries\n   */\n  getScheduledQueries(filter?: any): any[] {\n    return this.queryScheduler.getScheduledQueries(filter);\n  }\n\n  /**\n   * Get query history\n   */\n  async getQueryHistory(filter: any = {}): Promise<any> {\n    return await this.historyManager.getHistory(filter);\n  }\n\n  /**\n   * Get query history statistics\n   */\n  async getQueryHistoryStatistics(): Promise<any> {\n    return await this.historyManager.getStatistics();\n  }\n\n  /**\n   * Get concurrency manager status\n   */\n  getConcurrencyStatus(): any {\n    return this.concurrencyManager.getStatus();\n  }\n\n  /**\n   * Get scheduler statistics\n   */\n  getSchedulerStatistics(): any {\n    return this.queryScheduler.getStatistics();\n  }\n\n  /**\n   * Update resource quota\n   */\n  updateResourceQuota(newQuota: Partial<ResourceQuota>): void {\n    this.concurrencyManager.updateResourceQuota(newQuota);\n  }\n\n  /**\n   * Pause a recurring query\n   */\n  async pauseRecurringQuery(queryId: string): Promise<boolean> {\n    return await this.queryScheduler.pauseRecurringQuery(queryId);\n  }\n\n  /**\n   * Resume a paused recurring query\n   */\n  async resumeRecurringQuery(queryId: string): Promise<boolean> {\n    return await this.queryScheduler.resumeRecurringQuery(queryId);\n  }\n\n  /**\n   * Register a custom condition evaluator for conditional queries\n   */\n  registerConditionEvaluator(queryId: string, evaluator: () => boolean): void {\n    this.queryScheduler.registerConditionEvaluator(queryId, evaluator);\n  }\n\n  /**\n   * Clear query history\n   */\n  async clearQueryHistory(): Promise<void> {\n    await this.historyManager.clearHistory();\n  }\n\n  /**\n   * Get a specific query from history\n   */\n  async getQueryFromHistory(queryId: string): Promise<any> {\n    return await this.historyManager.getQuery(queryId);\n  }\n\n  /**\n   * Delete a query from history\n   */\n  async deleteQueryFromHistory(queryId: string): Promise<boolean> {\n    return await this.historyManager.deleteQuery(queryId);\n  }\n\n  // Session Management API\n\n  /**\n   * Create a new session\n   */\n  async createSession(\n    name: string,\n    options: {\n      description?: string;\n      userId?: string;\n      agentId?: string;\n      resourceQuota?: Partial<ResourceQuota>;\n      persistenceEnabled?: boolean;\n      autoSave?: boolean;\n      metadata?: Record<string, any>;\n    } = {}\n  ): Promise<string> {\n    const sessionId = await this.sessionManager.createSession(name, options);\n\n    // Also create session in Prolog backend\n    try {\n      await this.sendRequest('session_create', { name });\n    } catch (error) {\n      console.warn('[PrologBackend] Failed to create session in Prolog backend:', error);\n    }\n\n    return sessionId;\n  }\n\n  /**\n   * Switch to a different session\n   */\n  async switchToSession(sessionId: string): Promise<void> {\n    await this.sessionManager.switchToSession(sessionId);\n\n    // Also switch session in Prolog backend\n    try {\n      await this.sendRequest('session_switch', { session_id: sessionId });\n    } catch (error) {\n      console.warn('[PrologBackend] Failed to switch session in Prolog backend:', error);\n    }\n  }\n\n  /**\n   * Get current active session\n   */\n  getCurrentSession(): { sessionId: string; config: any; state: any } | null {\n    return this.sessionManager.getCurrentSession();\n  }\n\n  /**\n   * Get session by ID\n   */\n  getSession(sessionId: string): { config: any; state: any } | null {\n    return this.sessionManager.getSession(sessionId);\n  }\n\n  /**\n   * List all sessions\n   */\n  listSessions(filter?: {\n    userId?: string;\n    agentId?: string;\n    isActive?: boolean;\n    includeInactive?: boolean;\n  }): Array<{ sessionId: string; config: any }> {\n    return this.sessionManager.listSessions(filter);\n  }\n\n  /**\n   * Delete a session\n   */\n  async deleteSession(sessionId: string): Promise<boolean> {\n    const result = await this.sessionManager.deleteSession(sessionId);\n\n    // Also delete session in Prolog backend\n    if (result) {\n      try {\n        await this.sendRequest('session_delete', { session_id: sessionId });\n      } catch (error) {\n        console.warn('[PrologBackend] Failed to delete session in Prolog backend:', error);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Save current session state\n   */\n  async saveCurrentSessionState(): Promise<void> {\n    await this.sessionManager.saveCurrentSessionState();\n\n    // Also save state in Prolog backend\n    try {\n      await this.sendRequest('session_save_state', {});\n    } catch (error) {\n      console.warn('[PrologBackend] Failed to save session state in Prolog backend:', error);\n    }\n  }\n\n  /**\n   * Save session state\n   */\n  async saveSessionState(sessionId: string, state?: any): Promise<void> {\n    await this.sessionManager.saveSessionState(sessionId, state);\n\n    // Also save state in Prolog backend\n    try {\n      await this.sendRequest('session_save_state', { session_id: sessionId });\n    } catch (error) {\n      console.warn('[PrologBackend] Failed to save session state in Prolog backend:', error);\n    }\n  }\n\n  /**\n   * Restore session state\n   */\n  async restoreSessionState(sessionId: string, snapshotId?: string): Promise<void> {\n    await this.sessionManager.restoreSessionState(sessionId, snapshotId);\n\n    // Also restore state in Prolog backend\n    try {\n      await this.sendRequest('session_restore_state', { session_id: sessionId });\n    } catch (error) {\n      console.warn('[PrologBackend] Failed to restore session state in Prolog backend:', error);\n    }\n  }\n\n  /**\n   * Create a snapshot of session state\n   */\n  async createSessionSnapshot(\n    sessionId: string,\n    name: string,\n    description?: string\n  ): Promise<string> {\n    return await this.sessionManager.createSnapshot(sessionId, name, description);\n  }\n\n  /**\n   * Get session-specific concurrency manager\n   */\n  getSessionConcurrencyManager(sessionId: string): ConcurrencyManager | undefined {\n    return this.sessionManager.getSessionConcurrencyManager(sessionId);\n  }\n\n  /**\n   * Get session-specific history manager\n   */\n  getSessionHistoryManager(sessionId: string): QueryHistoryManager | undefined {\n    return this.sessionManager.getSessionHistoryManager(sessionId);\n  }\n\n  /**\n   * Update session resource quota\n   */\n  async updateSessionResourceQuota(\n    sessionId: string,\n    quota: Partial<ResourceQuota>\n  ): Promise<void> {\n    await this.sessionManager.updateSessionResourceQuota(sessionId, quota);\n  }\n\n  /**\n   * Get session statistics\n   */\n  async getSessionStatistics(sessionId: string): Promise<any> {\n    return this.sessionManager.getSessionStatistics(sessionId);\n  }\n\n  /**\n   * Export session state to file\n   */\n  async exportSessionState(sessionId: string, filePath: string): Promise<void> {\n    try {\n      await this.sendRequest('session_export', {\n        session_id: sessionId,\n        file_path: filePath,\n      });\n    } catch (error) {\n      console.error('[PrologBackend] Failed to export session state:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import session state from file\n   */\n  async importSessionState(sessionId: string, filePath: string): Promise<void> {\n    try {\n      await this.sendRequest('session_import', {\n        session_id: sessionId,\n        file_path: filePath,\n      });\n\n      // Refresh session state in TypeScript side\n      await this.sessionManager.restoreSessionState(sessionId);\n    } catch (error) {\n      console.error('[PrologBackend] Failed to import session state:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get session manager for direct access\n   */\n  getSessionManager(): SessionManager {\n    return this.sessionManager;\n  }\n\n  private handleExit(code: number | null, signal: Signals | null) {\n    this.log(\n      `[DEBUG] handleExit() called. code=${code}, signal=${signal}, intentionalStop=${this.intentionalStop}`\n    );\n    this.isReady = false;\n    this.emit('exit', code, signal);\n    this.log(`Prolog backend exited with code ${code}, signal ${signal}`);\n    // Automatic restart logic\n    if (!this.intentionalStop) {\n      this.log('[DEBUG] Scheduling automatic restart in 1s');\n      setTimeout(() => {\n        this.log('[DEBUG] Automatic restart: suppressing stopped event and listening for started');\n        this._suppressStoppedEvent = true;\n        const onStarted = () => {\n          this.log('[DEBUG] onStarted (auto-restart): emitting restarted');\n          this.off('started', onStarted);\n          this._suppressStoppedEvent = false;\n          this.emit('restarted');\n        };\n        this.on('started', onStarted);\n        this.start();\n      }, 1000); // restart after 1s\n    } else {\n      this.log('[DEBUG] Not auto-restarting because intentionalStop=true');\n    }\n    this.intentionalStop = false;\n  }\n\n  async start() {\n    this.log('[DEBUG] start() called. this.process=' + !!this.process);\n    if (this.process) {\n      this.log('Prolog backend already running.');\n      return;\n    }\n\n    // Enhanced executable resolution with permission checking\n    let swiplPath = this.options.swiplPath || PlatformUtils.getDefaultExecutablePath();\n\n    // Validate the configured path first\n    if (swiplPath && swiplPath !== PlatformUtils.getDefaultExecutablePath()) {\n      const normalizedPath = PlatformUtils.normalizePath(swiplPath);\n      if (await PlatformUtils.pathExists(normalizedPath)) {\n        if (await PlatformUtils.isExecutable(normalizedPath)) {\n          swiplPath = normalizedPath;\n        } else {\n          this.log(\n            `[WARNING] Configured SWI-Prolog path '${normalizedPath}' exists but lacks execute permissions`\n          );\n          // Try to find alternative\n          const executableFinder = new ExecutableFinder();\n          const detectionResult = await executableFinder.findSwiplExecutable();\n          if (detectionResult.found && detectionResult.path) {\n            swiplPath = detectionResult.path;\n            this.log(\n              `[INFO] Using alternative SWI-Prolog at '${swiplPath}' found via ${detectionResult.detectionMethod}`\n            );\n          }\n        }\n      } else {\n        this.log(`[WARNING] Configured SWI-Prolog path '${normalizedPath}' does not exist`);\n        // Try to find alternative\n        const executableFinder = new ExecutableFinder();\n        const detectionResult = await executableFinder.findSwiplExecutable();\n        if (detectionResult.found && detectionResult.path) {\n          swiplPath = detectionResult.path;\n          this.log(\n            `[INFO] Using alternative SWI-Prolog at '${swiplPath}' found via ${detectionResult.detectionMethod}`\n          );\n        }\n      }\n    } else {\n      // No specific path configured, use comprehensive detection\n      const executableFinder = new ExecutableFinder();\n      const detectionResult = await executableFinder.findSwiplExecutable();\n      if (detectionResult.found && detectionResult.path) {\n        swiplPath = detectionResult.path;\n        this.log(\n          `[INFO] Found SWI-Prolog at '${swiplPath}' via ${detectionResult.detectionMethod}`\n        );\n\n        // Check permissions\n        if (!detectionResult.permissions?.executable) {\n          this.log(`[WARNING] Found SWI-Prolog at '${swiplPath}' but it lacks execute permissions`);\n          const platform = PlatformUtils.getPlatform();\n          if (platform !== 'windows') {\n            this.log(`[SUGGESTION] Try fixing permissions with: chmod +x \"${swiplPath}\"`);\n          }\n        }\n      } else {\n        // Fallback to default\n        swiplPath = PlatformUtils.normalizePath(swiplPath);\n        this.log(`[WARNING] Could not find SWI-Prolog executable, using fallback: ${swiplPath}`);\n      }\n    }\n\n    const serverPath = PlatformUtils.resolvePath(__dirname, 'prolog_json_server.pl');\n    // Use proper escaping for cross-platform paths in Prolog\n    const prologPath = serverPath.replace(/\\\\/g, '/').replace(/'/g, \"''\");\n    const args = this.options.args || [\n      '-q',\n      '-f',\n      'none',\n      '-g',\n      `consult('${prologPath}'), main(${this.port})`,\n    ];\n    const cwd = PlatformUtils.normalizePath(this.options.cwd || process.cwd());\n\n    this.log('Spawning Prolog with:');\n    this.log('  swiplPath: ' + swiplPath);\n    this.log('  serverPath: ' + serverPath);\n    this.log('  args: ' + JSON.stringify(args));\n    this.process = spawn(swiplPath, args, {\n      cwd,\n      detached: false,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    this.isReady = false;\n    this.intentionalStop = false;\n\n    if (this.process) {\n      this.process.on('exit', (code, signal) => this.handleExit(code, signal));\n\n      // Capture stderr for debugging\n      this.process.stderr?.on('data', data => {\n        this.log(`[STDERR] ${data.toString()}`);\n      });\n\n      // Capture stdout for debugging\n      this.process.stdout?.on('data', data => {\n        this.log(`[STDOUT] ${data.toString()}`);\n      });\n\n      this.process.once('spawn', () => {\n        // Wait for server to start - increased delay for HTTP server initialization\n        setTimeout(() => {\n          this.sendRequest('version')\n            .then(output => {\n              this.isReady = true;\n              this.emit('ready');\n              this.emit('started');\n              this.log('Prolog backend started. Version: ' + output.version);\n            })\n            .catch(async err => {\n              this.log('Prolog handshake/version check failed: ' + err.message);\n\n              // Show enhanced error message for backend startup failures\n              if (err.code === 'ENOENT' || err.message?.includes('not found')) {\n                const action = await this.uiHandler.showErrorMessage(\n                  'SWI-Prolog backend failed to start. The Prolog backend requires SWI-Prolog to provide language features.',\n                  'Install SWI-Prolog',\n                  'Setup Wizard',\n                  'Configure Path',\n                  'Dismiss'\n                );\n\n                const installationGuide = InstallationGuide.getInstance();\n                switch (action) {\n                  case 'Install SWI-Prolog': {\n                    // In LSP context, we can't show the installation guide dialog\n                    // This would need to be handled by the extension\n                    console.log('SWI-Prolog installation required');\n                    break;\n                  }\n                  case 'Setup Wizard': {\n                    await this.uiHandler.executeCommand('prolog.setupWizard');\n                    break;\n                  }\n                  case 'Configure Path': {\n                    await this.uiHandler.executeCommand(\n                      'workbench.action.openSettings',\n                      'prolog.executablePath'\n                    );\n                    break;\n                  }\n                }\n              }\n\n              this.stop();\n            });\n        }, 2000); // Give more time for HTTP server to start\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\sdk\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\sdk\\prologApiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\sdk\\prologWebSocketClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\sdk\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\types\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\types\\backend.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\types\\configuration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\types\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\types\\vscode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\utils\\errorHandling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\utils\\executableFinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\utils\\platformUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\utils\\safeAccess.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\utils\\snippets_from_txt.ecl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\github-dev\\VSCode-Prolog-Toolkit\\src\\utils\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]